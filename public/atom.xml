<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>行云流水</title>
  <subtitle>却也碎碎念念</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weizhimiao.github.io/"/>
  <updated>2017-01-22T14:36:12.000Z</updated>
  <id>https://weizhimiao.github.io/</id>
  
  <author>
    <name>zhimiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入了解Redis之客户端C-服务器S设计与实现</title>
    <link href="https://weizhimiao.github.io/2017/01/22/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AFC-%E6%9C%8D%E5%8A%A1%E5%99%A8S%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2017/01/22/深入了解Redis之客户端C-服务器S设计与实现/</id>
    <published>2017-01-22T12:30:00.000Z</published>
    <updated>2017-01-22T14:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道<code>Redis</code>是一个典型的<code>C/S</code>设计程序，一个服务器可以与多个客户端建立连接。通过<code>I/O</code>多路复用技术实现的文件事件处理器，<code>Redis</code>服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p>
<p>所以，对于<code>Redis</code>我们分为这两部分来了解，</p>
<ul>
<li><code>Redis</code>服务器维护和管理客户端状态的方法</li>
<li><code>Redis</code>服务器的运行机制</li>
</ul>
<a id="more"></a>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的 <code>redisClient</code> 结构（客户端状态），这个结构保存了客户端当前的状态信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">typedef struct redisClent&#123;</div><div class="line"></div><div class="line">  // ...</div><div class="line">  // 客户端的套接字描述符</div><div class="line">  int fd;</div><div class="line">  // 客户端的名字</div><div class="line">  robj *name;</div><div class="line">  // 客户端的标识值（flag）</div><div class="line">  int flags;</div><div class="line">  // 输入缓冲区</div><div class="line">  sqs querybuf;</div><div class="line">  // 命令与命令参数</div><div class="line">  robj **argv;</div><div class="line">  // 命令参数个数</div><div class="line">  int argc;</div><div class="line">  //命令的实现函数</div><div class="line">  struct redisCommand *cmd;</div><div class="line">  //输出缓冲区</div><div class="line">  char buf[REDIS_REPLY_CHUNK_BYTES];</div><div class="line">  //</div><div class="line">  int bufpos;</div><div class="line">  // 身份认证相关属性</div><div class="line">  int authenticated;</div><div class="line">  //</div><div class="line">  time_t ctime;</div><div class="line">  time_t lastinteraction;</div><div class="line">  time_t obuf_soft_limit_reached_time;</div><div class="line"></div><div class="line">  // ...</div><div class="line"></div><div class="line">&#125; redisClient</div></pre></td></tr></table></figure></p>
<p><code>Redis</code>服务器状态结构的<code>clients</code>属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构(<code>redisClient</code>)，对客户端执行批量操作或者查找某个指定的客户端，都可以通过遍历 <code>clients</code> 链表来完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct redisServer &#123;</div><div class="line">  //...</div><div class="line"></div><div class="line">  // 一个链表，保存了所有客户端状态</div><div class="line">  list *clients;</div><div class="line"></div><div class="line">  //...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如图，是一个与三个客户端进行连接的服务器。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170116/clientsLianBiao.png" alt="clients 链表"></p>
<h3 id="客户端类型"><a href="#客户端类型" class="headerlink" title="客户端类型"></a>客户端类型</h3><p>按照处理的命令请求的来源，客户端可以分为以下两种：</p>
<ul>
<li><p>伪客户端</p>
<blockquote>
<p>处理来自<code>AOF</code>文件或者Lua脚本的命令请求。目前<code>Redis</code>会在两个地方用到伪客户端，</p>
<ul>
<li>用于载入 <code>AOF</code> 文件并还原数据库状态</li>
<li>用于执行<code>Lua</code>脚本中包含的<code>Redis</code>命令</li>
</ul>
</blockquote>
</li>
<li><p>普通客户端</p>
<blockquote>
<p>处理来自网络的普通命令请求。</p>
</blockquote>
</li>
</ul>
<p>两者的主要区别是，在客户端状态结构（<code>redisClient</code>）中的 <code>fd</code> 属性，伪客户端的该属性值为<code>-1</code>，普通客户端的该属性的值是普通客户端的套接字的描述符。</p>
<h3 id="客户端状态属性"><a href="#客户端状态属性" class="headerlink" title="客户端状态属性"></a>客户端状态属性</h3><p>客户端状态属性主要可以分为两类：</p>
<ul>
<li><p>比较通用的属性</p>
<ul>
<li>套接字描述，根据客户端端类型的不同，该属性的值可以是<code>-1</code> 或者是大于<code>-1</code> 的整数。</li>
<li>名字，默认情况下，一个连接到服务器的客户端是没有名字的，使用 <code>CLIENT setname</code> 可以为客户端设置一个名字。</li>
<li>标识，记录了客户端的角色（<code>role</code>）如，主服务器，从服务器，低版本的从服务器，专门处理<code>Lua</code>脚本的伪客户端；以及客户端目前所处的状态，如客户端正在执行<code>MONITOR</code>命令，客户端正在被<code>BRPOP</code>、<code>BLPOP</code>等命令阻塞，客户端正在执行事务等等。</li>
<li>输入缓冲区，用于保存客户端发送的命令请求。</li>
<li>命令与命令参数，保存命令参数以及命令参数个数。</li>
<li>命令的实现函数，保存命令的实现函数。</li>
<li>输出缓冲区，保存执行命令所得的命令回复内容。</li>
<li>身份验证，用于记录客户端是否通过了身份验证。</li>
<li>时间，记录创建客户端的时间、客户端与服务器最后一次交互的时间、输出缓冲区第一次到达软性限制的时间等等。</li>
</ul>
</li>
<li><p>和特定功能相关的属性</p>
<ul>
<li><code>db</code>属性（数据库操作时需要）</li>
<li><code>dictid</code>属性（数据库操作时需要）</li>
<li><code>mstate</code>属性（执行事务时需要）</li>
<li><code>watched_keys</code>属性（执行<code>WATCH</code>命令时需要）</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 clients 链表的末尾。</p>
<p>对于Lua脚本的伪客户端，服务器会在初始化时，创建负责执行Lua脚本中包含的<code>Redis</code>命令的伪客户端，并将这个伪客户端关联在服务器状态结构的 <code>lua_client</code> 属性中。且 <code>lua_client</code> 伪客户端会在服务器运行的整个生命周期中会一直存在，只有在服务器关闭时，这个伪客户端才会关闭。</p>
<p>对于用户载入 <code>AOF</code> 文件还原数据库的伪客户端，会在服务器载入<code>AOF</code>文件时创建，用于执行<code>AOF</code>文件包含的<code>Redis</code>命令，在完成载入操作之后，这个伪客户端就会关闭。</p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>对于一个普通客户端可以有多种原因而被关闭，</p>
<ul>
<li>客户端进程推出或者被杀死</li>
<li>客户单向服务器端发送了不符合协议格式的命令请求</li>
<li>客户端成为了 <code>CLIENT KILL</code> 命令的目标</li>
<li>客户端空转时间 大于了 <code>timeout</code> 的设置</li>
<li>客户端发送的命令请求的大小超过了输入缓冲区的大小限制（默认 <code>1GB</code>）</li>
<li>发送给客户端的命令回复的大小超过了输出缓冲区的限制大小</li>
</ul>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p><code>Redis</code> 服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p>
<h3 id="一条请求命令的执行过程"><a href="#一条请求命令的执行过程" class="headerlink" title="一条请求命令的执行过程"></a>一条请求命令的执行过程</h3><p>一条命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。，例如，执行 <code>redis&gt; SET KEY VALUE</code>这条命令的执行过程如下：</p>
<ul>
<li>1）客户端向服务器发送命令请求 <code>SET KEY VALUE</code></li>
<li>2）服务器接收并处理客户端发送过来的命令请求 <code>SET KEY VALUE</code>，在数据库中进行设置操作，并返回命令回复 <code>OK</code></li>
<li>3）服务器将命令回复<code>OK</code>发送给客户端</li>
<li>4）客户端接收服务器返回的命令回复<code>OK</code>，并将这个回复打印给用户</li>
</ul>
<h4 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h4><p><img src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanJieShouBingFaSongMingLingQingQiuDeGuoCheng.png" alt="客户端接收并发送命令请求的过程"><br>如图所示，用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令发送服务器。</p>
<p>示例，假设用户在客户端键入了命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SET KEY VALUE</div></pre></td></tr></table></figure></p>
<p>那么客户端会将这个命令转换成协议格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n</div></pre></td></tr></table></figure></p>
<p>然后将这段协议内容发送给服务器。</p>
<h4 id="服务器读取命令请求"><a href="#服务器读取命令请求" class="headerlink" title="服务器读取命令请求"></a>服务器读取命令请求</h4><p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求出来器来执行一下操作。</p>
<ul>
<li>1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里。</li>
<li>2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及参数的个数，然后分别保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性中。</li>
<li>3）调用命令执行器，执行客户端指定的命令。</li>
</ul>
<p>示例，</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanZhuangTaiZhongDeMingLingQingQiu.png" alt="客户端状态中的命令请求"></p>
<p>服务器将命令请求保存到客户端状态的输入缓冲区。之后，分析程序将对输入缓冲区的协议进行分析，并将分析结果保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性里。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanZhuangTaiDeargvShuXingHeargcShuXing.png" alt="客户端状态的argv属性和argc属性"></p>
<h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>分析程序将分析结果保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性里之后，服务器将通过调用命令执行器来完成执行命令所需的余下步骤。</p>
<ul>
<li><p>命令执行器：查找命令实现</p>
<blockquote>
<p>根据客户端状态的 <code>argv[0]</code> 参数，在命令表（<code>command table</code>） 中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性中。</p>
</blockquote>
</li>
<li><p>命令执行器：执行预备操作</p>
<blockquote>
<p>到目前为止，服务器已经将执行命令所需的命令实现函数（<code>cmd</code>属性）、参数（<code>argv</code>属性）、参数个数（<code>argc</code>属性）都收集齐了。但在真正执行命令前，还需要进行一些预备操作，从而确保命令能够正确的、顺序被执行。这些操作有，</p>
<ul>
<li>检查实现函数是否为空</li>
<li>检查参数个数满足当前实现函数的要求</li>
<li>检查客户端是否已经通过了身份验证</li>
<li>如果服务器打开了 <code>maxmemory</code> 功能，那么检查服务器的内从占用情况，并在有需要的情况下回收内存</li>
<li>如果服务器上一次执行 <code>BGSAVE</code> 命令出错，且打开了 <code>stop-writes-on-bgsave-error</code> 功能，且服务器当前要执行的是一个写命令，则拒绝执行这个命令，并返回错误。</li>
<li>检查服务器是否正处于某种状态（正在用<code>subscribe</code>命令订阅频道、正在用<code>psubscribe</code>命令订阅模式、正在进行数据载入、正在阻塞、正在执行事务），如果处于某种状态之下，则需要分别当前命令是否可以在该状态下被执行。</li>
<li>如果服务器打开了监视功能，那么服务器会将要执行的命令和参数等信息，发送给监视器。</li>
</ul>
<p>当完成以上操作之后，服务器就可以开始真正执行命令了。</p>
</blockquote>
</li>
<li><p>命令执行器：调用命令的实现函数</p>
<blockquote>
<p>因为之前服务器已经将要执行的命令的实现保存到了客户端状态的cmd属性、参数和个数分别保存到了<code>argv</code>属性和<code>argc</code>属性，所以当服务器决定要执行命令时，是需要执行就可以了。<code>client-&gt;cmd-&gt;proc(client);</code>实现函数执行完操作之后，会产生相应的命令回复，这些回复会保存在客户端状态的输出缓冲区里，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。</p>
</blockquote>
</li>
<li><p>命令执行器：执行后续操作</p>
<blockquote>
<p>在执行完函数之后，服务器还需要执行一些后续工作，</p>
<ul>
<li>如果服务器开启了慢日志功能，那么检查刚执行的命令是否符合条件</li>
<li>更新命令的<code>redisCommand</code>结构中<code>milliseconds</code>属性（执行命令耗费时长），和<code>calls</code>属性（被调用次数）</li>
<li>如果服务器开启<code>AOF</code>持久化功能，将刚执行的命令传播给所有从服务器</li>
</ul>
<p>到此，服务器对于当前命令的执行就告一段落了。</p>
</blockquote>
</li>
</ul>
<h4 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h4><p>前面的命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变成可写状态时，服务器就会执行命令回复处理器，将保存在输出缓冲区中的命令回复发送给客户端。</p>
<p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。</p>
<h4 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h4><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanJieShouBingDaYinMingLingHuiFuDeGuoCheng.png" alt="客户端接收并打印显示命令回复的过程"></p>
<h3 id="serverCron-函数"><a href="#serverCron-函数" class="headerlink" title="serverCron 函数"></a>serverCron 函数</h3><p><code>redis</code>服务器中的<code>serverCron</code>函数负责管理服务器的资源，并保持服务器自身的良好运转，其默认每隔 <code>100 ms</code> 执行一次。</p>
<p><code>serverCron</code>函数需要做的事情，</p>
<ul>
<li>更新服务器的时间缓存（用于获得当前时间时）</li>
<li>更新<code>LRU</code>时钟（用于计算键的空转事件）</li>
<li>更新服务器每秒执行命令次数</li>
<li>更新服务器内存峰值记录</li>
<li>处理<code>SIGTERM</code>信号</li>
<li>管理客户端资源</li>
<li>管理数据库资源</li>
<li>执行被延迟的<code>BGREWRITEAOF</code></li>
<li>检查持久化操作的运行状态</li>
<li>将<code>AOF</code>缓冲区中的内容写入<code>AOF</code>文件</li>
<li>关闭异步客户端</li>
<li>增加<code>cronloops</code>计数器值</li>
</ul>
<h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个<code>redis</code>服务器从启动到能够接受客户端的命令请求，需要经过一些列的初始化和设置过程，如</p>
<ul>
<li>初始化服务器状态结构</li>
<li>载入配置选项</li>
<li>初始化服务器数据结构</li>
<li>还原数据库状态</li>
<li>执行事件循环</li>
</ul>
<h4 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h4><p>服务器状态结构指的就是 <code>redisServer</code> 结构，初始化服务器的第一步就是创建一个 <code>struct redisServer</code>类型的实例变量 <code>server</code> 作为服务器的状态，并为结构中的各个属性设置默认值。</p>
<p>具体初始化工作由 <code>redis.c/initServerConfig</code> 函数完成，<code>initServerConfig</code> 函数完成的主要工作是，</p>
<ul>
<li>设置服务器的运行ID</li>
<li>设置服务器的默认运行频率</li>
<li>设置服务器的默认配置文件路径</li>
<li>设置服务器的运行架构</li>
<li>设置服务器的默认端口号</li>
<li>设置服务器的默认<code>RDB</code>持久化条件和<code>AOF</code>持久化条件</li>
<li>创建命令表</li>
</ul>
<p>当<code>initServerConfig</code> 函数执行完毕之后，服务器就可以进入初始化的第二阶段–载入配置选项</p>
<h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>服务器在用 <code>initServerConfig</code> 函数初始化完 <code>server</code> 变量之后，就会载入用户给指定的配置参数和配置文件，并根据用户设定的配置，对 <code>server</code> 变量相关属性进行修改：</p>
<p>例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-server --port 10086</div></pre></td></tr></table></figure></p>
<p>那么我们就会修改了服务器默认的运行端口号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-server redis.conf</div></pre></td></tr></table></figure>
<p>按照配置文件中的配置，修改 <code>server</code> 变量属性。</p>
<p>服务器在载入用户指定的配置选项，并对<code>server</code>状态进行更新之后，服务器就可以进入初始化的第三个阶段–初始化服务器数据结构。</p>
<h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>在之前执行 <code>initServerConfig</code> 函数初始化 <code>server</code> 状态，程序只创建了命令表的一个数据结构，不过了命令表之外，服务器状态还包含其他数据结构。</p>
<ul>
<li><code>server.client</code> 链表，记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个<code>redisClient</code>结构实例。</li>
<li><code>server.db</code> 数组，包含了服务器的所有数据库。</li>
<li><code>server.pubsub_channels</code> 字典，保存频道订阅信息。</li>
<li><code>server.pubsub_patterns</code> 链表，保存模式订阅信息。</li>
<li><code>server.lua</code>，保存执行<code>lua</code>脚本的<code>Lua</code>环境。</li>
<li><code>server.slowlog</code> ，保存慢查询日志。</li>
</ul>
<p>这些数据结构是通过 <code>iniServer</code> 函数来实现，为这些数据结构分配内存，并设置或关联初始化值。</p>
<p><code>iniServer</code> 函数除了初始化这些数据结构之外，还会进行一些其他非常重要的设置操作，包括:</p>
<ul>
<li>为服务器是指进程信号处理器</li>
<li>创建共享对象：这些对象包括<code>redis</code>服务器经常用到的一些值（如，包含“OK”回复的字符串对象，包含“ERR”回复的字符串对象，等等），服务器通过重用这些对象来避免反复重复的创建相同的对象。</li>
<li>打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接收客户端连接。</li>
<li>为 <code>serverCron</code> 函数创建时间事件，等待服务器正式运行时实行 <code>serverCron</code> 函数。</li>
<li>如果<code>AOF</code>持久化功能已经打开，那么打开现有的<code>AOF</code>文件，如果<code>AOF</code>文件不存在，那么创建并打开一个新的<code>AOF</code>文件，为<code>AOF</code>文件写入做好准备。</li>
<li>初始化后台<code>I/O</code>模块（<code>bio</code>），为将来的<code>I/O</code>操作做好准备。</li>
</ul>
<p>当<code>iniServer</code>函数执行完毕之后，服务器会用 <code>ASCII</code>字符在日志中打印出<code>Redis</code>的图标，以及Redis的版本信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">root@5254004e45d0:/srv/rorapps/redis/redis-2.8.15# src/redis-server</div><div class="line">[16445] 16 Sep 09:54:32.684 # Warning: no config file specified, using the default config. In order to specify a config file use src/redis-server /path/to/redis.conf</div><div class="line">[16445] 16 Sep 09:54:32.686 * Increased maximum number of open files to 10032 (it was originally set to 1024).</div><div class="line">				_._												  </div><div class="line">		   _.-``__ &apos;&apos;-._											 </div><div class="line">	  _.-``	`.  `_.  &apos;&apos;-._		   Redis 2.8.15 (00000000/0) 64 bit</div><div class="line">  .-`` .-```.  ```\/	_.,_ &apos;&apos;-._								   </div><div class="line"> (	&apos;	  ,	   .-`  | `,	)	 Running in stand alone mode</div><div class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|	 Port: 6379</div><div class="line"> |	`-._   `._	/	 _.-&apos;	|	 PID: 16445</div><div class="line">  `-._	`-._  `-./  _.-&apos;	_.-&apos;								   </div><div class="line"> |`-._`-._	`-.__.-&apos;	_.-&apos;_.-&apos;|								  </div><div class="line"> |	`-._`-._		_.-&apos;_.-&apos;	|		   http://redis.io		</div><div class="line">  `-._	`-._`-.__.-&apos;_.-&apos;	_.-&apos;								   </div><div class="line"> |`-._`-._	`-.__.-&apos;	_.-&apos;_.-&apos;|								  </div><div class="line"> |	`-._`-._		_.-&apos;_.-&apos;	|								  </div><div class="line">  `-._	`-._`-.__.-&apos;_.-&apos;	_.-&apos;								   </div><div class="line">	  `-._	`-.__.-&apos;	_.-&apos;									   </div><div class="line">		  `-._		_.-&apos;										   </div><div class="line">			  `-.__.-&apos;											   </div><div class="line"></div><div class="line">[16445] 16 Sep 09:54:32.688 # Server started, Redis version 2.8.15</div><div class="line">[16445] 16 Sep 09:54:32.688 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &apos;vm.overcommit_memory = 1&apos; to /etc/sysctl.conf and then reboot or run the command &apos;sysctl vm.overcommit_memory=1&apos; for this to take effect.</div><div class="line">[16445] 16 Sep 09:54:32.688 * The server is now ready to accept connections on port 6379</div></pre></td></tr></table></figure>
<h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><p>在完成对 <code>server</code> 变量的初始化之后，服务器需要载入 <code>RDB</code> 文件或者 <code>AOF</code> 文件，并根据文件记录的内容来还原服务器的数据库状态。</p>
<ul>
<li>如果服务器采用的是 <code>AOF</code>方式的持久化方式，那么服务器将使用<code>AOF</code>文件来还原数据库状态。</li>
<li>相反的如果服务器没有采用<code>AOF</code>方式的持久化方式，那么服务器使用<code>RDB</code>文件来还原服务器数据库状态。</li>
</ul>
<p>当服务器完成数据库的还原操作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费的时长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[5244] 21 Nov 22:43:49.084 * DB loaded from disk: 0.067 seconds</div></pre></td></tr></table></figure></p>
<h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>初始化的最后一步，服务器将打印以下日志，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[5244] 21 Nov 22:43:49.084 * The server is now ready to accept connections on port  6379</div></pre></td></tr></table></figure></p>
<p>并开始执行服务器的时间循环（<code>loop</code>）<br>。</p>
<p>至此，服务器的初始化操作就圆满完成。服务器从现在开始就可以接受客户端的连接请求，并处理客户端发来的命令请求了。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道&lt;code&gt;Redis&lt;/code&gt;是一个典型的&lt;code&gt;C/S&lt;/code&gt;设计程序，一个服务器可以与多个客户端建立连接。通过&lt;code&gt;I/O&lt;/code&gt;多路复用技术实现的文件事件处理器，&lt;code&gt;Redis&lt;/code&gt;服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。&lt;/p&gt;
&lt;p&gt;所以，对于&lt;code&gt;Redis&lt;/code&gt;我们分为这两部分来了解，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;服务器维护和管理客户端状态的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;服务器的运行机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之事件原理和实现</title>
    <link href="https://weizhimiao.github.io/2017/01/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2017/01/13/深入了解Redis之事件原理和实现/</id>
    <published>2017-01-13T12:30:00.000Z</published>
    <updated>2017-01-13T09:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis服务器是一个事件驱动程序，其主要处理的事件主要可分为以下两类：</p>
<ul>
<li><p>文件事件(file event)</p>
<blockquote>
<p>Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信。</p>
</blockquote>
</li>
<li><p>时间事件(time event)</p>
<blockquote>
<p>Redis服务器中的一些操作（如，serverCron函数）需要在指定的时间点执行，而时间事件就是对这类定时操作的抽象。</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。</p>
<p>Redis基于Reactor模式开发了自己的文件事件（网络事件）处理器（file event handler）。其构成可分为四个部分，套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/WenJianShiJianChuLiQiDeSiGeZuChengBuFen.png" alt="事件处理器的四个组成部分"></p>
<ul>
<li>因为一个服务器通常会连接多个套接字，所以多个文件事件可能会并发的出现</li>
<li>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。（尽管会有多个文件事件同时出现，但是I/O多路复用程序会将之转化成一个有序的队列，依次将其传送给文件事件分派器。并且等上一个套接字处理完毕之后，I/O多路复用程序才会继续向文件事件分派器传送下一个套接字）</li>
<li>文件事件分派器接受I/O多路复用程序传送过来的套接字，并根据套接字产生的事件类型，调用相应的事件处理器。<blockquote>
<p>服务器会为执行不同任务的套接字关联不同的事件处理器，如有应答处理器、命令请求处理器、命令回复处理器。</p>
<h3 id="I-O多路复用程序的实现方式"><a href="#I-O多路复用程序的实现方式" class="headerlink" title="I/O多路复用程序的实现方式"></a>I/O多路复用程序的实现方式</h3></blockquote>
</li>
</ul>
<p>Redis的I/O复用程序的功能都是通过包装了常见的I/O多路复用函数库来实现的</p>
<ul>
<li>select</li>
<li>epoll</li>
<li>evport</li>
<li>kqueue</li>
</ul>
<p>I/O多路复用函数库的选择</p>
<blockquote>
<p>Redis用每个函数库都实现了相同的API，程序会在编译时自动判断当前系统下哪种多路复用函数库性能最高，而选择其作为Redis的I/O多路复用程序的底层实现。</p>
</blockquote>
<h3 id="文件事件的类型"><a href="#文件事件的类型" class="headerlink" title="文件事件的类型"></a>文件事件的类型</h3><ul>
<li><p>AE_READABLE 事件</p>
<blockquote>
<p>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作）</p>
</blockquote>
</li>
<li><p>AE_WRITABLE 事件</p>
<blockquote>
<p>当套接字变得可写时（客户端对套接字执行read操作）</p>
</blockquote>
</li>
</ul>
<p>I/O多路复用程序允许服务器同时监听套接字的 AE_READABLE 和 AE_WRITABLE 事件，并且如果一个套接字同时出现这两种事件，那么文件分派器会优先处理 AE_READABLE 事件，然后才会处理 AE_WRITABLE 事件。</p>
<h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><ul>
<li>连接应答处理器</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiDuiKeHuDuanDeLianJieQingQiuJinXingYingDa.png" alt="服务器对客户端的连接请求进行应答"></p>
<p>当Redis服务器进行初始化的时候，会将连接应答处理器和服务器监听套接字的 AE_READABLE 事件关联起来，当有客户端与服务器监听的套接字进行连接时，套接字就会产生 AE_READABLE 事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p>
<ul>
<li>命令请求处理器</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiJieShouKeHuDuanFaLaiDeMingLingQingQiu.png" alt="服务器接收客户端发来的命令请求"><br>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的 AE_READABLE 事件和命令请求处理器关联起来，当客户端向服务器端发送请求命令的时候，套接字就会产生 AE_READABLE 事件，引发命令请求处理器执行，并执行相应的套接字读入操作。</p>
<p>在客户端与服务器连接的整个过程中，服务器都会一直为客户端套接字的 AE_READABLE 事件关联命令请求处理器。</p>
<ul>
<li>命令回复处理器</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiXiangKeHuDuanFaSongMingLingHuiFu.png" alt="服务器向客户端发送命令回复"></p>
<p>当客户端有命令回复需要传送给客户端的时候，服务器会将客户端套接字的 AE_WRITABLE 事件和命令回复处理器关联起来，当客户端准备好接受服务器传回的命令回复时，就会产生 AE_WRITABLE 事件，引发命令回复处理器执行，并执行相应的套接字写入操作。</p>
<h3 id="一次完整的客户端与服务器连接事件的示例"><a href="#一次完整的客户端与服务器连接事件的示例" class="headerlink" title="一次完整的客户端与服务器连接事件的示例"></a>一次完整的客户端与服务器连接事件的示例</h3><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/KeHuDuanHeFuWuQiDeTongXinGuoCheng.png" alt="客户端和服务器的通信过程"></p>
<p>假设一个Redis服务器正在运行，那么这个服务器的监听套接字的 AE_READABLE 事件应该正在处于监听状态下，而该事件所对应的处理器为连接应答处理器。</p>
<p>这是如果有一个Redis客户端向服务器发起连接，那么监听套接字将会产生 AE_READABLE 事件，I/O多路复用程序将会将这个 AE_READABLE 事件传送给文件事件分派器，文件分派器将其分给连接应答处理器触发其执行。</p>
<p>应答处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端的套接字的 AE_READABLE 事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p>
<p>之后，假设客户端向主服务器发送命令请求，那么客户端套接字将产生 AE_READABLE 事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</p>
<p>执行程序执行完毕将会有对应的回复，为了将这些命令回复传送给客户端，服务器会将客户端套接字的 AE_WRITABLE 事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将会产生 AE_WRITABLE 事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联。</p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类：</p>
<ul>
<li>定时事件</li>
<li>周期性事件</li>
</ul>
<blockquote>
<p>目前版本的Redis只使用周期性事件，而没有使用定时事件。</p>
</blockquote>
<h3 id="时间事件的组成"><a href="#时间事件的组成" class="headerlink" title="时间事件的组成"></a>时间事件的组成</h3><p>一个时间事件由以下三个属性组成，</p>
<ul>
<li><p>id，服务器为时间事件生成的全局唯一的ID（标志号）。该ID是自增的，即新的事件ID总是比旧事件ID要大。</p>
</li>
<li><p>when，毫秒精度的时间戳，记录了事件的到达（arrive）时间</p>
</li>
<li><p>timeProc，时间事件处理器，一个函数</p>
</li>
</ul>
<p>不管是定期时间事件和还是周期性时间事件，其组成都是由这三个属性构成。其不同取决于时间事件处理器的返回值</p>
<ul>
<li>如果事件处理器返回 AE_NOMARE ,那么这个事件就是定时事件。该事件在第一次之后就会被删除，之后不在到达。</li>
<li>如果事件处理器返回 非AE_NOMARE 的整数值，那么这个事件就是周期性事件，该事件在到达之后，服务器会根据这个返回的值，对时间事件的 when 属性进行更新，让这个事件在一段时间之后可以再次到达。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Redis 服务器将所有的时间事件都放在了一个无序列表中，每当时间事件执行器运行时，它就会遍历成哥链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/YongLianBiaoLianJieQiLaiDeSanGeShiJianShiJian.png" alt="时间事件实现"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>持续运行的Redis服务器需要定期的对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行，这些定期操作是由 serverCron 函数负责执行。它的主要工作有，</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等</li>
<li>清理数据库中过期的键</li>
<li>关闭和清理连接失效的客户端</li>
<li>尝试进行AOF或RDB持久化操作</li>
<li>如果服务器是主服务器，那么对从服务器进行定期数据同步</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试</li>
</ul>
<p>Redis以周期性时间事件方式来运行 serverCron 函数，直至服务器关闭为止。</p>
<h2 id="文件事件和时间事件的关系"><a href="#文件事件和时间事件的关系" class="headerlink" title="文件事件和时间事件的关系"></a>文件事件和时间事件的关系</h2><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/ShiJianChuLiJiaoDuXiaDeFuWuQiYunXingLiuCheng.png" alt="事件角度下的服务器运行流程"></p>
<p>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件。并且由于文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器也不会终端正在执行的事件处理，也不会对事件进行抢占。</p>
<h3 id="Redis事件调度和执行的几条规则"><a href="#Redis事件调度和执行的几条规则" class="headerlink" title="Redis事件调度和执行的几条规则"></a>Redis事件调度和执行的几条规则</h3><ul>
<li><p>由于文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍然未有任何事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时，服务器就可以开始处理到达的时间事件了。</p>
</li>
<li><p>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间一般会比设定的时间稍晚一些。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis服务器是一个事件驱动程序，其主要处理的事件主要可分为以下两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件事件(file event)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时间事件(time event)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis服务器中的一些操作（如，serverCron函数）需要在指定的时间点执行，而时间事件就是对这类定时操作的抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之Redis的持久化方式</title>
    <link href="https://weizhimiao.github.io/2017/01/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8BRedis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>https://weizhimiao.github.io/2017/01/12/深入了解Redis之Redis的持久化方式/</id>
    <published>2017-01-12T13:30:00.000Z</published>
    <updated>2017-01-12T07:51:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Redis是一个内存数据库，它所有的数据库状态都存储在内存中，所以如果想要在服务器故障、重启之后数据还在，就需要一个将这些数据持久化的一个功能。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/redisChiJiuHuaYuanLi.png" alt="redis持久化原理"></p>
<p>Redis提供了两种持久化的方式，</p>
<ul>
<li><p>RDB 持久化方式</p>
<blockquote>
<p>将数据库中的键值对及状态保存在持久化文件中</p>
</blockquote>
</li>
<li><p>AOF 持久化方式</p>
<blockquote>
<p>而AOF保存的是服务器所执行过的所有写命令</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiZaiRuWenJianShiDePanDuanLiuCheng.png" alt="服务器载入文件时的判断流程"></p>
<p>值得提一下的是，因为AOF文件的更新频率通常比RDB文件的更新频率更高，所以如果服务器有开启AOF持久化功能时，服务器就会优先使用AOF文件来还原数据库，其次才是RDB文件。</p>
<h2 id="RDB-持久化方式"><a href="#RDB-持久化方式" class="headerlink" title="RDB 持久化方式"></a>RDB 持久化方式</h2><h3 id="RDB文件结构简析"><a href="#RDB文件结构简析" class="headerlink" title="RDB文件结构简析"></a>RDB文件结构简析</h3><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/RDBWenJianJieGou.png" alt="RDB文件结构"></p>
<h3 id="redis服务器保存和载入RDB文件的方法"><a href="#redis服务器保存和载入RDB文件的方法" class="headerlink" title="redis服务器保存和载入RDB文件的方法"></a>redis服务器保存和载入RDB文件的方法</h3><p>redis中创建RDB文件的两个命令</p>
<ul>
<li><p>SAVE<br>SAVE命令会由Redis服务器主进程来执行RDB文件的创建，所以在执行SAVE时，Redis服务器会有阻塞，知道RDB文件创建完毕为止，且在阻塞期间服务器不能处理任何命令请求。</p>
</li>
<li><p>BGSAVE<br>BGSAVE命令则会派生出一个子进程，然后由子进程负责创建RDB文件，而Redis服务器主进程（父进程）可以继续处理各种命令请求。</p>
</li>
</ul>
<p>创建RDB文件的实际工作由rdb.c/rdbSave函数来完成，SAVE和BGSAVE命令都会以不同的形式调用这个函数。</p>
<p>RDB文件载入时的服务器状态</p>
<blockquote>
<p>RDB文件的载入只有在服务器启动时才会被执行，所以Redis中没有专门载入RDB文件的命令，只要Redis启动时没有开启AOF功能，且检测到RDB文件的存在，就会自动载入RDB文件。且服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成。</p>
</blockquote>
<h3 id="redis服务器自动保存功能的实现原理"><a href="#redis服务器自动保存功能的实现原理" class="headerlink" title="redis服务器自动保存功能的实现原理"></a>redis服务器自动保存功能的实现原理</h3><p>通过上面我们知道，Redis服务器有两个命令，SAVE和BGSAVE，来执行保存数据库状态的操作。<br>SAVE是阻塞的，BGSAVE是非阻塞的。Redis中借助BGSAVE命令，每隔一段时间自动执行一次BGSAVE命令来实现数据库状态的自动保存功能。</p>
<p>具体实现是通过设置服务器配置的save选项，按照一定的周期去执行BGSAVE命令。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div></pre></td></tr></table></figure></p>
<p>那么只要满足上面这三个条件的任何一条，BGSAVE就会被执行。</p>
<ul>
<li>服务器在900s之内，对数据库进行了至少1次修改</li>
<li>服务器在300s之内，对数据库进行了至少10次修改</li>
<li>数据库在60s之内，对数据库进行了10000次修改</li>
</ul>
<h2 id="AOF-持久化方式"><a href="#AOF-持久化方式" class="headerlink" title="AOF 持久化方式"></a>AOF 持久化方式</h2><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/AOFChiJiuHua.png" alt="AOF持久化方式"></p>
<h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>当AOF持久化功能处于打开的状态时，服务器在执行完一个写命令，先将被执行的写命令追加到服务器状态的 aof_buf 的缓冲区。Redis服务器会在每次事件循环结束之前，都会调用“flushAppendOnlyFile”函数来判断是否需要将 aof_buf 缓冲区中内容保存到AOF文件里面。</p>
<p>flushAppendOnlyFile 函数判断是否保存的依据和配置（appendfsync）</p>
<ul>
<li>always,将aof_buf 将缓冲区中所有内容写入并同步到AOF文件</li>
<li>everysec,将缓冲区中所有内容写入AOF文件，但至少间隔一秒同步一次(默认值)</li>
<li>no,将缓冲区中所有内容写入AOF文件，但不对AOF文件进行同步，何时同步则由系统决定</li>
</ul>
<h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/AOFWenJianZaiRuGuoCheng.png" alt="AOF文件载入过程"></p>
<h3 id="AOF重写的原理和实现"><a href="#AOF重写的原理和实现" class="headerlink" title="AOF重写的原理和实现"></a>AOF重写的原理和实现</h3><p>随着服务器运行时间的增加，AOF文件中的内容会越来越多，相应的文件体积就会越来越大，但其实文件中很大一部分信息是冗余信息。</p>
<p>例如，我们对一个键进行了n次的写操作，AOF文件中相对应就会产生n次的写操作命令。但其实AOF文件中的对于该键的前n-1次的写操作命令都可认为是冗余操作命令，只需保留最后一条的写操作命令即可。</p>
<p>所以，Redis提供了AOF文件重写（rewrite）功能，来清除这些冗余命令，以控制AOF文件的大小。具体实现思路为，Redis服务器先创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态是相同的，但新的AOF文件不会包含任何浪费空间的冗余命令。</p>
<h4 id="Redis服务器AOF重写的实现"><a href="#Redis服务器AOF重写的实现" class="headerlink" title="Redis服务器AOF重写的实现"></a>Redis服务器AOF重写的实现</h4><ul>
<li><p>虽然该功能名称叫 AOF文件重写 ，但是具体的实现却并没有对现有AOF文件进行任何读取、分析、或者写入操作，而是通过读取当前服务器的数据库状态来实现的。</p>
</li>
<li><p>通过读取当前数据库中键值的状态，尽量生成最少的能与之对应redis命令，然后将该redis命令写入新的AOF文件中，直至将当前数据库状态全部生成完毕。</p>
</li>
<li><p>另外，在执行AOF重写的期间，Redis会维护一个AOF重写缓冲区，该缓冲区会在子进程创建AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态完全一致。</p>
</li>
<li><p>最后，服务器用新的AOF替换旧的AOF文件，以此来完成AOF文件的重写操作。</p>
</li>
</ul>
<h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>由于生成新的AOF文件时会进行大量的写入操作，所以在进行AOF重写的时候，会造成长时间的阻塞，所以redis将AOF重写程序放在子进程里执行，这样就可避免主进程长时间的阻塞。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道Redis是一个内存数据库，它所有的数据库状态都存储在内存中，所以如果想要在服务器故障、重启之后数据还在，就需要一个将这些数据持久化的一个功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20170112/redisChiJiuHuaYuanLi.png&quot; alt=&quot;redis持久化原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;Redis提供了两种持久化的方式，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RDB 持久化方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将数据库中的键值对及状态保存在持久化文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AOF 持久化方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;而AOF保存的是服务器所执行过的所有写命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之Redis数据库的实现</title>
    <link href="https://weizhimiao.github.io/2017/01/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8BRedis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2017/01/12/深入了解Redis之Redis数据库的实现/</id>
    <published>2017-01-12T12:30:00.000Z</published>
    <updated>2017-01-12T07:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis这个<code>key-value</code>的存储系统，由于其高性能，支持主从复制和丰富的数据结构等特性，目前已经广泛应用于我们的各个场景之中。所以了解整理其相关的一些内容，用以加深我们对其的了解，方便之后更好的使用它实现我们的各种功能。</p>
<a id="more"></a>
<h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><p>Redis底层的实现，主要用到的数据结构有简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等。但REdis没有直接用这些数据结构来实现数据库的设计。而是基于这些数据结构创建了一个对象系统。</p>
<p>使用这种对象系统的好处</p>
<ul>
<li>对不同的使用场景，可以为对象设置多种不同的数据结构实现，从而可以优化对象在不同场景下的使用效率</li>
<li>基于对象方便实现基于引用计数技术的内存回收机制</li>
</ul>
<p>键值对的具体组成：</p>
<ul>
<li>键 =&gt; 自字符串对象</li>
<li>值<ul>
<li>字符串对象</li>
<li>列表对象</li>
<li>哈希对象</li>
<li>集合对象</li>
<li>有序集合对象</li>
</ul>
</li>
</ul>
<h2 id="数据库的实现"><a href="#数据库的实现" class="headerlink" title="数据库的实现"></a>数据库的实现</h2><p>Redis服务器的所有数据库都保存在”redisSeriver”结构中的“db” 的数组中。而db的结构则主要由“dict”和“expires”另个字典构成，dict字典负责保存键值对，而expires字典负责保存键的过期时间。</p>
<p>redisSeriver结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct redisSeriver&#123;</div><div class="line">  //...</div><div class="line"></div><div class="line">  redisDb *db;</div><div class="line"></div><div class="line">  //...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>redisDb结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typeed struct redisDb&#123;</div><div class="line">  //...</div><div class="line"></div><div class="line">  //数据库键值字典，保存数据库中所有键值对（又称之为，键空间）</div><div class="line">  dict *dict;</div><div class="line"></div><div class="line">  //过期字典，保存键的过期时间</div><div class="line">  dict *expires;</div><div class="line"></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure></p>
<h3 id="服务器保存键值对的方法"><a href="#服务器保存键值对的方法" class="headerlink" title="服务器保存键值对的方法"></a>服务器保存键值对的方法</h3><p>键值字典和用户所见的数据库是直接对应的</p>
<ul>
<li>该字典里的键就是我们数据库的键（每个键都是一个字符串对象）</li>
<li>字典的值就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任一种对象。</li>
</ul>
<p>相应的操作</p>
<ul>
<li><p>当添加新键值对时</p>
<blockquote>
<p>实际就是将一个新键值对添加到该“dict”键值字典中，其键为字符串对象，值为任意的一个Redis对象</p>
</blockquote>
</li>
<li><p>删除键</p>
<blockquote>
<p>实际上就是在该“dict”键值字典中删除键对应的键值对对象</p>
</blockquote>
</li>
<li><p>更新键</p>
</li>
<li>对该键取值</li>
</ul>
<p>当我们对这些键值进行这些读写操作的时候，redis还会执行一些额外的（维护）操作。这些操作有</p>
<ul>
<li>当读取一个键后，会更新服务器键空间命中次数（hit）或不命中次数（miss）</li>
<li>读取一个键后，还会更新该键的LRU（最后一次使用时间）</li>
<li>当读取一个键时，发现该键已经过期，那么出返回结果还需要删除这个键</li>
<li>如果有客户端watch这个键，那么操作过这个键之后还需要将这个键标记为“dirty”，让watch这个键的客户端知道该键已经被修改过</li>
<li>当每次修改过一个键之后，都会对“dirty”计数器的值增1，以便触发服务器的持久化以及复制操作。</li>
<li>如果服务器开启了数据库通知的功能，那么修改了键之后，还需要按配置发送相应的通知。</li>
</ul>
<h3 id="服务器保存键值对过期时间的方法"><a href="#服务器保存键值对过期时间的方法" class="headerlink" title="服务器保存键值对过期时间的方法"></a>服务器保存键值对过期时间的方法</h3><p>过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p>
<p>redis有四个不同的命令来设置键的过期时间</p>
<ul>
<li>EXPIRE <key> <ttl> (秒级)</ttl></key></li>
<li>PEXPIRE <key> <ttl> (毫秒级)</ttl></key></li>
<li>EXPIREAT <key> <timestamp> (秒级)</timestamp></key></li>
<li>PEXPIREAT <key> <timestamp> (毫秒级)</timestamp></key></li>
</ul>
<p>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令最终都是使用PEXPIREAT命令来实现的。</p>
<p>redisDb结构中，expires字典保存了数据库中所有键的过期时间。</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象</li>
<li>过期字典的值是一个long类型的整数，这个整数保存着过期时间（一个毫秒精度的UNIX时间戳）</li>
</ul>
<h3 id="服务器删除过期键值对的方法"><a href="#服务器删除过期键值对的方法" class="headerlink" title="服务器删除过期键值对的方法"></a>服务器删除过期键值对的方法</h3><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><ul>
<li>1、检查给定的键是否存在于过期字典，如果存在，那么取得键的过期时间</li>
<li>2、检查当前UNIX时间戳是否大于取得的键的过期时间，如果大于的，那么该键已过期；否则该键未过期。</li>
</ul>
<h4 id="一般的常见的过期键删除机制"><a href="#一般的常见的过期键删除机制" class="headerlink" title="一般的常见的过期键删除机制"></a>一般的常见的过期键删除机制</h4><ul>
<li>定时删除，在设置键的时候设定一个定时器，让其在定时器结束时执行对键的删除操作</li>
<li>惰性删除，设置后不管，当需要再次获取该键时，先检查该键是否已经过期，如果过期的话，执行删除操作，没有过期的话，返回键值</li>
<li>定期删除，每隔一段时间，对所有键检查一次，有过期的则主动删除</li>
</ul>
<h4 id="Redis采用的过期键删除机制（惰性-定期）"><a href="#Redis采用的过期键删除机制（惰性-定期）" class="headerlink" title="Redis采用的过期键删除机制（惰性+定期）"></a>Redis采用的过期键删除机制（惰性+定期）</h4><ul>
<li><p>惰性删除策略的实现</p>
<blockquote>
<p>redis在所有读写数据库的Redis命令之前都会执行一个叫”expireIfNeeded”的函数对要操作的键进行检查</p>
</blockquote>
<ul>
<li>如果要操作的键已经过期，那么”expireIfNeeded”函数将该键从数据库中删除</li>
<li>如果未过期，那么”expireIfNeeded”函数不做操作</li>
</ul>
</li>
</ul>
<p>注：对所操作键存在与否的判断先与是否过期的判断</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170111/redisGuoQiJianShanChuLiuCheng.png" alt="img"></p>
<ul>
<li>定期删除策略的实现<blockquote>
<p>redis中会有一个周期性运行的操作函数“serverCron”。过期键的定期删除是由一个叫“activeExpireCycle”的函数实现。当serverCron函数运行时，activeExpireCycle 函数就会被调用。它会在规定的时间内分多次遍历服务器中各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
</blockquote>
</li>
</ul>
<h4 id="redis集群中过期键的删除"><a href="#redis集群中过期键的删除" class="headerlink" title="redis集群中过期键的删除"></a>redis集群中过期键的删除</h4><p>在Redis集群中 当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，而从服务器即使发现过期键也不会自作主张的将其删除，而是等待主节点发来DEL命令，显式的进行删除。这种统一的、中心化的过期键策略可以保证主从服务器数据一致。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis这个&lt;code&gt;key-value&lt;/code&gt;的存储系统，由于其高性能，支持主从复制和丰富的数据结构等特性，目前已经广泛应用于我们的各个场景之中。所以了解整理其相关的一些内容，用以加深我们对其的了解，方便之后更好的使用它实现我们的各种功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构下使用Nginx变量对应用程序进行性能追踪[转]</title>
    <link href="https://weizhimiao.github.io/2016/12/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E4%BD%BF%E7%94%A8Nginx%E5%8F%98%E9%87%8F%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E8%BF%BD%E8%B8%AA%5B%E8%BD%AC%5D/"/>
    <id>https://weizhimiao.github.io/2016/12/29/微服务架构下使用Nginx变量对应用程序进行性能追踪[转]/</id>
    <published>2016-12-29T13:30:00.000Z</published>
    <updated>2016-12-29T13:02:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>使用变量来对应用程序性能进行管理</em></strong></p>
<p>变量是NGINX配置的一个重要且有时被忽视的方面。 Nginx 有大约<a href="http://nginx.org/en/docs/varindex.html" target="_blank" rel="external">150个变量</a>可用，Nginx 变量可用来方便每个部分的配置。 在本博客中，我们讨论如何使用NGINX变量来进行 <strong>应用程序跟踪</strong> 和 <strong>应用程序性能管理（APM）</strong> ，重点是发现应用程序中的性能瓶颈。 这篇文章适用于开源的 NGINX 软件和 NGINX Plus。 为了简洁，我们将参考NGINX Plus，除非两个产品之间有差异。</p>
<a id="more"></a>
<h2 id="应用程序交付环境"><a href="#应用程序交付环境" class="headerlink" title="应用程序交付环境"></a>应用程序交付环境</h2><p>在我们的示例应用程序交付环境中，NGINX Plus作为我们应用程序的反向代理。 应用程序本身包括一个Web前端，后面是多个微服务。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161229/nginx-proxies-app-with-frontend-and-microservices.png" alt="示例应用程序交付环境"></p>
<h2 id="跟踪端到端-End‑to‑End-请求"><a href="#跟踪端到端-End‑to‑End-请求" class="headerlink" title="跟踪端到端(End‑to‑End)请求"></a>跟踪端到端(End‑to‑End)请求</h2><p><code>NGINX Plus R10</code>（和<code>NGINX 1.11.0</code>）引入 <code>$request_id</code> 变量，它是随机生成的32个十六进制字符串，在每个HTTP请求到达时自动分配给它们（例如<code>444535f9378a3dfa1b8604bc9e05a303</code>）。 这个看似简单的机制解锁了一个强大的工具，可用于跟踪和故障排除。 通过配置<code>NGINX Plus</code>和所有后端服务传递<code>$request_id</code>值，您可以跟踪每个请求端到端。 这个示例配置是为我们的前端<code>NGINX Plus</code>服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">upstream app_server &#123;</div><div class="line">    server 10.0.0.1:80;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    add_header X-Request-ID $request_id; # Return to client</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://app_server;</div><div class="line">        proxy_set_header X-Request-ID $request_id; # Pass to app server</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要配置NGINX Plus进行请求跟踪，我们首先定义 <code>upstream</code> 块中应用程序服务器的网络位置。 为了简单起见，我们在这里只显示一个应用程序服务器，但通常使用几个应用程序服务器来实现高可用性和负载平衡。</p>
<p><code>server</code>块定义了<code>NGINX Plus</code>如何处理传入的HTTP请求。 <code>listen</code>指令告诉<code>NGINX Plus</code>侦听端口80，但生产环境配置通常使用<code>SSL/TLS</code>来保护传输中的数据。</p>
<p><code>add_header</code>指令将<code>$request_id</code>值作为响应中的自定义<code>header</code>头发送回客户端。 这对于测试以及生成自己的日志（如移动应用程序）的客户端应用程序非常有用，以便客户端可以精确匹配服务器的错误日志。</p>
<p>最后，<code>location</code> 块应用于整个应用程序空间（<code>/</code>），<code>proxy_pass</code>指令简单地代理所有请求到应用程序服务器。 <code>proxy_set_header</code>指令通过添加传递给应用程序的HTTP头来修改代理请求。 在这种情况下，我们创建一个名为<code>X-Request-ID</code>的头，并为其分配<code>$request_id</code>变量的值。 因此，我们的应用程序接收由<code>NGINX Plus</code>生成的request ID。</p>
<h2 id="记录端到端的-request-id"><a href="#记录端到端的-request-id" class="headerlink" title="记录端到端的$request_id"></a>记录端到端的<code>$request_id</code></h2><p>我们的应用程序跟踪的目标是确定请求处理生命周期中的性能瓶颈，作为应用程序性能管理的一部分。 我们可以通过在处理过程中记录重要的事件来做到这一点，方便我们以后分析它们的异常或不合理的延迟。</p>
<h3 id="配置NGINX-Plus"><a href="#配置NGINX-Plus" class="headerlink" title="配置NGINX Plus"></a>配置NGINX Plus</h3><p>我们从配置前端<code>NGINX Plus</code>服务器开始，将<code>$request_id</code>包含在用于<code>access_trace.log</code>文件的自定义日志记录格式<code>trace</code>中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">log_format trace &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                 &apos;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &apos;</div><div class="line">                 &apos;&quot;$http_x_forwarded_for&quot; $request_id&apos;;</div><div class="line"></div><div class="line">upstream app_server &#123;</div><div class="line">    server 10.0.0.1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    add_header X-Request-ID $request_id; # Return to client</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://app_server;</div><div class="line">        proxy_set_header X-Request-ID $request_id;        # Pass to app server</div><div class="line">        access_log /var/log/nginx/access_trace.log trace; # Log $request_id</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="配置后端应用程序"><a href="#配置后端应用程序" class="headerlink" title="配置后端应用程序"></a>配置后端应用程序</h3><p>将<code>Request ID</code> 传递到我们的应用程序有时也会用到。 在这个例子中，我们有一个由<code>uWSGI</code>管理的<code>Python应用程序</code>。 让我们修改应用程序入口点，以获取<code>Request ID</code>作为日志变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> uwsgi <span class="keyword">import</span> set_logvar</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    set_logvar(<span class="string">'requestid'</span>, environ[<span class="string">'X_REQUEST_ID'</span>])</div></pre></td></tr></table></figure>
<p>然后我们可以修改<code>uWSGI</code>配置，将<code>Request ID</code>包含在标准日志文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log-format = %(addr) - %(user) [%(ltime)] &quot;%(method) %(uri) %(proto)&quot; %(status)</div><div class="line">%(size) &quot;%(referer)&quot; &quot;%(uagent)&quot; %(requestid)</div></pre></td></tr></table></figure>
<p>通过这种配置，我们现在可以生成日志文件，这些文件可以跨多个系统，我们可以通过<code>requestid</code>来查看我们单次<code>request</code>的调用链。</p>
<p>来自<code>NGINX</code>的日志示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">172.17.0.1 - - [02/Aug/2016:14:26:50 +0000] &quot;GET / HTTP/1.1&quot; 200 90 &quot;-&quot; &quot;-&quot; &quot;-&quot; 5f222ae5938482c32a822dbf15e19f0f</div></pre></td></tr></table></figure></p>
<p>来自应用程序的日志示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.91.1 - - [02/Aug/2016:14:26:50 +0000] &quot;GET / HTTP/1.0&quot; 200 123 &quot;-&quot; &quot;-&quot; 5f222ae5938482c32a822dbf15e19f0f</div></pre></td></tr></table></figure></p>
<p>通过将 <code>Request ID</code> 字段与事务匹配，<code>Splunk</code> 和 <code>Kibana</code> 之类的工具允许我们识别性能瓶颈。 例如，我们可以搜索花费两秒钟以上时间完成的请求。 然而，在常规时间戳中的默认时间精度为一秒不足以用于大多数真实环境的分析。</p>
<h2 id="高精度时序"><a href="#高精度时序" class="headerlink" title="高精度时序"></a>高精度时序</h2><p>为了准确地测量端到端请求，我们需要具有毫秒级精度的时间戳。 通过在日志条目中包括<code>$msec</code>变量，我们在每个条目的时间戳上获得毫秒的精度。 向应用程序日志添加毫秒时间戳允许我们查找花费 本该不超过200毫秒完成，但却花了2秒的请求。</p>
<p>但是即使这样，我们也没有得到全部的图片，因为<code>NGINX Plus</code>只在处理每个请求结束时写入<code>$msec</code>时间戳。 幸运的是，有几个其他<code>NGINX Plus</code>定时变量，毫秒精度，让我们更深入地了解处理本身：</p>
<ul>
<li><p><code>$request_time</code> – 完全请求时间，从NGINX Plus从客户端读取第一个字节，并在NGINX Plus发送响应主体的最后一个字节时结束</p>
</li>
<li><p><code>$upstream_connect_time</code> – 花费在与<code>upstream</code>服务器建立连接的时间</p>
</li>
<li><p><code>$upstream_header_time</code> – 建立到<code>upstream</code>服务器的连接和接收响应头的第一个字节之间的时间</p>
</li>
<li><p><code>$upstream_response_time</code> – 建立到<code>upstream</code>服务器的连接和接收响应主体的最后一个字节之间的时间</p>
</li>
</ul>
<p>有关这些时序变量的详细信息，请参阅<a href="Using NGINX Logging for Application Performance Monitoring">使用NGINX日志记录应用程序性能监视</a>。</p>
<p>我们可以扩展我们的<code>log_format</code>指令，将所有这些高精度定时变量包含在我们的跟踪日志格式中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">log_format trace &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; $status &apos;</div><div class="line">                 &apos;$body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &apos;</div><div class="line">                 &apos;&quot;$http_x_forwarded_for&quot; $request_id $msec $request_time &apos;</div><div class="line">                 &apos;$upstream_connect_time $upstream_header_time $upstream_response_time&apos;;</div></pre></td></tr></table></figure></p>
<p>使用我们首选的日志分析工具，我们可以提取变量值并执行以下计算，以了解<code>NGINX Plus</code>在连接到应用程序服务器之前处理请求的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NGINX Plus processing time = $request_time - $upstream_connect_time - $upstream_response_time</div></pre></td></tr></table></figure></p>
<p>我们还可以搜索<code>$upstream_response_time</code>的最高值，查看它们是否与特定URI或上游服务器相关联。 然后可以进一步检查具有相同请求ID的应用程序日志条目。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>利用新的<code>$request_id</code>变量和一些毫秒精度的时间变量可以提供对应用程序性能瓶颈的深入了解，提高应用程序性能管理，而无需使用什么重量级代理和插件。</p>
<p><a href="https://www.nginx.com/blog/application-tracing-nginx-plus/" target="_blank" rel="external">【原文】:https://www.nginx.com/blog/application-tracing-nginx-plus/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;使用变量来对应用程序性能进行管理&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变量是NGINX配置的一个重要且有时被忽视的方面。 Nginx 有大约&lt;a href=&quot;http://nginx.org/en/docs/varindex.html&quot;&gt;150个变量&lt;/a&gt;可用，Nginx 变量可用来方便每个部分的配置。 在本博客中，我们讨论如何使用NGINX变量来进行 &lt;strong&gt;应用程序跟踪&lt;/strong&gt; 和 &lt;strong&gt;应用程序性能管理（APM）&lt;/strong&gt; ，重点是发现应用程序中的性能瓶颈。 这篇文章适用于开源的 NGINX 软件和 NGINX Plus。 为了简洁，我们将参考NGINX Plus，除非两个产品之间有差异。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="APM" scheme="https://weizhimiao.github.io/tags/APM/"/>
    
      <category term="应用性能跟踪" scheme="https://weizhimiao.github.io/tags/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>贪婪和懒惰匹配模式使用小结</title>
    <link href="https://weizhimiao.github.io/2016/11/29/%E8%B4%AA%E5%A9%AA%E5%92%8C%E6%87%92%E6%83%B0%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/11/29/贪婪和懒惰匹配模式使用小结/</id>
    <published>2016-11-29T12:30:00.000Z</published>
    <updated>2016-12-14T03:27:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>所谓的贪婪/懒惰匹配模式，就是指正则表达式在匹配字符串是的两种不同的匹配策略。<br>简单的说就是，贪婪匹配模式在正则匹配时会尽量匹配出尽可能多的字符；而懒惰匹配模式则相反，它会匹配尽可能少的字符。</p>
<p>举例来说，</p>
<p>我们要匹配以字符<code>a</code>开始，以<code>b</code>结束的字符串：假如我们要搜索的字符串是<code>aabab</code>，那么分别按照贪婪和懒惰两种模式来匹配，将会得到以下结果：</p>
<ul>
<li><code>aabab</code>(贪婪模式)</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-0@2x.png" alt="贪婪"></p>
<ul>
<li><code>aab</code>(懒惰模式)(为什么不是<code>ab</code>？)</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-1@2x.png" alt="懒惰"></p>
<a id="more"></a>
<h2 id="正则表达式的这两种匹配模式的实现"><a href="#正则表达式的这两种匹配模式的实现" class="headerlink" title="正则表达式的这两种匹配模式的实现"></a>正则表达式的这两种匹配模式的实现</h2><ul>
<li><strong>贪婪</strong> <code>a.*b</code> 一般当一个正则表达式能够匹配出多种结果时，默认将会匹配出尽可能多的字符串。</li>
</ul>
<ul>
<li><strong>懒惰</strong> <code>a.*?b</code>只要表达式中的限定符后面加上一个问号。例如，（<code>.*?</code>）,则会匹配出符合条件的最短的字符。</li>
</ul>
<h2 id="懒惰模式的匹配原理"><a href="#懒惰模式的匹配原理" class="headerlink" title="懒惰模式的匹配原理"></a>懒惰模式的匹配原理</h2><p>简单的来说，就是在匹配喝不匹配都可以的情况下，优先不匹配，记录备选状态，并将匹配控制权交给正则表达式的下一个匹配字符。当后面的匹配失败时，回溯，进行匹配。</p>
<h2 id="常用的懒惰限定符"><a href="#常用的懒惰限定符" class="headerlink" title="常用的懒惰限定符"></a>常用的懒惰限定符</h2><table>
<thead>
<tr>
<th>懒惰限定符代码/语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*?</code></td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>重复1次或多次，但尽可能少重复</td>
</tr>
<tr>
<td><code>??</code></td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,m}?</code></td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,}?</code></td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
<h2 id="示例中，采用a-b表达式进行匹配时，匹配的结果为什么不是ab"><a href="#示例中，采用a-b表达式进行匹配时，匹配的结果为什么不是ab" class="headerlink" title="示例中，采用a.*?b表达式进行匹配时，匹配的结果为什么不是ab"></a>示例中，采用<code>a.*?b</code>表达式进行匹配时，匹配的结果为什么不是<code>ab</code></h2><p>如果我们只考虑<code>.*?</code>这个表达式，<code>aabab</code>字符串中将会匹配出两组字符，一组是<code>aab</code>(1~3字符)，另一组时<code>ab</code>（第2~3个字符）。但为什么结果是<code>aab</code>?按照懒惰模式匹配，他应该匹配出符合条件的最短的字符（最短的字符应该是<code>ab</code>）。</p>
<p>简单的说，正则表达式有一条规则，比懒惰/贪婪规则优先级更高：<strong><em>最先开始的匹配拥有最高优先权</em></strong>。</p>
<p><strong>提示：</strong></p>
<p>在实际开发中，涉及贪婪模式与懒惰模式的地方是很多的。在一定的情况下，使用懒惰模式可以减少回溯，提高效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓的贪婪/懒惰匹配模式，就是指正则表达式在匹配字符串是的两种不同的匹配策略。&lt;br&gt;简单的说就是，贪婪匹配模式在正则匹配时会尽量匹配出尽可能多的字符；而懒惰匹配模式则相反，它会匹配尽可能少的字符。&lt;/p&gt;
&lt;p&gt;举例来说，&lt;/p&gt;
&lt;p&gt;我们要匹配以字符&lt;code&gt;a&lt;/code&gt;开始，以&lt;code&gt;b&lt;/code&gt;结束的字符串：假如我们要搜索的字符串是&lt;code&gt;aabab&lt;/code&gt;，那么分别按照贪婪和懒惰两种模式来匹配，将会得到以下结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aabab&lt;/code&gt;(贪婪模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-0@2x.png&quot; alt=&quot;贪婪&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aab&lt;/code&gt;(懒惰模式)(为什么不是&lt;code&gt;ab&lt;/code&gt;？)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-1@2x.png&quot; alt=&quot;懒惰&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
      <category term="正则表达式" scheme="https://weizhimiao.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Memcached</title>
    <link href="https://weizhimiao.github.io/2016/11/27/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Memcached/"/>
    <id>https://weizhimiao.github.io/2016/11/27/深入了解Memcached/</id>
    <published>2016-11-27T14:30:00.000Z</published>
    <updated>2016-11-29T02:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://n.sinaimg.cn/games/3ece443e/20161128/memcachedDuoXianChengMoXingYuanLiTu.png" alt="Memcached多线程模型原理"></p>
<a id="more"></a>
<h3 id="Memcached的高并发支持原理"><a href="#Memcached的高并发支持原理" class="headerlink" title="Memcached的高并发支持原理"></a>Memcached的高并发支持原理</h3><ul>
<li>多路复用I/O模型</li>
<li>多线程模式</li>
</ul>
<p>Memcached 使用了多路复用I/O模型（如，epoll、select等）。</p>
<p>传统的阻塞I/O中，系统可能会因为某个用户连接还没有做好I/O准备而一直等待，知道这个连接做好I/O准备。如果在这是有其他的用户连接到服务器，很可能会因为系统阻塞而得不到响应。</p>
<p>而多路复用I/O是一种消息通知模式，用户连接做好I/O准备后，系统会通知我们这个连接可以进行I/O操作了，这样系统就不会阻塞在某个用户连接了。因此就能够支持更高的并发。</p>
<p>此外，Memcached使用了多线程模式，在开启Memcached服务器时，通过使用 <code>-t</code> 参数指定要开启的线程数。（但，并不是线程数越多越好，一般设置为CPU核数，这样效率最高。）</p>
<h3 id="Memcached内存分配算法了解"><a href="#Memcached内存分配算法了解" class="headerlink" title="Memcached内存分配算法了解"></a>Memcached内存分配算法了解</h3><p>Memcached 在存储数据时，使用的是Slab内存分配算法。这种算法可以减少生成的内存碎片，提高使用效率。但这种算法也导致Memcached只能够使用不大于1MB的内存（所以，Memcache默认只能存储不大于1MB的数据）。</p>
<h3 id="Slab分配算法原理"><a href="#Slab分配算法原理" class="headerlink" title="Slab分配算法原理"></a>Slab分配算法原理</h3><p>Slab分配算法把每1MB大小的内存块称之为一个slab页，每次向系统申请一个slab页（所以，slab是一次申请内存的最小单位），然后再通过分割算法将这个slab页分割成若干小块的chunk，然后把这些chunk分配给用户使用。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161128/slabNaCunFenPeiYuanLi.png" alt="img"></p>
<p>默认情况下，Memcached可分为40种slab页，每种slab页的chunk块大小都不相同。</p>
<p>当保存数据时Memcached向Slab层申请内存时，Slab层找到一个一个合适的slab页，然后分配其中一个空闲的chunk块给Memcached使用。</p>
<h3 id="Memcached过期数据删除机制"><a href="#Memcached过期数据删除机制" class="headerlink" title="Memcached过期数据删除机制"></a>Memcached过期数据删除机制</h3><p>Memcached 为每一个item都设置了一个过期时间，但不是到期了之后就把item从内存中删除，而是访问item时，先进行判断，如果到期有效期，才把item从内存中删掉。</p>
<h3 id="Memcached淘汰数据算法"><a href="#Memcached淘汰数据算法" class="headerlink" title="Memcached淘汰数据算法"></a>Memcached淘汰数据算法</h3><blockquote>
<p>当内存不足时，Memcached会把访问比较少的或者一段时间没有访问的item淘汰（并不是主动去遍历那些过期的item），以便腾出内存空间存放新的item。</p>
</blockquote>
<p>当Memecached使用的内存数大于设置的内存数之后，为了腾出空间来存放新的数据项，Memcached采用的是LRU算法(最近最少使用算法)来淘汰旧的数据项。</p>
<p>数据淘汰流程：</p>
<ul>
<li>1、当Memcached第一次申请内存失败时，就开始算法进行淘汰数据。</li>
<li>2、首先从数据项列表（item_list）尾部开始遍历。</li>
<li>3、在列表中查找一个引用计数器（refcount）为0的item，把此item占用的内存释放掉。</li>
<li>4、再次申请内存，如果失败的话，继续进行淘汰算法。</li>
<li>5、查找3小时没有访问过的item，并将这些item释放掉。</li>
<li>6、再次申请内存，如果还是失败的话，就返回NULL（申请内存失败）。</li>
</ul>
<p><strong>Tips：</strong></p>
<p>1、为什么从数据项列表尾部开始遍历？</p>
<p>因为，Memcached会把刚刚访问过的item放到item列表头部，所以尾部的item就是没有被访问过的（或者是很少被访问到的），这就是LRU的精髓。</p>
<h3 id="Memcached多线程模型"><a href="#Memcached多线程模型" class="headerlink" title="Memcached多线程模型"></a>Memcached多线程模型</h3><p>Memcached 是一个多线程的缓存服务器程序。在Memcached内部，线程分为：</p>
<ul>
<li>主线程（main thread）：负责接收客户端连接，并把连接分配给工作线程处理；</li>
<li>工作线程（worker thread）：处理主线程分配过来的客户端连接请求。</li>
</ul>
<p>Memcached 多线程模型原理如图所示。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161128/memcachedDuoXianChengMoXingYuanLiTu.png" alt="Memcached多线程模型原理"></p>
<p>主线程主要负责侦听客户端连接，在客户端连接到Memcached时，Memcached接收到来的请求，并把连接push到工作线程的CQ队列中，并向工作线程发送一个信号，告诉工作线程有新的客户端连接需要处理。</p>
<p>当工作线程收到主线程的信号后，便会把CQ队列上的客户端连接注册到libevent进行侦听，libevent会侦听客户端连接的读写请求，病调用相关的回调函数进行处理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161128/memcachedDuoXianChengMoXingYuanLiTu.png&quot; alt=&quot;Memcached多线程模型原理&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="memcached" scheme="https://weizhimiao.github.io/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>Linux中借助lockf简单实现和应用文件锁机制</title>
    <link href="https://weizhimiao.github.io/2016/11/16/%E6%96%87%E4%BB%B6%E9%94%81%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://weizhimiao.github.io/2016/11/16/文件锁机制实现与应用/</id>
    <published>2016-11-16T13:30:00.000Z</published>
    <updated>2016-11-29T02:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>文件锁机制的作用：防止多个程序同时对一个不允许同时操作的工作做操作。</p>
<a id="more"></a>
<h2 id="实现-lockf"><a href="#实现-lockf" class="headerlink" title="实现(lockf)"></a>实现(lockf)</h2><p>在Linux中我们可以借助lockf命令来实现文件锁机制</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -xzf lockf_linux.tar.gz</div><div class="line">cd lockf_linux</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lockf --help</div><div class="line">  -k 锁定文件，如果当前文件被锁，则输出 lockf:/tmp/create/lock :already locked</div><div class="line">  -s 锁定文件，不输出任何信息 silent</div><div class="line">  -t second ：超时时间，超时就退出</div></pre></td></tr></table></figure>
<h3 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lockf -s -t 0 /tmp/create.lock /usr/local/bin/php -f xxx.php</div></pre></td></tr></table></figure>
<blockquote>
<p>先判断/tmp/create.lock 文件是否被锁，被锁则立即退出，否则将会执行后面的脚本。</p>
</blockquote>
<p>第一次运行会给<code>/tmp/create.lock</code> 文件上锁，并执行后面的命令，</p>
<p>当第二次运行该命令时，<code>/tmp/create.lock</code> 文件已经被锁，命令将会直接退出，而不会去执行后面的<code>/usr/local/bin/php -f xxx.php</code> 的脚本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件锁机制的作用：防止多个程序同时对一个不允许同时操作的工作做操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="文件锁机制" scheme="https://weizhimiao.github.io/tags/%E6%96%87%E4%BB%B6%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Bash脚本15分钟进阶教程[转]</title>
    <link href="https://weizhimiao.github.io/2016/11/16/Bash%E8%84%9A%E6%9C%AC15%E5%88%86%E9%92%9F%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"/>
    <id>https://weizhimiao.github.io/2016/11/16/Bash脚本15分钟进阶教程/</id>
    <published>2016-11-16T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里的技术技巧最初是来自谷歌的“Testing on the Toilet” (TOTT)。这里是一个修订和扩增版本。</p>
<ul>
<li>脚本安全</li>
<li>脚本函数</li>
<li>变量注解</li>
<li>用$()代替反单引号(`)</li>
<li>用<code>[[]]</code>(双层中括号)替代[]</li>
<li>正则表达式/Globbing</li>
<li>字符串操作</li>
<li>避免使用临时文件</li>
<li>内置变量</li>
<li>调试</li>
<li>什么时候不应该使用bash脚本</li>
</ul>
<a id="more"></a>
<h2 id="脚本安全"><a href="#脚本安全" class="headerlink" title="脚本安全"></a>脚本安全</h2><p>我的所有bash脚本都以下面几句为开场白：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">   <span class="built_in">set</span> -o nounset</div><div class="line">   <span class="built_in">set</span> -o errexit</div></pre></td></tr></table></figure></p>
<p>这样做会避免两种常见的问题：</p>
<ul>
<li>引用未定义的变量(缺省值为“”)</li>
<li>执行失败的命令被忽略</li>
</ul>
<p>需要注意的是，有些Linux命令的某些参数可以强制忽略发生的错误，例如“mkdir -p” 和 “rm -f”。</p>
<p>还要注意的是，在“errexit”模式下，虽然能有效的捕捉错误，但并不能捕捉全部失败的命令，在某些情况下，一些失败的命令是无法检测到的。(更多细节请参考<a href="https://groups.google.com/forum/?fromgroups#!topic/gnu.bash.bug/-9ySnEo1WrQ" target="_blank" rel="external">这个帖子</a>。)</p>
<h2 id="脚本函数"><a href="#脚本函数" class="headerlink" title="脚本函数"></a>脚本函数</h2><p>在bash里你可以定义函数，它们就跟其它命令一样，可以随意的使用；它们能让你的脚本更具可读性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">ExtractBashComments</span></span>() &#123;</div><div class="line">    egrep <span class="string">"^#"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">cat myscript.sh | ExtractBashComments | wc</div><div class="line"></div><div class="line">comments=$(ExtractBashComments &lt; myscript.sh)</div></pre></td></tr></table></figure>
<p>还有一些例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">SumLines</span></span>() &#123;  <span class="comment"># iterating over stdin - similar to awk      </span></div><div class="line">    <span class="built_in">local</span> sum=0</div><div class="line">    <span class="built_in">local</span> line=””</div><div class="line">    <span class="keyword">while</span> <span class="built_in">read</span> line ; <span class="keyword">do</span></div><div class="line">        sum=$((<span class="variable">$&#123;sum&#125;</span> + <span class="variable">$&#123;line&#125;</span>))</div><div class="line">    <span class="keyword">done</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;sum&#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">SumLines &lt; data_one_number_per_line.txt</div><div class="line"></div><div class="line"><span class="function"><span class="title">log</span></span>() &#123;  <span class="comment"># classic logger</span></div><div class="line">   <span class="built_in">local</span> prefix=<span class="string">"[<span class="variable">$(date +%Y/%m/%d\ %H:%M:%S)</span>]: "</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;prefix&#125;</span> <span class="variable">$@</span>"</span> &gt;&amp;2</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">log</span> <span class="string">"INFO"</span> <span class="string">"a message"</span></div></pre></td></tr></table></figure>
<p>尽可能的把你的bash代码移入到函数里，仅把全局变量、常量和对“main”调用的语句放在最外层。</p>
<h2 id="变量注解"><a href="#变量注解" class="headerlink" title="变量注解"></a>变量注解</h2><p>Bash里可以对变量进行有限的注解。最重要的两个注解是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">local</span>(函数内部变量)</div><div class="line"><span class="built_in">readonly</span>(只读变量)</div><div class="line">    <span class="comment"># a useful idiom: DEFAULT_VAL can be overwritten</span></div><div class="line">    <span class="comment">#       with an environment variable of the same name</span></div><div class="line">    <span class="built_in">readonly</span> DEFAULT_VAL=<span class="variable">$&#123;DEFAULT_VAL:-7&#125;</span></div><div class="line"></div><div class="line">    <span class="function"><span class="title">myfunc</span></span>() &#123;</div><div class="line">       <span class="comment"># initialize a local variable with the global default</span></div><div class="line">       <span class="built_in">local</span> some_var=<span class="variable">$&#123;DEFAULT_VAL&#125;</span></div><div class="line">       ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这样，你可以将一个以前不是只读变量的变量声明成只读变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x=5</div><div class="line">x=6</div><div class="line"><span class="built_in">readonly</span> x</div><div class="line">x=7   <span class="comment"># failure</span></div></pre></td></tr></table></figure>
<p>尽量对你bash脚本里的所有变量使用local或readonly进行注解。</p>
<h2 id="用-代替反单引号"><a href="#用-代替反单引号" class="headerlink" title="用$()代替反单引号(`)"></a>用$()代替反单引号(`)</h2><p>反单引号很难看，在有些字体里跟正单引号很相似。$()能够内嵌使用，而且避免了转义符的麻烦。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># both commands below print out: A-B-C-D</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"A-`echo B-\`echo C-\\\`echo D\\\`\``"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"A-<span class="variable">$(echo B-$(echo C-$(echo D)</span>))"</span></div></pre></td></tr></table></figure></p>
<h2 id="用-双层中括号-替代"><a href="#用-双层中括号-替代" class="headerlink" title="用[[]](双层中括号)替代[]"></a>用<code>[[]]</code>(双层中括号)替代[]</h2><p>使用[[]]能避免像异常的文件扩展名之类的问题，而且能带来很多语法上的改进，而且还增加了很多新功能：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#124;&#124;</td>
<td>逻辑or(仅双中括号里使用)</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑and(仅双中括号里使用)</td>
</tr>
<tr>
<td>&lt;</td>
<td>字符串比较(双中括号里不需要转移)</td>
</tr>
<tr>
<td>-lt</td>
<td>数字比较</td>
</tr>
<tr>
<td>=</td>
<td>字符串相等</td>
</tr>
<tr>
<td>==</td>
<td>以Globbing方式进行字符串比较(仅双中括号里使用，参考下文)</td>
</tr>
<tr>
<td>=~</td>
<td>用正则表达式进行字符串比较(仅双中括号里使用，参考下文)</td>
</tr>
<tr>
<td>-n</td>
<td>非空字符串</td>
</tr>
<tr>
<td>-z</td>
<td>空字符串</td>
</tr>
<tr>
<td>-eq</td>
<td>数字相等</td>
</tr>
<tr>
<td>-ne</td>
<td>数字不等</td>
</tr>
</tbody>
</table>
<p>单中括号：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> \&gt; <span class="string">"a"</span> -o <span class="variable">$&#123;name&#125;</span> \&lt; <span class="string">"m"</span> ]</div></pre></td></tr></table></figure></p>
<p>双中括号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[ <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> &gt; <span class="string">"a"</span> &amp;&amp; <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> &lt; <span class="string">"m"</span>  ]]</div></pre></td></tr></table></figure></p>
<h2 id="正则表达式-Globbing"><a href="#正则表达式-Globbing" class="headerlink" title="正则表达式/Globbing"></a>正则表达式/Globbing</h2><p>使用双中括号带来的好处用下面几个例子最能表现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t=<span class="string">"abc123"</span></div><div class="line">[[ <span class="string">"<span class="variable">$t</span>"</span> == abc* ]]         <span class="comment"># true (globbing比较)</span></div><div class="line">[[ <span class="string">"<span class="variable">$t</span>"</span> == <span class="string">"abc*"</span> ]]       <span class="comment"># false (字面比较)</span></div><div class="line">[[ <span class="string">"<span class="variable">$t</span>"</span> =~ [abc]+[123]+ ]] <span class="comment"># true (正则表达式比较)</span></div><div class="line">[[ <span class="string">"<span class="variable">$t</span>"</span> =~ <span class="string">"abc*"</span> ]]       <span class="comment"># false (字面比较)</span></div></pre></td></tr></table></figure></p>
<p>注意，从bash 3.2版开始，正则表达式和globbing表达式都不能用引号包裹。如果你的表达式里有空格，你可以把它存储到一个变量里：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r=<span class="string">"a b+"</span></div><div class="line">[[ <span class="string">"a bbb"</span> =~ <span class="variable">$r</span> ]]        <span class="comment"># true</span></div></pre></td></tr></table></figure></p>
<p>按Globbing方式的字符串比较也可以用到case语句中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="variable">$t</span> <span class="keyword">in</span></div><div class="line">abc*)  &lt;action&gt; ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure></p>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>Bash里有各种各样操作字符串的方式，很多都是不可取的。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">f=<span class="string">"path1/path2/file.ext"</span>  </div><div class="line"></div><div class="line">len=<span class="string">"<span class="variable">$&#123;#f&#125;</span>"</span> <span class="comment"># = 20 (字符串长度)</span></div><div class="line"></div><div class="line"><span class="comment"># 切片操作: $&#123;&lt;var&gt;:&lt;start&gt;&#125; or $&#123;&lt;var&gt;:&lt;start&gt;:&lt;length&gt;&#125;</span></div><div class="line">slice1=<span class="string">"<span class="variable">$&#123;f:6&#125;</span>"</span> <span class="comment"># = "path2/file.ext"</span></div><div class="line">slice2=<span class="string">"<span class="variable">$&#123;f:6:5&#125;</span>"</span> <span class="comment"># = "path2"</span></div><div class="line">slice3=<span class="string">"<span class="variable">$&#123;f: -8&#125;</span>"</span> <span class="comment"># = "file.ext"(注意："-"前有空格)</span></div><div class="line">pos=6</div><div class="line">len=5</div><div class="line">slice4=<span class="string">"<span class="variable">$&#123;f:$&#123;pos&#125;</span>:<span class="variable">$&#123;len&#125;</span>&#125;"</span> <span class="comment"># = "path2"</span></div></pre></td></tr></table></figure>
<h3 id="替换操作-使用globbing"><a href="#替换操作-使用globbing" class="headerlink" title="替换操作(使用globbing)"></a>替换操作(使用globbing)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">f=<span class="string">"path1/path2/file.ext"</span>  </div><div class="line"></div><div class="line">single_subst=<span class="string">"<span class="variable">$&#123;f/path?/x&#125;</span>"</span>   <span class="comment"># = "x/path2/file.ext"</span></div><div class="line">global_subst=<span class="string">"<span class="variable">$&#123;f//path?/x&#125;</span>"</span>  <span class="comment"># = "x/x/file.ext"</span></div><div class="line"></div><div class="line"><span class="comment"># 字符串拆分</span></div><div class="line"><span class="built_in">readonly</span> DIR_SEP=<span class="string">"/"</span></div><div class="line">array=(<span class="variable">$&#123;f//$&#123;DIR_SEP&#125;</span>/ &#125;)</div><div class="line">second_dir=<span class="string">"<span class="variable">$&#123;arrray[1]&#125;</span>"</span>     <span class="comment"># = path2</span></div></pre></td></tr></table></figure>
<h3 id="删除头部或尾部-使用globbing"><a href="#删除头部或尾部-使用globbing" class="headerlink" title="删除头部或尾部(使用globbing)"></a>删除头部或尾部(使用globbing)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">f=<span class="string">"path1/path2/file.ext"</span></div><div class="line"></div><div class="line"><span class="comment"># 删除字符串头部</span></div><div class="line">extension=<span class="string">"<span class="variable">$&#123;f#*.&#125;</span>"</span>  <span class="comment"># = "ext"</span></div><div class="line"></div><div class="line"><span class="comment"># 以贪婪匹配方式删除字符串头部</span></div><div class="line">filename=<span class="string">"<span class="variable">$&#123;f##*/&#125;</span>"</span>  <span class="comment"># = "file.ext"</span></div><div class="line"></div><div class="line"><span class="comment"># 删除字符串尾部</span></div><div class="line">dirname=<span class="string">"<span class="variable">$&#123;f%/*&#125;</span>"</span>    <span class="comment"># = "path1/path2"</span></div><div class="line"></div><div class="line"><span class="comment"># 以贪婪匹配方式删除字符串尾部</span></div><div class="line">root=<span class="string">"<span class="variable">$&#123;f%%/*&#125;</span>"</span>      <span class="comment"># = "path1"</span></div></pre></td></tr></table></figure>
<h2 id="避免使用临时文件"><a href="#避免使用临时文件" class="headerlink" title="避免使用临时文件"></a>避免使用临时文件</h2><p>有些命令需要以文件名为参数，这样一来就不能使用管道。这个时候 &lt;() 就显出用处了，它可以接受一个命令，并把它转换成可以当成文件名之类的什么东西：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 下载并比较两个网页</span></div><div class="line">diff &lt;(wget -O - url1) &lt;(wget -O - url2)</div></pre></td></tr></table></figure></p>
<p>还有一个非常有用处的是”here documents”，它能让你在标准输入上输入多行字符串。下面的’MARKER’可以替换成任何字词。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 任何字词都可以当作分界符</span></div><div class="line"><span class="built_in">command</span>  &lt;&lt; MARKER</div><div class="line">...</div><div class="line"><span class="variable">$&#123;var&#125;</span></div><div class="line">$(cmd)</div><div class="line">...</div><div class="line">MARKER</div></pre></td></tr></table></figure></p>
<p>如果文本里没有内嵌变量替换操作，你可以把第一个MARKER用单引号包起来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">command</span> &lt;&lt; <span class="string">'MARKER'</span></div><div class="line">...</div><div class="line">no substitution is happening here.</div><div class="line">$ (dollar sign) is passed through verbatim.</div><div class="line">...</div><div class="line">MARKER</div></pre></td></tr></table></figure></p>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>脚本名称</td>
</tr>
<tr>
<td>$n</td>
<td>传给脚本/函数的第n个参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本的PID</td>
</tr>
<tr>
<td>$!</td>
<td>上一个被执行的命令的PID(后台运行的进程)</td>
</tr>
<tr>
<td>$?</td>
<td>上一个命令的退出状态(管道命令使用${PIPESTATUS})</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本/函数的参数个数</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本/函数的所有参数(识别每个参数)</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本/函数的所有参数(把所有参数当成一个字符串)</td>
</tr>
</tbody>
</table>
<p><strong>提示</strong></p>
<blockquote>
<p>使用$*很少是正确的选择。</p>
<p>$@能够处理空格参数，而且参数间的空格也能正确的处理。</p>
<p>使用$@时应该用双引号括起来，像”$@”这样。</p>
</blockquote>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>对脚本进行语法检查：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -n myscript.sh</div></pre></td></tr></table></figure></p>
<p>跟踪脚本里每个命令的执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -v myscripts.sh</div></pre></td></tr></table></figure></p>
<p>跟踪脚本里每个命令的执行并附加扩充信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -x myscript.sh</div></pre></td></tr></table></figure></p>
<p>你可以在脚本头部使用set -o verbose和set -o xtrace来永久指定-v和-o。当在远程机器上执行脚本时，这样做非常有用，用它来输出远程信息。</p>
<h2 id="什么时候不应该使用bash脚本"><a href="#什么时候不应该使用bash脚本" class="headerlink" title="什么时候不应该使用bash脚本"></a>什么时候不应该使用bash脚本</h2><ul>
<li>你的脚本太长，多达几百行</li>
<li>你需要比数组更复杂的数据结构</li>
<li>出现了复杂的转义问题</li>
<li>有太多的字符串操作</li>
<li>不太需要调用其它程序和跟其它程序管道交互</li>
<li>担心性能</li>
</ul>
<p>这个时候，你应该考虑一种脚本语言，比如Python或Ruby。</p>
<p>[转自 <a href="http://blog.sae.sina.com.cn/archives/3606" target="_blank" rel="external">http://blog.sae.sina.com.cn/archives/3606</a>]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里的技术技巧最初是来自谷歌的“Testing on the Toilet” (TOTT)。这里是一个修订和扩增版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脚本安全&lt;/li&gt;
&lt;li&gt;脚本函数&lt;/li&gt;
&lt;li&gt;变量注解&lt;/li&gt;
&lt;li&gt;用$()代替反单引号(`)&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;[[]]&lt;/code&gt;(双层中括号)替代[]&lt;/li&gt;
&lt;li&gt;正则表达式/Globbing&lt;/li&gt;
&lt;li&gt;字符串操作&lt;/li&gt;
&lt;li&gt;避免使用临时文件&lt;/li&gt;
&lt;li&gt;内置变量&lt;/li&gt;
&lt;li&gt;调试&lt;/li&gt;
&lt;li&gt;什么时候不应该使用bash脚本&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://weizhimiao.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>sudo使用场景分析[转]</title>
    <link href="https://weizhimiao.github.io/2016/11/16/sudo%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <id>https://weizhimiao.github.io/2016/11/16/sudo使用场景分析/</id>
    <published>2016-11-16T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下使用 sudo 命令，可以让普通用户也能执行一些或者全部的 root 命令。本文就对我们常用到 sudo 操作情景进行简单分析，通过一些例子来了解 sudo 命令相关的技巧。</p>
<ul>
<li><p>情景一：用户无权限执行 root 命令</p>
</li>
<li><p>情景二：vim 编辑后发现忘记使用 sudo</p>
</li>
<li><p>情景三：执行 root 命令忘记加 sudo</p>
</li>
<li><p>情景四：shell 内置命令如何使用 sudo</p>
</li>
<li><p>情景五：sudo 操作记录日志</p>
</li>
</ul>
<a id="more"></a>
<h2 id="情景一：用户无权限执行-root-命令"><a href="#情景一：用户无权限执行-root-命令" class="headerlink" title="情景一：用户无权限执行 root 命令"></a>情景一：用户无权限执行 root 命令</h2><p>普通用户登录 shell 之后，如果自身没有权限访问某个文件或执行某个命令时，若该用户获得root授权，那么就可以在需要执行的命令之前加上 sudo，临时切换到root用户的权限，完成相关的操作。在sudo于1980年前后被写出之前，一般用户管理系统的方式是利用su切换为超级用户。但是使用su的缺点之一在于必须要先告知超级用户的密码，而sudo使一般用户不需要知道超级用户的密码即可获得权限。</p>
<p>那么哪些用户可以临时获得 root 权限呢？这就需要在 <code>/etc/sudoers</code> 文件中进行配置：</p>
<p>授权给单个用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># User privilege specification</div><div class="line">guohl   ALL=(ALL) ALL</div></pre></td></tr></table></figure></p>
<p>上面这个例子中：</p>
<ul>
<li><p>guohl：允许使用 sudo 的用户名</p>
</li>
<li><p>ALL：允许从任何终端（任何机器）使用 sudo</p>
</li>
<li><p>(ALL)：允许以任何用户执行 sudo 命令</p>
</li>
<li><p>ALL：允许 sudo 权限执行任何命令</p>
</li>
</ul>
<p>如果我们想让用户 test 只能在本主机（主机名为guohl-pc）以 root 账户执行/bin/chown、/bin/chmod 两条命令，那么就应该这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># User privilege specification</div><div class="line">test   guohl-pc=(root) /bin/chown,/bin/chmod</div></pre></td></tr></table></figure></p>
<p>如果test 登录之后运行 sudo 命令，不满足上面三个条件命令均失败。</p>
<p>授权给用户组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Allow members of group sudo to execute any command</div><div class="line"># (Note that later entries override this, so you might need to move it further down)</div><div class="line">%sudo ALL=(ALL) ALL</div><div class="line">和授权给单个用户类似，只不过将用户名在这里换成%组名，所有在该组中的用户都按照此规则进行授权。对于该例，所有在 sudo 组内的用户都有在任何终端（第一个ALL）、以任何用户（第二个ALL）、执行任何命令（第三个ALL）的权限，查看 /etc/group 文件可以知道哪些用户属于 sudo 组。</div></pre></td></tr></table></figure></p>
<p>举例:</p>
<p>如果当前帐号在 /etc/sudoers 文件中被授予 sudo 的权限，那么你就可以将任何 root 命令作为 sudo 命令的参数，使用 root 权限来执行该命令。举例来说，挂载一个文件系统只能由 root 来执行，但是一个普通用户也可以使用 sudo 来挂载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$sudo mount /dev/sda7 /mnt</div><div class="line">[sudo] password for guohailin:</div></pre></td></tr></table></figure>
<p>首次使用会要求你输入当前用户的密码，系统确实输入正确即以 root 权限来执行 mount 命令，接下来一段时间（默认为5分钟）再次使用 sudo 命令就不需要输密码了。</p>
<h2 id="情景二：vim-编辑后发现忘记使用-sudo"><a href="#情景二：vim-编辑后发现忘记使用-sudo" class="headerlink" title="情景二：vim 编辑后发现忘记使用 sudo"></a>情景二：vim 编辑后发现忘记使用 sudo</h2><p>我们经常会遇到这样的一个囧境：使用 <code>vim</code> 对某个文件进行编辑，编辑完之后，按 ESC 之后回到普通模式，再按 <code>:wq</code> 准备保存退出时，发现没有权限对该文件进行修改，我们在使用 <code>vim</code> 命令时忘记在前面加 <code>sudo</code> 了。我就经常出现这种问题，之前的做法是只能不保存强退，再加上 <code>sudo</code> 重新编辑。</p>
<p>但是今后我们再也不需要用这么愚蠢的做法了，我们可以在 vim 的普通模式下，按 <code>:w !sudo tee %</code>，这样就可以 root 权限来保存文件了，你也无需因为自己一时忘记加个 sudo 而沮丧懊恼了！</p>
<h2 id="情景三：执行-root-命令忘记加-sudo"><a href="#情景三：执行-root-命令忘记加-sudo" class="headerlink" title="情景三：执行 root 命令忘记加 sudo"></a>情景三：执行 root 命令忘记加 sudo</h2><p>我们还会遇到这样稍微好一点的情形：输入一个长长的命令，按 Enter 之后出现无权限操作，因为我们忘记加 sudo 了。大多人的做法是按 ↑ 回到上一条命令，在该命令之前加上 sudo，再执行该命令。</p>
<p>以后，我们无需这样了，只要输入 <code>sudo !!</code> 即可，这里的 <code>!!</code> 代表上一条命令。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ head -n 4 /etc/sudoers</div><div class="line">head: cannot open `/etc/sudoers&apos; for reading: Permission denied</div><div class="line"></div><div class="line">$ sudo !!</div><div class="line">sudo head -n 4 /etc/sudoers</div><div class="line"># /etc/sudoers</div><div class="line">#</div><div class="line"># This file MUST be edited with the &apos;visudo&apos; command as root.</div><div class="line">#</div></pre></td></tr></table></figure></p>
<h2 id="情景四：shell-内置命令如何使用-sudo"><a href="#情景四：shell-内置命令如何使用-sudo" class="headerlink" title="情景四：shell 内置命令如何使用 sudo"></a>情景四：shell 内置命令如何使用 sudo</h2><p>shell 是一个交互式的应用程序，在执行外部命令时通过 fork 来创建一个子进程，再通过 exec 来加载外部命令的程序来执行，但是如果一个命令是 shell 内置命令，那么只能直接由 shell 来运行。sudo 的意思是，以别的用户（如root）的权限来 fork 一个进程，加载程序并运行，因此 sudo 后面不能跟 shell 的内置命令，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo cd /sys/kernel/debugfs</div><div class="line">sudo: cd: command not found</div></pre></td></tr></table></figure>
<p>在这种情况，我们又没有 root 账户的密码，我们怎样执行该命令呢？有种办法就是使用 sudo 获得root shell 的权限，然后在root shell 中执行该命令。进入root shell 很简单，输入sudo bash 确认本用户的密码即可，此时你会发现命令提示符显示当前是 root。一旦获得root shell，你可以执行任何命令而不需要在每条命令前输入sudo了。</p>
<p>另外，常用的shell 内置命令在<a href="http://www.thegeekstuff.com/2010/08/bash-shell-builtin-commands/" target="_blank" rel="external">这里</a> 有简单介绍，我们可以使用 type 命令来查看命令的类型，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ type ls</div><div class="line">ls is /bin/ls</div><div class="line">$ type umask</div><div class="line">umask is a shell builtin</div></pre></td></tr></table></figure>
<h2 id="情景五：sudo-操作记录日志"><a href="#情景五：sudo-操作记录日志" class="headerlink" title="情景五：sudo 操作记录日志"></a>情景五：sudo 操作记录日志</h2><p>作为一个 Linux 系统的管理员，不仅可以让指定的用户或用户组作为root用户或其它用户来运行某些命令，还能将指定的用户所输入的命令和参数作详细的记录。而sudo的日志功能就可以用户跟踪用户输入的命令，这不仅能增进系统的安全性，还能用来进行故障检修。但是要记录sudo的日志还要一些简单的配置：</p>
<p>1、创建sudo日志文件</p>
<p>我们将sudo日志文件放置在 <code>/var/log/sudo.log</code> 文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo touch /var/log/sudo.log</div></pre></td></tr></table></figure></p>
<p>2、修改 <code>/etc/rsyslog.conf</code> 配置文件</p>
<p>我使用系统为<code>Ubuntu13.04</code>为改名字，但有些系统名为<code>/etc/syslog.conf</code>，注意不同发行版之间的差别，在该文件加入下面一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">local2.debug    /var/log/sudo.log    #空白不能用空格，必须用tab</div></pre></td></tr></table></figure>
<p>3、修改 /etc/sudoers 配置文件</p>
<p>注意网上很多关于sudo日志文件配置都缺少这一步！在该文件中加入下面一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Defaults    logfile=/var/log/sudo.log</div></pre></td></tr></table></figure></p>
<p>4、重启 syslog 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service rsyslog restart</div></pre></td></tr></table></figure></p>
<p>5、查看 sudo 日志记录：</p>
<p>经过上面的配置，sudo 的所有成功和不成功的sudo</p>
<p>命令都记录到文件/var/log/sudo.log 中，例如我运行几条sudo 命令之后，查看该文件的记录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat sudo.log</div><div class="line">Sep 20 22:10:51 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;</div><div class="line">    COMMAND=/bin/cat /etc/sudoers</div><div class="line">Sep 20 22:11:36 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;</div><div class="line">    COMMAND=/usr/sbin/service rsyslog restart</div><div class="line">Sep 20 22:11:45 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;</div><div class="line">    COMMAND=/bin/ls</div><div class="line">Sep 20 22:12:08 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;</div><div class="line">    COMMAND=/bin/ls /root/</div></pre></td></tr></table></figure></p>
<p>[原文：<a href="http://www.cnblogs.com/hazir/p/sudo_command.html" target="_blank" rel="external">http://www.cnblogs.com/hazir/p/sudo_command.html</a>]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 下使用 sudo 命令，可以让普通用户也能执行一些或者全部的 root 命令。本文就对我们常用到 sudo 操作情景进行简单分析，通过一些例子来了解 sudo 命令相关的技巧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;情景一：用户无权限执行 root 命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景二：vim 编辑后发现忘记使用 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景三：执行 root 命令忘记加 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景四：shell 内置命令如何使用 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景五：sudo 操作记录日志&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="sudo" scheme="https://weizhimiao.github.io/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法与实现（PHP）汇总</title>
    <link href="https://weizhimiao.github.io/2016/11/07/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88PHP%EF%BC%89%E6%B1%87%E6%80%BB/"/>
    <id>https://weizhimiao.github.io/2016/11/07/常见的排序算法与实现（PHP）汇总/</id>
    <published>2016-11-07T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>堆排序</li>
<li>桶排序</li>
<li>基数排序</li>
<li>希尔排序</li>
</ul>
<a id="more"></a>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>在排序的一组数中，对当前还未排好的序列，从前后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的数往上冒。</p>
<p>即，每当两个相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [bubblingSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bubblingSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    $len = count($arr);</div><div class="line"></div><div class="line">    <span class="comment">//控制需要冒泡的轮数</span></div><div class="line">    <span class="keyword">for</span>($i = <span class="number">1</span>;$i &lt; $len; $i++)&#123;</div><div class="line">      <span class="comment">//控制每层冒出一个数 需要比较的次数</span></div><div class="line">      <span class="keyword">for</span>($k = <span class="number">0</span>; $k &lt; $len-$i; $k++)&#123;</div><div class="line">        <span class="keyword">if</span>($arr[$k] &gt; $arr[$k+<span class="number">1</span>])&#123;</div><div class="line">          $temp = $arr[$k+<span class="number">1</span>];</div><div class="line">          $arr[$k+<span class="number">1</span>] = $arr[$k];</div><div class="line">          $arr[$k] = $temp;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(bubblingSort($arr));</div></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>在要排序的一组数中，选出最小的一个数与第一个位置的数交换。</p>
<p>然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [selectSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">selectSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    <span class="comment">//双重循环，外层控制循环轮数，内层控制比较次数</span></div><div class="line">    $len = count($arr);</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$len<span class="number">-1</span>;$i++)&#123;</div><div class="line">      <span class="comment">//先假设最小的值的位置</span></div><div class="line">      $p = $i;</div><div class="line"></div><div class="line">      <span class="keyword">for</span>($j=$i+<span class="number">1</span>;$j&lt;$len;$j++)&#123;</div><div class="line">        <span class="comment">//$arr[$p] 是当前已知的最小值</span></div><div class="line">        <span class="keyword">if</span>($arr[$p] &gt; $arr[$j])&#123;</div><div class="line">          <span class="comment">//比较，发现更小的，记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较</span></div><div class="line">          $p = $j;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。</span></div><div class="line">      <span class="keyword">if</span>($p != $i)&#123;</div><div class="line">        $tmp = $arr[$p];</div><div class="line">        $arr[$p] = $arr[$i];</div><div class="line">        $arr[$i] = $tmp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(selectSort($arr));</div></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插入到前面的有序数中，使得这n个数也是排好序的。如此反复循环，直到全部排好顺序。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [insertSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insertSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    $len = count($arr);</div><div class="line"></div><div class="line">    <span class="keyword">for</span>($i=<span class="number">1</span>;$i&lt;$len;$i++)&#123;</div><div class="line">      $tmp = $arr[$i];</div><div class="line">      <span class="comment">//内层循环控制，比较并插入</span></div><div class="line">      <span class="keyword">for</span>($j=$i<span class="number">-1</span>;$j&gt;=<span class="number">0</span>;$j--)&#123;</div><div class="line">        <span class="keyword">if</span>($tmp &lt; $arr[$j])&#123;</div><div class="line">          <span class="comment">//发现插入的元素要小，交换位置，将后边的元素与前面的元素互换</span></div><div class="line">          $arr[$j+<span class="number">1</span>] = $arr[$j];</div><div class="line">          $arr[$j] = $tmp;</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">          <span class="comment">//如果碰到不需要移动的元素，由于是已经排序好的数组，则前面的就不需要再次比较了</span></div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(insertSort($arr));</div></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。</p>
<p>此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [quickSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    <span class="comment">//先判断是否需要继续进行</span></div><div class="line">    $len = count($arr);</div><div class="line">    <span class="keyword">if</span>($len &lt;= <span class="number">1</span>)&#123;</div><div class="line">      <span class="keyword">return</span> $arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//选择第一个元素作为基准</span></div><div class="line">    $base_num = $arr[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">//遍历除了标尺外的所有元素，按照大小关系放入两个数组内</span></div><div class="line">    <span class="comment">//初始化两个数组</span></div><div class="line">    $left_array = <span class="keyword">array</span>();  <span class="comment">//小于基准值的数组</span></div><div class="line">    $right_array = <span class="keyword">array</span>();   <span class="comment">//大于基准的数组</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>($i=<span class="number">1</span>;$i&lt;$len;$i++)&#123;</div><div class="line">      <span class="keyword">if</span>($base_num &gt; $arr[$i])&#123;</div><div class="line">        <span class="comment">//放入左边</span></div><div class="line">        $left_array[] = $arr[$i];</div><div class="line">      &#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//放入右边</span></div><div class="line">        $right_array[] = $arr[$i];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数</span></div><div class="line">    $left_array = quickSort($left_array);</div><div class="line">    $right_array = quickSort($right_array);</div><div class="line"></div><div class="line">    <span class="comment">//合并</span></div><div class="line">    <span class="keyword">return</span> array_merge($left_array, <span class="keyword">array</span>($base_num), $right_array);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(quickSort($arr));</div></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>采用分治法，将已有序的子序列合并,从而得到完全有序的序列.</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [mergeSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    $len = count($arr);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>($len &lt; <span class="number">2</span>)&#123;</div><div class="line">      <span class="keyword">return</span> $arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获取中间参考点值</span></div><div class="line">    $middle = floor($len/<span class="number">2</span>);</div><div class="line">    <span class="comment">//取左边区间</span></div><div class="line">    $left = array_slice($arr, <span class="number">0</span>, $middle);</div><div class="line">    <span class="comment">//取右边区间</span></div><div class="line">    $right = array_slice($arr, $middle);</div><div class="line"></div><div class="line">    <span class="comment">//调用归并函数</span></div><div class="line">    <span class="keyword">return</span> merge(mergeSort($left), mergeSort($right));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 归并函数</div><div class="line">   * <span class="doctag">@param</span>  [type] $left  [description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $right [description]</div><div class="line">   * <span class="doctag">@return</span> [type]        [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">($left, $right)</span></span>&#123;</div><div class="line">    $res = <span class="keyword">array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(count($left) &gt; <span class="number">0</span> &amp;&amp; count($right) &gt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">if</span>($left[<span class="number">0</span>] &lt;= $right[<span class="number">0</span>])&#123;</div><div class="line">        array_push($res, array_shift($left));</div><div class="line">      &#125; <span class="keyword">else</span>&#123;</div><div class="line">        array_push($res, array_shift($right));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//解决$left遗留元素</span></div><div class="line">    <span class="keyword">while</span>(count($left) &gt; <span class="number">0</span>)&#123;</div><div class="line">      array_push($res, array_shift($left));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//解决$right遗留元素</span></div><div class="line">    <span class="keyword">while</span>(count($right) &gt; <span class="number">0</span>)&#123;</div><div class="line">      array_push($res, array_shift($right));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(mergeSort($arr));</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>思路分析<blockquote>
<p><strong>建堆</strong>，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。</p>
<p><strong>调整堆</strong>：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。</p>
<p><strong>堆排序</strong>：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是O(nlgn)。因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是lgn，调用了n-1次，所以堆排序的时间复杂度是O(nlgn)</p>
</blockquote>
</li>
</ul>
<ul>
<li>实现</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [heapSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">heapSort</span><span class="params">($arr)</span> </span>&#123;</div><div class="line">      <span class="comment">#初始化大顶堆</span></div><div class="line">      initHeap($arr, <span class="number">0</span>, count($arr) - <span class="number">1</span>);</div><div class="line"></div><div class="line">      <span class="comment">#开始交换首尾节点,并每次减少一个末尾节点再调整堆,直到剩下一个元素</span></div><div class="line">      <span class="keyword">for</span>($end = count($arr) - <span class="number">1</span>; $end &gt; <span class="number">0</span>; $end--) &#123;</div><div class="line">          $temp = $arr[<span class="number">0</span>];</div><div class="line">          $arr[<span class="number">0</span>] = $arr[$end];</div><div class="line">          $arr[$end] = $temp;</div><div class="line">          ajustNodes($arr, <span class="number">0</span>, $end - <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 初始化大顶堆</div><div class="line">   * 初始化最大堆,从最后一个非叶子节点开始,最后一个非叶子节点编号为 数组长度/2 向下取整</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initHeap</span><span class="params">(&amp;$arr)</span> </span>&#123;</div><div class="line">      $len = count($arr);</div><div class="line">      <span class="keyword">for</span>($start = floor($len / <span class="number">2</span>) - <span class="number">1</span>; $start &gt;= <span class="number">0</span>; $start--) &#123;</div><div class="line">          ajustNodes($arr, $start, $len - <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 调整节点</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr   待调整数组</div><div class="line">   * <span class="doctag">@param</span>  [type] $start 调整的父节点坐标</div><div class="line">   * <span class="doctag">@param</span>  [type] $end   待调整数组结束节点坐标</div><div class="line">   * <span class="doctag">@return</span> [type]        [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ajustNodes</span><span class="params">(&amp;$arr, $start, $end)</span> </span>&#123;</div><div class="line">      $maxInx = $start;</div><div class="line">      $len = $end + <span class="number">1</span>;    <span class="comment">#待调整部分长度</span></div><div class="line">      $leftChildInx = ($start + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;    <span class="comment">#左孩子坐标</span></div><div class="line">      $rightChildInx = ($start + <span class="number">1</span>) * <span class="number">2</span>;    <span class="comment">#右孩子坐标</span></div><div class="line"></div><div class="line">      <span class="comment">#如果待调整部分有左孩子</span></div><div class="line">      <span class="keyword">if</span>($leftChildInx + <span class="number">1</span> &lt;= $len) &#123;</div><div class="line">          <span class="comment">#获取最小节点坐标</span></div><div class="line">          <span class="keyword">if</span>($arr[$maxInx] &lt; $arr[$leftChildInx]) &#123;</div><div class="line">              $maxInx = $leftChildInx;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">#如果待调整部分有右子节点</span></div><div class="line">          <span class="keyword">if</span>($rightChildInx + <span class="number">1</span> &lt;= $len) &#123;</div><div class="line">              <span class="keyword">if</span>($arr[$maxInx] &lt; $arr[$rightChildInx]) &#123;</div><div class="line">                  $maxInx = $rightChildInx;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">#交换父节点和最大节点</span></div><div class="line">      <span class="keyword">if</span>($start != $maxInx) &#123;</div><div class="line">          $temp = $arr[$start];</div><div class="line">          $arr[$start] = $arr[$maxInx];</div><div class="line">          $arr[$maxInx] = $temp;</div><div class="line"></div><div class="line">          <span class="comment">#如果交换后的子节点还有子节点,继续调整</span></div><div class="line">          <span class="keyword">if</span>(($maxInx + <span class="number">1</span>) * <span class="number">2</span> &lt;= $len) &#123;</div><div class="line">              ajustNodes($arr, $maxInx, $end);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(heapSort($arr));</div></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>先将数组根据其值的大小放入到桶的相应位置，然后在按照顺序将元素从桶中取出。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [tongSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $max [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tongSort</span><span class="params">($arr, $max)</span></span>&#123;</div><div class="line">    $len = count($arr);</div><div class="line"></div><div class="line">    <span class="comment">//填充木桶</span></div><div class="line">		$tong = <span class="keyword">array</span>();</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$max;$i++)&#123;</div><div class="line">      $tong[$i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">		<span class="comment">//开始标示木桶</span></div><div class="line">		<span class="keyword">for</span>($i = <span class="number">0</span>; $i&lt;$len; $i++)&#123;</div><div class="line">			$tong[$arr[$i]]++;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		$res = <span class="keyword">array</span>();</div><div class="line">		<span class="comment">//开始从木桶中拿出数据</span></div><div class="line">		<span class="keyword">for</span>($i = <span class="number">0</span>; $i&lt; $max ; $i++)&#123;</div><div class="line">        <span class="keyword">if</span>($tong[$i] &gt; <span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">for</span>($j = <span class="number">1</span>; $j &lt;= $tong[$i]; $j++)&#123; <span class="comment">//这一行主要用来控制输出多个数</span></div><div class="line">            $res[] = $i;</div><div class="line">    			&#125;</div><div class="line">        &#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> $res;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">  var_dump(tongSort($arr, <span class="number">1000</span>));</div></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</p>
<p>然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [countingSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type]  $arr       [description]</div><div class="line">   * <span class="doctag">@param</span>  boolean $digit_num [description]</div><div class="line">   * <span class="doctag">@return</span> [type]             [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countingSort</span><span class="params">($arr, $digit_num = false)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> ($digit_num !== <span class="keyword">false</span>) &#123; <span class="comment">#如果参数$digit_num不为空，则根据元素的第$digit_num位数进行排序</span></div><div class="line">       <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($arr); $i++) &#123;</div><div class="line">         $arr_temp[$i] = get_specific_digit($arr[$i], $digit_num);</div><div class="line">       &#125;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       $arr_temp = $arr;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     $max = max($arr);</div><div class="line">     $time_arr = <span class="keyword">array</span>(); <span class="comment">#储存元素出现次数的数组</span></div><div class="line"></div><div class="line">     <span class="comment">#初始化出现次数数组</span></div><div class="line">     <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt;= $max; $i++) &#123;</div><div class="line">       $time_arr[$i] = <span class="number">0</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">#统计每个元素出现次数</span></div><div class="line">     <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($arr_temp); $i++) &#123;</div><div class="line">       $time_arr[$arr_temp[$i]]++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">#统计每个元素比其小或相等的元素出现次数</span></div><div class="line">     <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($time_arr) - <span class="number">1</span>; $i++) &#123;</div><div class="line">       $time_arr[$i + <span class="number">1</span>] += $time_arr[$i];</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">#利用出现次数对数组进行排序</span></div><div class="line">     <span class="keyword">for</span>($i = count($arr) - <span class="number">1</span>; $i &gt;= <span class="number">0</span>; $i--) &#123;</div><div class="line">       $sorted_arr[$time_arr[$arr_temp[$i]] - <span class="number">1</span>] = $arr[$i];</div><div class="line">       $time_arr[$arr_temp[$i]]--;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     $arr = $sorted_arr;</div><div class="line">     ksort($arr);  <span class="comment">#忽略这次对key排序的效率损耗</span></div><div class="line">     <span class="keyword">return</span> $arr;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 计算某个数的位数</div><div class="line">    * <span class="doctag">@param</span>  [type] $number [description]</div><div class="line">    * <span class="doctag">@return</span> [type]         [description]</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">get_digit</span><span class="params">($number)</span> </span>&#123;</div><div class="line">     $i = <span class="number">1</span>;</div><div class="line">     <span class="keyword">while</span> ($number &gt;= pow(<span class="number">10</span>, $i)) &#123;</div><div class="line">      $i++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> $i;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 获取某个数字的从个位算起的第i位数</div><div class="line">    * <span class="doctag">@param</span>  [type] $num [description]</div><div class="line">    * <span class="doctag">@param</span>  [type] $i   [description]</div><div class="line">    * <span class="doctag">@return</span> [type]      [description]</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">get_specific_digit</span><span class="params">($num, $i)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> ($num &lt; pow(<span class="number">10</span>, $i - <span class="number">1</span>)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> floor($num % pow(<span class="number">10</span>, $i) / pow(<span class="number">10</span>, $i - <span class="number">1</span>));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 基数排序,以计数排序作为子排序过程</div><div class="line">    * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">    * <span class="doctag">@return</span> [type]      [description]</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">radix_sort</span><span class="params">(&amp;$arr)</span> </span>&#123;</div><div class="line">     <span class="comment">#先求出数组中最大的位数</span></div><div class="line">     $max = max($arr);</div><div class="line">     $max_digit = get_digit($max);</div><div class="line"></div><div class="line">     <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max_digit; $i++) &#123;</div><div class="line">       counting_sort($arr, $i);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   var_dump(countingSort($arr));</div></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul>
<li><p>思路分析：</p>
<blockquote>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [shellSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">shellSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    $length=count($arr);</div><div class="line">    $h=<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>($h&lt;$length/<span class="number">3</span>)</div><div class="line">    &#123;</div><div class="line">      $h=<span class="number">3</span>*$h+<span class="number">1</span>;<span class="comment">//设置间隔</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>($h&gt;=<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>($i=$h; $i&lt;$length; $i++)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">for</span>($j=$i; $j&gt;=$h &amp;&amp; $arr[$j]&lt;$arr[$j-$h]; $j-=$h)</div><div class="line">        &#123;</div><div class="line">           $temp =$arr[$j-$h];</div><div class="line">           $arr[$j-$h]=$arr[$j];</div><div class="line">           $arr[$j]=$temp;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      $h=($h<span class="number">-1</span>)/<span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line">  var_dump(shellSort($arr));</div></pre></td></tr></table></figure>
<h2 id="简单比较"><a href="#简单比较" class="headerlink" title="简单比较"></a>简单比较</h2><p><img src="http://n.sinaimg.cn/games/3ece443e/20161107/sort_img.png" alt="sort"></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;桶排序&lt;/li&gt;
&lt;li&gt;基数排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
      <category term="算法" scheme="https://weizhimiao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux中常用的shell脚本（二）</title>
    <link href="https://weizhimiao.github.io/2016/11/01/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84shell%E8%84%9A%E6%9C%AC%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://weizhimiao.github.io/2016/11/01/Linux中常用的shell脚本（二）/</id>
    <published>2016-11-01T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://n.sinaimg.cn/games/3ece443e/20161030/bash.png" alt="Linux中常用的shell脚本"></p>
<a id="more"></a>
<p>1、进程运行前后台切换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ctrl+z		# 将进程转入后台运行</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fg				# 将进程转到前台</div></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ ping www.baidu.com</div><div class="line">PING www.a.shifen.com (119.75.217.109): 56 data bytes</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=0 ttl=57 time=6.829 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=1 ttl=57 time=32.417 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=2 ttl=57 time=5.999 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=3 ttl=57 time=21.105 ms</div><div class="line">^Z</div><div class="line">[1]  + 1879 suspended  ping www.baidu.com</div><div class="line">--------------------------------------------------------------</div><div class="line">$ fg                </div><div class="line">[1]  + 1879 continued  ping www.baidu.com</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=4 ttl=57 time=27.063 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=5 ttl=57 time=5.939 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=6 ttl=57 time=6.633 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=7 ttl=57 time=7.462 ms</div><div class="line">^C</div><div class="line">--- www.a.shifen.com ping statistics ---</div><div class="line">8 packets transmitted, 8 packets received, 0.0% packet loss</div><div class="line">round-trip min/avg/max/stddev = 5.939/14.181/32.417/10.232 ms</div></pre></td></tr></table></figure></p>
<p>2、截取前5个字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ var=&quot;hello world&quot;</div><div class="line">$ echo $&#123;var:0:5&#125;</div><div class="line">hello</div></pre></td></tr></table></figure></p>
<p>3、一次创建多个目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p data/&#123;test,test1,test2&#125;</div><div class="line">$ tree data</div><div class="line">data</div><div class="line">├── test</div><div class="line">├── test1</div><div class="line">└── test2</div></pre></td></tr></table></figure></p>
<p>4、获得文本的md5 hash<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo -n &quot;testText&quot; | md5sum</div></pre></td></tr></table></figure></p>
<p>5、将tar.gz提取到新目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar -zxvf package.tar.gz -C /path/to/new</div></pre></td></tr></table></figure></p>
<p>6、通过curl获取HTTP头信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ curl -I http://www.baidu.com</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: bfe/1.0.8.18</div><div class="line">Date: Tue, 01 Nov 2016 15:00:30 GMT</div><div class="line">Content-Type: text/html</div><div class="line">Content-Length: 277</div><div class="line">Last-Modified: Mon, 13 Jun 2016 02:50:08 GMT</div><div class="line">Connection: Keep-Alive</div><div class="line">ETag: &quot;575e1f60-115&quot;</div><div class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</div><div class="line">Pragma: no-cache</div><div class="line">Accept-Ranges: bytes</div></pre></td></tr></table></figure></p>
<p>7、快速备份一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ll</div><div class="line">-rw-r--r--   1 zhimiao  staff   200B  2 29  2016 test.txt</div><div class="line"></div><div class="line">$ cp test.txt&#123;,.bak&#125;</div><div class="line"></div><div class="line">$ ll</div><div class="line">-rw-r--r--   1 zhimiao  staff   200B  2 29  2016 test.txt</div><div class="line">-rw-r--r--   1 zhimiao  staff   200B 11  1 23:02 test.txt.bak</div></pre></td></tr></table></figure></p>
<p>8、利用cat快速输入多行文字（Ctrl+d 退出）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ cat &gt; test2.txt</div><div class="line">weizhadf</div><div class="line">asdfads</div><div class="line">asdf</div><div class="line">adsf</div><div class="line">asdf</div><div class="line">adf</div><div class="line">(Ctrl+d)</div><div class="line"></div><div class="line">$ cat test2.txt</div><div class="line">weizhadf</div><div class="line">asdfads</div><div class="line">asdf</div><div class="line">adsf</div><div class="line">asdf</div><div class="line">adf</div></pre></td></tr></table></figure></p>
<p>9、重复运行命令，并显示其输出（默认是2秒运行一次）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">watch ps -ef</div><div class="line">Every 2.0s: ps -ef                                                                     Tue Nov  1 23:10:06 2016</div><div class="line"></div><div class="line">  UID   PID  PPID   C STIME   TTY           TIME CMD</div><div class="line">    0     1     0   0 10:28    ??         0:05.23 /sbin/launchd</div><div class="line">    0    47     1   0 10:28    ??         0:01.21 /usr/libexec/UserEventAgent (System)</div><div class="line">    0    48     1   0 10:28    ??         0:00.42 /usr/sbin/syslogd</div><div class="line">    0    50     1   0 10:28    ??         0:00.14 /System/Library/PrivateFrameworks/Uninstall.framework/Resourc</div><div class="line">es/uninstalld</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>10、递归查找目录中文件中的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ grep -r &quot;some_text&quot; /path/</div></pre></td></tr></table></figure></p>
<p>11、将所有的文件名中含有”*.txt”的文件，移入指定目录中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find -iname &quot;*.txt*&quot; -exec mv -v &#123;&#125; /home/user \;</div></pre></td></tr></table></figure></p>
<p>12、拆分大体积tar.gz文件（拆成每个100MB），然后合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ split -b 100m /path/to/large/archive /path/to/output/files</div><div class="line">$ cat files* &gt; archive</div></pre></td></tr></table></figure></p>
<p>13、Shell(Bash)中如何判断是否存在某个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 判断foo命令是否存在</div><div class="line">$ command -v foo &gt;/dev/null 2&gt;&amp;1 || &#123; echo &gt;&amp;2 &quot;I require foo but it&apos;s not installed.  Aborting.&quot;; exit 1; &#125;</div><div class="line">$ type foo &gt;/dev/null 2&gt;&amp;1 || &#123; echo &gt;&amp;2 &quot;I require foo but it&apos;s not installed.  Aborting.&quot;; exit 1; &#125;</div><div class="line">$ hash foo 2&gt;/dev/null || &#123; echo &gt;&amp;2 &quot;I require foo but it&apos;s not installed.  Aborting.&quot;; exit 1; &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161030/bash.png&quot; alt=&quot;Linux中常用的shell脚本&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://weizhimiao.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux中常用的shell脚本</title>
    <link href="https://weizhimiao.github.io/2016/10/30/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84shell%E8%84%9A%E6%9C%AC/"/>
    <id>https://weizhimiao.github.io/2016/10/30/Linux中常用的shell脚本/</id>
    <published>2016-10-30T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://n.sinaimg.cn/games/3ece443e/20161030/bash.png" alt="Linux中常用的shell脚本"></p>
<a id="more"></a>
<p>1、对于进程来说，查看其运行时的环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/$PID/environ</div></pre></td></tr></table></figure></p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#首先需要我们运行一个程序</div><div class="line"># pgrep inotifywait</div><div class="line">8977</div><div class="line"># cat /proc/8977/environ</div><div class="line">HOSTNAME=localhost.localdomainSELINUX_ROLE_REQUESTED=TERM=xterm-256colorSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=192.168.1.100 63684 22SELINUX_USE_CURRENT_RANGE=SSH_TTY=/dev/pts/0USER=rootLS_COLORS=rs=0:di=38;... %sG_BROKEN_FILENAMES=1_=/usr/local/bin/inotifywaitOLDPWD=/data</div><div class="line">#一般返回的环境变量会有很多，我们采用换行方式查看会更直观</div><div class="line"></div><div class="line"># cat /proc/8977/environ | tr &apos;\0&apos; &apos;\n&apos;</div><div class="line">HOSTNAME=localhost.localdomain</div><div class="line">SELINUX_ROLE_REQUESTED=</div><div class="line">TERM=xterm-256color</div><div class="line">SHELL=/bin/bash</div><div class="line">HISTSIZE=1000</div><div class="line">SSH_CLIENT=192.168.1.100 63684 22</div><div class="line">SELINUX_USE_CURRENT_RANGE=</div><div class="line">SSH_TTY=/dev/pts/0</div><div class="line">USER=root</div><div class="line">....</div></pre></td></tr></table></figure></p>
<p>2、获得字符串长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># var=wahaha</div><div class="line"># echo $&#123;var&#125;</div><div class="line">wahaha</div><div class="line"># echo $&#123;#var&#125;</div><div class="line">6</div></pre></td></tr></table></figure></p>
<p>3、识别当前使用的是哪种shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo $SHELL</div><div class="line">/bin/bash</div></pre></td></tr></table></figure></p>
<p>4、shell脚本检查是执行当前脚本的是否为root用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># cat check_root.sh</div><div class="line">#!/bin/bash</div><div class="line">if [ $UID -ne 0 ]; then</div><div class="line">	echo &quot;Non root user. Please run as root.&quot;</div><div class="line">else</div><div class="line">	echo Root User</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>5、修改bash提示字符串（username@hastname:~$）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#利用PS1环境变量来定制</div><div class="line"># cat ~/.bashrc | grep PS1</div><div class="line">PS1=&apos;$&#123;debian_chroot:+$($debian_chroot)&#125;\u@\h:\w\$ &apos;</div><div class="line"># \u 用户名</div><div class="line"># \h 主机名</div><div class="line"># \w 当前工作目录</div></pre></td></tr></table></figure></p>
<p>6、如何判断一个命令是否执行成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">当一个命令发生错误并退回时，他会返回一个非0的退出状态；</div><div class="line">而当命令成功完成后，它会返回数字0.</div><div class="line">退出状态可以从特殊变量 $? 中获得（在命令执行之后立刻运行 $? ,就可以打印出退出状态）</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">CMD=&quot;commod&quot;  #commod代表需要检测退出状态的命令</div><div class="line">$CMD</div><div class="line">if [ $? -eq 0 ];</div><div class="line">then</div><div class="line">  echo &quot;$CMD executed succ&quot;</div><div class="line">else</div><div class="line">  echo &quot;$CMD excuted unsucc&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>7、shell中数组的定义与操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#定义1</div><div class="line">array_var=(1 2 3 4 5)</div><div class="line">#定义2</div><div class="line">array_var[0]=&quot;test&quot;</div><div class="line">array_var[1]=&quot;test1&quot;</div><div class="line">array_var[2]=&quot;test2&quot;</div><div class="line">array_var[3]=&quot;test3&quot;</div><div class="line">#打印特定索引数组元素</div><div class="line">echo $&#123;array_var[0]&#125;</div><div class="line">#以清单形式打印出数组中的所有值</div><div class="line">echo $&#123;array_var[*]&#125;</div><div class="line">test test1 test2 test3</div><div class="line">#也可以</div><div class="line">echo $&#123;array_var[@]&#125;</div><div class="line">test test1 test2 test3</div><div class="line">#输出数组元素个数</div><div class="line">echo $&#123;#array_var[*]&#125;</div><div class="line">4</div></pre></td></tr></table></figure></p>
<p>8、按照指定格式打印系统当前时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># date &quot;+%Y%m%d&quot;</div><div class="line">20161029</div><div class="line"># %a  星期  例，Sat</div><div class="line"># %A  星期  例，Saturday</div><div class="line"># %b  月    例，Nov</div><div class="line"># %B  月    例，November</div><div class="line"># %d  日   例，31</div><div class="line"># %D  固定格式(mm/dd/yy)  例，10/18/10</div><div class="line"># %y  年   例，16</div><div class="line"># %Y  年   例，2016</div><div class="line"># %I或%H 小时  例，08</div><div class="line"># %M  分钟  例，30</div><div class="line"># %S  秒   例，10</div><div class="line"># %N  纳秒  例，694394444</div></pre></td></tr></table></figure></p>
<p>9、shell函数参数传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">func()&#123;</div><div class="line">  echo $1,$2  #访问参数1和参数2</div><div class="line">  echo &quot;$@&quot;   #以列表方式一次性打印所有参数</div><div class="line">  echo &quot;$*&quot;   #类似于$@,但是参数被作为单个实体</div><div class="line">  return 0;   #返回值</div><div class="line">&#125;</div><div class="line"></div><div class="line"># $1,  第一个参数</div><div class="line"># $2,  第二个参数</div><div class="line"># $n,  第n个参数</div><div class="line"># &quot;$@&quot;,   被扩展成&quot;$1&quot; &quot;$2&quot; &quot;$3&quot;等</div><div class="line"># &quot;$*&quot;,   被扩展成&quot;$1c$2c$3&quot; ，其中c是IFS的第一个字符</div><div class="line"># &quot;$@&quot;要比&quot;$*&quot;用的多。由于&quot;$*&quot;将所有参数当做单个字符串，因此它很少被使用</div></pre></td></tr></table></figure></p>
<p>10、利用子shell生成独立进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># cat sub_shell.sh</div><div class="line">#!/bin/bash</div><div class="line">pwd;</div><div class="line">(cd /bin; pwd);</div><div class="line">pwd;</div><div class="line"># ./sub_shell.sh</div><div class="line">/root/shell</div><div class="line">/bin</div><div class="line">/root/shell</div><div class="line"></div><div class="line"># 我们可以发现（）中的子shell对于当前shell没有影响，它所有的改变仅限于（）内部</div></pre></td></tr></table></figure></p>
<p>11、运行命令直至成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">repeat()&#123;</div><div class="line">  while true</div><div class="line">  do</div><div class="line">    $@  &amp;&amp; return</div><div class="line">  done</div><div class="line">&#125;</div><div class="line"># 原理：该函数通过$@接收传参。如果命令执行成功，则返回并退出循环，否则一直循环</div><div class="line"></div><div class="line"># Tips：将该函数加入的shell的rc文件中，方便我们使用</div><div class="line"></div><div class="line"># 示例：使用repeat（）从网上下载一个文件，直至成功</div><div class="line">repeat wget -c http://xxxx.com/example.tar.gz</div></pre></td></tr></table></figure></p>
<p>12、删除多余的空行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># cat -s file &gt;&gt; newfile</div></pre></td></tr></table></figure></p>
<p>13、文件查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># find /home -name &quot;*.txt&quot;</div><div class="line"># find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>14、排序、去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 排序  sort</div><div class="line"># 去重  uniq</div><div class="line">sort file.txt | uniq</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># cat check_sorted.sh</div><div class="line">#!/bin/bash</div><div class="line"># 功能：检查文件是否已经排序过</div><div class="line">sort -C filename;</div><div class="line">if [ $? -eq 0 ]</div><div class="line">then</div><div class="line">  echo Sorted</div><div class="line">else</div><div class="line">  echo Unsorted</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>15、交互输出自动化实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># 文件名：enter.sh</div><div class="line">read -p &quot;Enter number:&quot; no ;</div><div class="line">read -p &quot;Enter name&quot; name ;</div><div class="line">echo You have entered $no $name;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#利用echo -e来生成输入序列</div><div class="line">echo -e &quot;1\nhello\n&quot; | ./enter.sh</div></pre></td></tr></table></figure>
<p>16、利用并行进程加速命令执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">PIDARRAY=()</div><div class="line">for file in File1.ios File2.ios</div><div class="line">do</div><div class="line">  md5sum $file &amp;</div><div class="line">  PIDARRAY+=(&quot;$!&quot;)</div><div class="line">done</div><div class="line">wait $&#123;PIDARRAY[@]&#125;</div><div class="line"># 原理：利用bash的操作符&amp;，它使得shell将命令置于后台并继续执行脚本。使用 $! 来获得进程的PID（在bash中 $! 保存最近一个后台进程的PID）。将这些进程PID放入PIDARRAY数组中。使用wait命令等待这些进程执行完成。</div></pre></td></tr></table></figure></p>
<p>17、查找并删除内容重复的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#创建测试文件testfile，testfile1，testfile2，newfile ;其中testfile1和testfile2都是testfile的副本</div><div class="line"></div><div class="line"># echo &quot;hello&quot; &gt;&gt; testfile</div><div class="line"># cp testfile testfile1</div><div class="line"># cp testfile testfile2</div><div class="line"># echo hello world &gt;&gt; newfile</div><div class="line"></div><div class="line"># cat remove_duplicates.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ls -lS --time-style=long-iso | awk &apos;BEGIN &#123;</div><div class="line">	getline; getline;</div><div class="line">	name1=$8; size=$5;</div><div class="line">&#125;&#123;</div><div class="line">	name2=$8</div><div class="line">	if(size==$5)&#123;</div><div class="line">		&quot;md5sum &quot;name1 | getline; csum1=$1;</div><div class="line">		&quot;md5sum &quot;name2 | getline; csum2=$1;</div><div class="line">		if(csum1==csum2)&#123;</div><div class="line">			print name1;</div><div class="line">			print name2;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	size=$5;</div><div class="line">	name1=name2;</div><div class="line">&#125;&apos; | sort -u &gt; duplicate_files</div><div class="line"></div><div class="line">cat duplicate_files | xargs -I &#123;&#125; md5sum &#123;&#125; | sort | uniq -w 32 | awk &apos;&#123;print &quot;^&quot;$2&quot;$&quot; &#125;&apos; | sort -u &gt; duplicate_sample</div><div class="line"></div><div class="line">echo Removing...</div><div class="line">comm duplicate_files duplicate_sample -2 -3 | tee /dev/stderr | xargs rm</div><div class="line">rm -f duplicate_files duplicate_sample</div><div class="line">echo Removed duplicates files successfully</div><div class="line"></div><div class="line"># 执行脚本</div><div class="line"># ./remove_duplicates.sh</div><div class="line">Removing...</div><div class="line">testfile</div><div class="line">testfile1</div><div class="line">Removed duplicates files successfully</div><div class="line"></div><div class="line"># 如上testfile、testfile1、testfile2这三个相同内容的文件，只保留了testfile2.</div><div class="line"></div><div class="line"># 脚本原理说明：</div><div class="line"># ls -lS 将当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息</div><div class="line"># awk命令的执行步骤：awk首先会执行BEGIN&#123;&#125;语句块，处理完&#123;&#125;中所有的命令后，在执行END&#123;&#125;语句块</div><div class="line"># 在awk中，外部的命令的输出可以用这样的方式来读取，&quot;cmd&quot; | getline ，随后我们就可以用 $0 来获取命令的输出 ，在$1,$2,$3...$n 获取命令输出中的每一列</div><div class="line"># BEGIN&#123;&#125;语句块中有两个getline;是因为 ls -lS --time-style=long-iso 命令的输出的第一行是文件的数量，所以我们直接跳过，来获取下一行数据</div><div class="line"># comm 通常只接受排过序的文件。所以在之前需要使用 sort -u 进行排序</div><div class="line"># tee 命令在这有一个妙用：它将文件名在传递给rm命令的同时，也起到了print的效果。tee将来自stdin的行写入文件，同事将其发送到stdout</div></pre></td></tr></table></figure></p>
<p>18、解析文本中的电子邮件地址和URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># 正则表达式</div><div class="line">#   mail：[a-zA-Z0-9.]+@[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,4&#125;</div><div class="line">#   URL： (http|https)://[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,3&#125;</div><div class="line"></div><div class="line"># wget www.sina.com.cn/index.html</div><div class="line"></div><div class="line"># 解析index.html中的email</div><div class="line"># egrep -o &quot;[a-zA-Z0-9.]+@[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,4&#125;&quot; index.html</div><div class="line">jubao@vip.sina.com</div><div class="line">jubao@vip.sina.com</div><div class="line"></div><div class="line"># 解析index.html中的URL</div><div class="line"># egrep -o &quot;(http|https)://[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,3&#125;&quot; index.html</div><div class="line">http://www.sina.com.cn</div><div class="line">http://www.sina.com.cn</div><div class="line">http://auto.sina.com.cn</div><div class="line">http://www.sina.com.cn</div><div class="line">...</div><div class="line">http://hq.sinajs.cn</div><div class="line">http://rm.sina.com.cn</div><div class="line">http://d4.sina.com.cn</div><div class="line">http://d1.sina.com.cn</div><div class="line">http://i1.sinaimg.cn</div><div class="line">http://news.sina.com.cn</div><div class="line">http://login.sina.com.cn</div><div class="line">http://login.sina.com.cn</div></pre></td></tr></table></figure></p>
<p>19、以纯文本形式下载网页<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lynx:是一款基于命令行的web浏览器。我们可以利用它获取纯文本形式的网页</div><div class="line"></div><div class="line">命令：</div><div class="line"># lynx -dump http://www.sina.com.cn</div><div class="line">-dump 选项表示将网页内容以ASCII编码形式打印</div><div class="line"></div><div class="line">另，lynx会将页面中所有的超链接（&lt;a href=&quot;link&quot;&gt;）作为文本的页脚，单独放置在标题为 References 的文本区域。如果我们需要匹配除某个页面中所有的超链接也可以使用该方法，也省的我们用正则匹配</div></pre></td></tr></table></figure></p>
<p>20、列出网络上所有的活动主机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># cat ping.sh</div><div class="line">#!/bin/bash</div><div class="line">for ip in 192.168.1.&#123;1..255&#125;;</div><div class="line">do</div><div class="line">	ping $ip -c 2 &amp;&gt; /dev/null;</div><div class="line"></div><div class="line">	if [ $? -eq 0 ]</div><div class="line">	then</div><div class="line">		echo $ip is alive</div><div class="line">	fi</div><div class="line">done</div><div class="line"></div><div class="line"># 并行ping</div><div class="line"># cat ping_1.sh</div><div class="line">#!/bin/bash</div><div class="line">for ip in 192.168.1.&#123;1..255&#125;;</div><div class="line">do</div><div class="line">	(</div><div class="line">	ping $ip -c 2 &amp;&gt; /dev/null;</div><div class="line"></div><div class="line">	if [ $? -eq 0 ]</div><div class="line">	then</div><div class="line">		echo $ip is alive</div><div class="line">	fi</div><div class="line">	)&amp;</div><div class="line">done</div><div class="line">wait</div><div class="line"></div><div class="line"># 将wait放在脚本最后，它就会一直等到所有的子脚本进程全部结束</div></pre></td></tr></table></figure></p>
<p>21、网络上利用套接字进行快速文件复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 设置侦听套接字</div><div class="line">nc -l 1234</div><div class="line"></div><div class="line"># 在另一终端或主机中连接到该套接字</div><div class="line">nc 127.0.0.1 1234</div><div class="line">message_test</div><div class="line"></div><div class="line"># 连接到套接字后就可以在终端中输入信息回车就会发送</div><div class="line"></div><div class="line"># 文件复制</div><div class="line">在接收端执行以下命令：</div><div class="line">nc -l 1234 &gt; destination_filename</div><div class="line">在发送端执行下列命令：</div><div class="line">nc 127.0.0.1 1234 &lt; source_filename</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161030/bash.png&quot; alt=&quot;Linux中常用的shell脚本&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://weizhimiao.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux中通过inotify-tools实现监控文件变化</title>
    <link href="https://weizhimiao.github.io/2016/10/29/Linux%E4%B8%AD%E9%80%9A%E8%BF%87inotify-tools%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96/"/>
    <id>https://weizhimiao.github.io/2016/10/29/Linux中通过inotify-tools实现监控文件变化/</id>
    <published>2016-10-29T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>inotify-tools 是一个用C语言库，一个为Linux提供简单inotify接口的命令行程序。这些程序可以用于监视文件系统事件并执行相应操作。这些程序是用C语言来写的，除了需要Linux内核的inotify支持外，没有其他的依赖。inotify-tools 3.14是目前最新版本，其于2010年3月7日发布。</p>
<p>那么什么inotify又是什么？</p>
<p>inotify，它是Linux在内核 2.6.13 (June 18, 2005)版本中引入的一个新功能，它为用户态监视文件系统的变化提供了强大的支持，允许监控程序打开一个独立文件描述符，并针对事件集监控一个或者多个文件，例如打开、关闭、移动/重命名、删除、创建或者改变属性。</p>
<p>官方站点地址：<a href="http://inotify-tools.sourceforge.net/" target="_blank" rel="external">http://inotify-tools.sourceforge.net/</a><br>Github地址：<a href="https://github.com/rvoicilas/inotify-tools" target="_blank" rel="external">https://github.com/rvoicilas/inotify-tools</a></p>
<a id="more"></a>
<h2 id="inotify安装"><a href="#inotify安装" class="headerlink" title="inotify安装"></a>inotify安装</h2><h3 id="inotify支持检测"><a href="#inotify支持检测" class="headerlink" title="inotify支持检测"></a>inotify支持检测</h3><p>只有在内核 2.6.13 (June 18, 2005)以上的Linux版本中才支持inotify-tools。</p>
<p>查看当前系统是否支持inotify， 可用通过 uname -a 查看你的内核版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">uname -a</div><div class="line">Linux localhost.localdomain 2.6.32-279.el6.i686 #1 SMP Fri Jun 22 10:59:55 UTC 2012 i686 i686 i386 GNU/Linux</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /proc/version</div><div class="line">Linux version 2.6.32-279.el6.i686 (mockbuild@c6b9.bsys.dev.centos.org) (gcc version 4.4.6 20120305 (Red Hat 4.4.6-4) (GCC) ) #1 SMP Fri Jun 22 10:59:55 UTC 2012</div></pre></td></tr></table></figure></p>
<p>或者查看<code>/proc/sys/fs/inotify/</code>，如果看到显示 max_queued_events max_user_instances max_user_watches 则说明支持inotify<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls /proc/sys/fs/inotify/</div><div class="line">max_queued_events  max_user_instances  max_user_watches</div></pre></td></tr></table></figure></p>
<h3 id="inotify-tools安装"><a href="#inotify-tools安装" class="headerlink" title="inotify-tools安装"></a>inotify-tools安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#wget --no-check-certificate https://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz</div><div class="line">#tar zxvf inotify-tools-3.14.tar.gz</div><div class="line">#cd inotify-tools-3.14</div><div class="line">#./configure</div><div class="line">#make</div><div class="line">#make install</div></pre></td></tr></table></figure>
<p>注：源码包安装需要编译，需要系统已经安装过C编译器</p>
<p>在系统下执行man inotify 、 man inotifywait、man inotifywatch即可得到相应的帮助信息，如果看到信息 则表示安装完成.</p>
<h2 id="inotify-tools使用"><a href="#inotify-tools使用" class="headerlink" title="inotify-tools使用"></a>inotify-tools使用</h2><h3 id="inotify-的默认内核参数详解"><a href="#inotify-的默认内核参数详解" class="headerlink" title="inotify 的默认内核参数详解"></a>inotify 的默认内核参数详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/proc/sys/fs/inotify/max_queued_events</div><div class="line">    默认值: 16384</div><div class="line">    该文件中的值为调用inotify_init时分配给inotify instance中可排队的event的数目的最大值，超出这个值得事件被丢弃，但会触发IN_Q_OVERFLOW事件</div><div class="line">/proc/sys/fs/inotify/max_user_instances</div><div class="line">    默认值: 128</div><div class="line">    指定了每一个real user ID可创建的inotify instatnces的数量上限</div><div class="line">/proc/sys/fs/inotify/max_user_watches</div><div class="line">    默认值: 8192</div><div class="line">    指定了每个inotify instance相关联的watches的上限，也就是每一个inotify实例可监控的最大目录数。如果监控的文件数目巨大，需要根据实际情况适当增加此值得大小。</div><div class="line"></div><div class="line">注意:</div><div class="line">    max_queued_events 是 Inotify 管理的队列的最大长度，文件系统变化越频繁，这个值就应该越大！如果你在日志中看到Event Queue Overflow，说明max_queued_events太小需要调整参数后再次使用</div></pre></td></tr></table></figure>
<p>优化参数配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo 104857600 &gt; /proc/sys/fs/inotify/max_user_watches</div></pre></td></tr></table></figure></p>
<p>inotify-tools 工具包中包含了两个命令</p>
<ul>
<li>inotifywait</li>
<li>inotifywatch</li>
</ul>
<h3 id="inotifywait"><a href="#inotifywait" class="headerlink" title="inotifywait"></a>inotifywait</h3><blockquote>
<p>inotifywait 仅执行阻塞，等待 inotify 事件，你可以使用它来监控任何一组文件和目录，或监控整个目录树（目录、子目录、子目录的子目录等等），并且可以结合 shell 脚本，更好的使用 inotifywait。</p>
</blockquote>
<p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inotifywait [-hcmrq] [-e &lt;event&gt; ] [-t &lt;seconds&gt; ] [--format &lt;fmt&gt; ] [--timefmt &lt;fmt&gt; ] &lt;file&gt; [ ... ]</div></pre></td></tr></table></figure></p>
<p>选项参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">-h|--help     	显示帮助信息</div><div class="line">@&lt;file&gt;       	排除不需要监视的文件，可以是相对路径，也可以是绝对路径</div><div class="line">--exclude &lt;pattern&gt;</div><div class="line">                正则匹配需要排除的文件，大小写敏感</div><div class="line">--excludei &lt;pattern&gt;</div><div class="line">                正则匹配需要排除的文件，忽略大小写。</div><div class="line">-m|--monitor  	接收到一个事情而不退出，无限期地执行。默认行为是接收到一个事情后立即退出</div><div class="line">-d|--daemon   	跟--monitor一样，除了是在后台运行，需要指定--outfile把事情输出到一个文件。也意味着使用了--syslog</div><div class="line">-r|--recursive	监视一个目录下的所有子目录</div><div class="line">--fromfile &lt;file&gt;</div><div class="line">                从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头</div><div class="line">-o|--outfile &lt;file&gt;</div><div class="line">                输出事件到文件.</div><div class="line">-s|--syslog   	输出错误信息到系统日志</div><div class="line">-q|--quiet    	不输出详细信息，只输出事件</div><div class="line">-qq           	除了致命错误，不会输出任何信息</div><div class="line">--timefmt &lt;fmt&gt;	指定时间格式，用于�format选项中的%T格式</div><div class="line">-c|--csv      	输出csv格式。</div><div class="line">-t|--timeout &lt;seconds&gt;</div><div class="line">                设置超时时间，如果为0，则无限期地执行下去。</div><div class="line">-e|--event &lt;event1&gt; [ -e|--event &lt;event2&gt; ... ]</div><div class="line">                指定监听的时间，如果省略，则侦听所有事件。</div><div class="line">--format &lt;fmt&gt;	指定输出格式</div><div class="line">     %w 表示发生事件的目录</div><div class="line">     %f 表示发生事件的文件</div><div class="line">     %e 表示发生的事件</div><div class="line">     %Xe 事件以“X”分隔</div><div class="line">     %T 使用由--timefmt定义的时间格式</div></pre></td></tr></table></figure></p>
<p>可监听的事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">access		    文件或者目录被读</div><div class="line">modify		    文件或目录被写入</div><div class="line">attrib		    文件或者目录属性被更改</div><div class="line">close_write	  文件或目录关闭，在写模式下打开后</div><div class="line">close_nowrite	文件或目录关闭，在只读模式打开后</div><div class="line">close		      文件或目录关闭，而不管是读/写模式</div><div class="line">open		      文件或目录被打开</div><div class="line">moved_to	    文件或者目录移动到监视目录</div><div class="line">moved_from	  文件或者目录移出监视目录</div><div class="line">move		      文件或目录移出或者移入目录</div><div class="line">create		    文件或目录被创建在监视目录</div><div class="line">delete		    文件或者目录被删除在监视目录</div><div class="line">delete_self	  文件或目录移除，之后不再监听此文件或目录</div><div class="line">unmount		    文件系统取消挂载，之后不再监听此文件系统</div></pre></td></tr></table></figure></p>
<p>示例1、监控<code>/data</code>目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inotifywait -rmq /data</div></pre></td></tr></table></figure></p>
<p>我们在另一个终端中想该目录中写入一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;test&quot; &gt;&gt; /data/newfile</div></pre></td></tr></table></figure></p>
<p>这个时候我们就会在前一个终端中看到如下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># inotifywait -rmq /data</div><div class="line">/data/ CREATE newfile</div><div class="line">/data/ OPEN newfile</div><div class="line">/data/ MODIFY newfile</div><div class="line">/data/ CLOSE_WRITE,CLOSE newfile</div></pre></td></tr></table></figure></p>
<p>如上所示，我们监控的了对于newfile文件的 CREATE、OPEN、MODIFY、CLOSE_WRITE、CLOSE等事件。</p>
<p>示例2、实时监控对<code>/etc/passwd</code> 文件的修改、删除和权限相关时间，并且按照指定格式输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># inotifywait -mrq --timefmt &apos;%d/%m/%y %H:%M&apos; --format  &apos;%T %w%f %e&apos; --event modify,delete,attrib  /etc/passwd</div></pre></td></tr></table></figure></p>
<p>这是我们在另一终端创建一个新用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># useradd testuser</div></pre></td></tr></table></figure></p>
<p>这时在前一个终端中就会监控到一个ATTRIB 事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># inotifywait -mrq --timefmt &apos;%d/%m/%y %H:%M&apos; --format  &apos;%T %w%f %e&apos; --event modify,delete,attrib  /etc/passwd</div><div class="line">29/10/16 16:59 /etc/passwd ATTRIB</div></pre></td></tr></table></figure></p>
<p>示例3、实现对 /data/web 目录进行监控，监控文件删除，修改，创建和权限相关事件，并且要求将监控信息写入/var/log/web_watch.log。要求日志条目要清晰明了，能突显文件路径、事件名和时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># cat web_watch.sh</div><div class="line">#!/bin/bash</div><div class="line">inotifywait -mrq --timefmt &apos;%y/%m/%d %H:%M&apos; --format  &apos;%T %w%f %e&apos; --event delete,modify,create,attrib  /data/web | while read  date time file event</div><div class="line">  do</div><div class="line">      case $event in</div><div class="line">          MODIFY|CREATE|MOVE|MODIFY,ISDIR|CREATE,ISDIR|MODIFY,ISDIR)</div><div class="line">                  echo $event&apos;-&apos;$file&apos;-&apos;$date&apos;-&apos;$time &gt;&gt; /var/log/web_watch.log</div><div class="line">              ;;</div><div class="line"></div><div class="line">          MOVED_FROM|MOVED_FROM,ISDIR|DELETE|DELETE,ISDIR)</div><div class="line">                  echo $event&apos;-&apos;$file&apos;-&apos;$date&apos;-&apos;$time /var/log/web_watch.log</div><div class="line">              ;;</div><div class="line">      esac</div><div class="line">  done</div></pre></td></tr></table></figure>
<p>运行脚本后，在另一个终端操作后，查看<code>/var/log/web_watch.log</code>日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cat /var/log/web_watch.log</div><div class="line">CREATE-/data/web/a-14/06/27-16:21</div><div class="line">CREATE-/data/web/aa-14/06/27-16:21</div><div class="line">CREATE-/data/web/aaaa-14/06/27-16:24</div><div class="line">CREATE-/data/web/aaaaa-14/06/27-16:24</div></pre></td></tr></table></figure></p>
<p>更多的使用方式，请查看 inotifywatch man page</p>
<h3 id="inotifywatch"><a href="#inotifywatch" class="headerlink" title="inotifywatch"></a>inotifywatch</h3><blockquote>
<p>inotifywatch 用来收集关于被监视的文件系统的统计数据，包括每个 inotify 事件发生多少次。</p>
</blockquote>
<p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inotifywatch  [-hvzrqf]  [-e  &lt;event&gt;  ] [-t &lt;seconds&gt; ] [-a &lt;event&gt; ] [-d &lt;event&gt; ] &lt;file&gt; [ ... ]</div></pre></td></tr></table></figure></p>
<p>选项参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-h|--help    	            显示帮助信息</div><div class="line">-v|--verbose 	            详细信息</div><div class="line">@&lt;file&gt;       	          排除不需要监视的文件，可以是相对路径，也可以是绝对路径</div><div class="line">--fromfile &lt;file&gt;         从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头</div><div class="line">--exclude &lt;pattern&gt;       正则匹配需要排除的文件，大小写敏感</div><div class="line">--excludei &lt;pattern&gt;      正则匹配需要排除的文件，忽略大小写。</div><div class="line">-z|--zero                 输出表格的行和列，即使元素为空</div><div class="line">-r|--recursive	          监视一个目录下的所有子目录</div><div class="line">-t|--timeout &lt;seconds&gt;</div><div class="line">                          设置超时时间，如果为0，则无限期地执行下去。</div><div class="line">-e|--event &lt;event1&gt; [ -e|--event &lt;event2&gt; ... ]</div><div class="line">                          指定监听的时间，如果省略，则侦听所有事件。</div><div class="line">-a|--ascending &lt;event&gt;    以指定事件升序排列</div><div class="line">-d|--descending &lt;event&gt;   以指定事件降序排列</div></pre></td></tr></table></figure></p>
<p>示例1、统计/data目录所在文件系统发生的事件次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inotifywatch -v -e create,modify,delete -t 30 -r /data</div></pre></td></tr></table></figure></p>
<p>然后在另一终端中进行一些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># echo &quot;test&quot; &gt;&gt; /data/newfile1</div><div class="line">...</div><div class="line"># rm /data/newfile</div><div class="line">rm：是否删除普通文件 &quot;/data/newfile&quot;？y</div><div class="line"># rm /data/newfile1</div><div class="line">rm：是否删除普通文件 &quot;/data/newfile1&quot;？y</div></pre></td></tr></table></figure></p>
<p>30秒后，前一个终端会生成如下报告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># inotifywatch -v -e create,modify,delete -t 30 -r /data</div><div class="line">Establishing watches...</div><div class="line">Setting up watch(es) on /data</div><div class="line">OK, /data is now being watched.</div><div class="line">Total of 1 watches.</div><div class="line">Finished establishing watches, now collecting statistics.</div><div class="line">Will listen for events for 30 seconds.</div><div class="line">total  modify  create  delete  filename</div><div class="line">11     8       1       2       /data/</div></pre></td></tr></table></figure></p>
<p>更多的使用方式，请查看 inotifywatch man page</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;inotify-tools 是一个用C语言库，一个为Linux提供简单inotify接口的命令行程序。这些程序可以用于监视文件系统事件并执行相应操作。这些程序是用C语言来写的，除了需要Linux内核的inotify支持外，没有其他的依赖。inotify-tools 3.14是目前最新版本，其于2010年3月7日发布。&lt;/p&gt;
&lt;p&gt;那么什么inotify又是什么？&lt;/p&gt;
&lt;p&gt;inotify，它是Linux在内核 2.6.13 (June 18, 2005)版本中引入的一个新功能，它为用户态监视文件系统的变化提供了强大的支持，允许监控程序打开一个独立文件描述符，并针对事件集监控一个或者多个文件，例如打开、关闭、移动/重命名、删除、创建或者改变属性。&lt;/p&gt;
&lt;p&gt;官方站点地址：&lt;a href=&quot;http://inotify-tools.sourceforge.net/&quot;&gt;http://inotify-tools.sourceforge.net/&lt;/a&gt;&lt;br&gt;Github地址：&lt;a href=&quot;https://github.com/rvoicilas/inotify-tools&quot;&gt;https://github.com/rvoicilas/inotify-tools&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="inotify" scheme="https://weizhimiao.github.io/tags/inotify/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中用instanceof运算符实现对象的安全创建</title>
    <link href="https://weizhimiao.github.io/2016/10/27/Javascript%E4%B8%AD%E7%94%A8instanceof%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%9B%E5%BB%BA/"/>
    <id>https://weizhimiao.github.io/2016/10/27/Javascript中用instanceof运算符实现对象的安全创建/</id>
    <published>2016-10-27T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Book = <span class="function"><span class="keyword">function</span>(<span class="params">title, time, type</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Book)&#123;</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">    <span class="keyword">this</span>.time = time;</div><div class="line">    <span class="keyword">this</span>.type = type;</div><div class="line">  &#125; <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Book(title, time, type);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="什么叫对象的安全创建"><a href="#什么叫对象的安全创建" class="headerlink" title="什么叫对象的安全创建"></a>什么叫对象的安全创建</h2><p>假设我们有以下一个类<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Book = <span class="function"><span class="keyword">function</span>(<span class="params">title, time, type</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.title = title;</div><div class="line">  <span class="keyword">this</span>.time = time;</div><div class="line">  <span class="keyword">this</span>.type = type;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们用下面代码去实例化一个Book<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = Book(<span class="string">'javascipt'</span>, <span class="string">'2010'</span>, <span class="string">'js'</span>);</div></pre></td></tr></table></figure></p>
<p>当我们查看book对象时，会发现book对象 undefined<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(book);  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>为什么会出现这种情况呢？原因就是我们在实例化book对象没有用<code>new</code>关键词。我们再试一下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = <span class="keyword">new</span> Book(<span class="string">'javascipt'</span>, <span class="string">'2010'</span>, <span class="string">'js'</span>);</div></pre></td></tr></table></figure></p>
<p>查看<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(book);</div><div class="line"><span class="comment">//得到 Book &#123;title: "javascipt", time: "2010", type: "js"&#125;</span></div></pre></td></tr></table></figure></p>
<p>那么又没有办法可以在我们没有用 <code>new</code> 关键词还能安全的创建对象，而不会出现 <code>undefined</code> 的情况。即，对象的安全创建。</p>
<h2 id="对象的安全创建的实现"><a href="#对象的安全创建的实现" class="headerlink" title="对象的安全创建的实现"></a>对象的安全创建的实现</h2><p>首先，我们会用到 javascript 中的 instanceof 运算符。</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote>
<p>instanceof 用来检测某个对象是否是某个类的实例。</p>
</blockquote>
<p>示例1：判断 foo 是否是 Foo 类的实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</div><div class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Foo)  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>示例2：instanceof 在继承中关系中的用法(判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Aoo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.prototype = <span class="keyword">new</span> Aoo();    <span class="comment">//JavaScript 原型继承</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</div><div class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Foo) <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Aoo) <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>Tips: instanceof 用来检测某个对象是否是某个类的实例。</p>
<p>所以<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> Aoo)  <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>但是<code>Foo.prototype</code> 继承了 <code>Aoo</code> ,所以<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(Foo.prototype <span class="keyword">instanceof</span> Aoo)  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><strong>希望我们不要弄混~</strong></p>
<p>另，Javascript为我们提供的原生对象 Object，所有的对象都可以说成是Object的子类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(instance instanceif <span class="built_in">Object</span>);  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Book = <span class="function"><span class="keyword">function</span>(<span class="params">title, time, type</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Book)&#123;</div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">    <span class="keyword">this</span>.time = time;</div><div class="line">    <span class="keyword">this</span>.type = type;</div><div class="line">  &#125; <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Book(title, time, type);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = Book(<span class="string">'javascipt'</span>, <span class="string">'2010'</span>, <span class="string">'js'</span>);</div><div class="line"><span class="built_in">console</span>.log(book);</div><div class="line"><span class="comment">//得到：Book &#123;title: "javascipt", time: "2010", type: "js"&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> book1 = <span class="keyword">new</span> Book(<span class="string">'javascipt_1'</span>, <span class="string">'2010'</span>, <span class="string">'js'</span>);</div><div class="line"><span class="built_in">console</span>.log(book1)</div><div class="line"><span class="comment">//得到：Book &#123;title: "javascipt_1", time: "2010", type: "js"&#125;</span></div></pre></td></tr></table></figure>
<p>over~</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Book = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;title, time, type&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Book)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.title = title;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.time = time;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.type = type;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Book(title, time, type);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://weizhimiao.github.io/categories/JavaScript/"/>
    
    
      <category term="instanceof" scheme="https://weizhimiao.github.io/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>PHP根据文件头检测文件类型</title>
    <link href="https://weizhimiao.github.io/2016/10/23/PHP%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B4%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
    <id>https://weizhimiao.github.io/2016/10/23/PHP根据文件头检测文件类型/</id>
    <published>2016-10-23T10:30:00.000Z</published>
    <updated>2016-11-29T02:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>文件签名一般都在文件的头部，如果你用十六进制方式查看文件，你就可以看到文件的一些签名信息。如用uestudio以十六进制方式查看zip格式的文件，其文件内容头部有50 4B 03 04这样的十六进制信息。同理jpg文件状况有FF D8 FF E0 xx xx 4A 46这样的十六进制信息，其实这此十六进制都是表示一些特殊字条。</p>
<a id="more"></a>
<p>php怎么样验证文件类型？先来看一个简单的方法：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkFileType</span><span class="params">($fileName)</span></span>&#123;  </div><div class="line">       $file = fopen($fileName, <span class="string">"rb"</span>);  </div><div class="line">       $bin = fread($file, <span class="number">2</span>); <span class="comment">//只读2字节  </span></div><div class="line">       fclose($file);  </div><div class="line">	<span class="comment">// C为无符号整数，网上搜到的都是c，为有符号整数，这样会产生负数判断不正常</span></div><div class="line">       $strInfo  = @unpack(<span class="string">"C2chars"</span>, $bin);</div><div class="line">       $typeCode = intval($strInfo[<span class="string">'chars1'</span>].$strInfo[<span class="string">'chars2'</span>]);  </div><div class="line">       $fileType = <span class="string">''</span>;  </div><div class="line"></div><div class="line">	<span class="keyword">switch</span>( $typeCode )</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">case</span> <span class="string">'255216'</span>:</div><div class="line">			<span class="keyword">return</span> $typeCode. <span class="string">' : '</span> .<span class="string">'jpg'</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="string">'7173'</span>:</div><div class="line">			<span class="keyword">return</span> $typeCode. <span class="string">' : '</span> .<span class="string">'gif'</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="string">'13780'</span>:</div><div class="line">			<span class="keyword">return</span> $typeCode. <span class="string">' : '</span> .<span class="string">'png'</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="string">'6677'</span>:</div><div class="line">			<span class="keyword">return</span> $typeCode. <span class="string">' : '</span> .<span class="string">'bmp'</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="string">'7790'</span>:</div><div class="line">			<span class="keyword">return</span> $typeCode. <span class="string">' : '</span> .<span class="string">'exe'</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="string">'7784'</span>:</div><div class="line">			<span class="keyword">return</span> $typeCode. <span class="string">' : '</span> .<span class="string">'midi'</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="string">'8297'</span>:</div><div class="line">			<span class="keyword">return</span> $typeCode. <span class="string">' : '</span> .<span class="string">'rar'</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">return</span> $typeCode. <span class="string">' : '</span> .<span class="string">'Unknown'</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//return $typeCode;</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">$file_name = <span class="string">'11.doc'</span>;</div><div class="line"><span class="keyword">echo</span> checkFileType($file_name);</div></pre></td></tr></table></figure></p>
<p>下来提供一个类的实现：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/*通过文件名，获得文件类型*</span></div><div class="line"> *<span class="doctag">@author</span> chengmo QQ:8292669*</div><div class="line"> *<span class="doctag">@copyright</span> &lt;a href="http://www.cnblogs.com/chengmo"&gt;http://www.cnblogs.com/chengmo&lt;/a&gt; 2010-10-17</div><div class="line"> *<span class="doctag">@version</span> 0.1</div><div class="line"> *$filename="d:/1.png";echo cFileTypeCheck::getFileType($filename); 打印：png</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">cFileTypeCheck</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $_TypeList=<span class="keyword">array</span>();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $CheckClass=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($filename)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">self</span>::$_TypeList=<span class="keyword">$this</span>-&gt;getTypeList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *处理文件类型映射关系表*</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> string $filename 文件类型</div><div class="line">     * <span class="doctag">@return</span> string 文件类型，没有找到返回：other</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">_getFileType</span><span class="params">($filename)</span></span></div><div class="line">    &#123;</div><div class="line">        $filetype=<span class="string">"other"</span>;</div><div class="line">        <span class="keyword">if</span>(!file_exists($filename)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"no found file!"</span>);</div><div class="line">        $file = @fopen($filename,<span class="string">"rb"</span>);</div><div class="line">        <span class="keyword">if</span>(!$file) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"file refuse!"</span>);</div><div class="line">        $bin = fread($file, <span class="number">15</span>); <span class="comment">//只读15字节 各个不同文件类型，头信息不一样。</span></div><div class="line">        fclose($file);</div><div class="line"></div><div class="line">        $typelist=<span class="keyword">self</span>::$_TypeList;</div><div class="line">        <span class="keyword">foreach</span> ($typelist <span class="keyword">as</span> $v)</div><div class="line">        &#123;</div><div class="line">            $blen=strlen(pack(<span class="string">"H*"</span>,$v[<span class="number">0</span>])); <span class="comment">//得到文件头标记字节数</span></div><div class="line">            $tbin=substr($bin,<span class="number">0</span>,intval($blen)); <span class="comment">///需要比较文件头长度</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span>(strtolower($v[<span class="number">0</span>])==strtolower(array_shift(unpack(<span class="string">"H*"</span>,$tbin))))</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> $v[<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> $filetype;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *得到文件头与文件类型映射表*</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> array array(array('key',value)...)</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTypeList</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="keyword">array</span>(<span class="string">"FFD8FFE1"</span>,<span class="string">"jpg"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"89504E47"</span>,<span class="string">"png"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"47494638"</span>,<span class="string">"gif"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"49492A00"</span>,<span class="string">"tif"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"424D"</span>,<span class="string">"bmp"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"41433130"</span>,<span class="string">"dwg"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"38425053"</span>,<span class="string">"psd"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"7B5C727466"</span>,<span class="string">"rtf"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"3C3F786D6C"</span>,<span class="string">"xml"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"68746D6C3E"</span>,<span class="string">"html"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"44656C69766572792D646174"</span>,<span class="string">"eml"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"CFAD12FEC5FD746F"</span>,<span class="string">"dbx"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"2142444E"</span>,<span class="string">"pst"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"D0CF11E0"</span>,<span class="string">"xls/doc"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"5374616E64617264204A"</span>,<span class="string">"mdb"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"FF575043"</span>,<span class="string">"wpd"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"252150532D41646F6265"</span>,<span class="string">"eps/ps"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"255044462D312E"</span>,<span class="string">"pdf"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"E3828596"</span>,<span class="string">"pwl"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"504B0304"</span>,<span class="string">"zip"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"52617221"</span>,<span class="string">"rar"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"57415645"</span>,<span class="string">"wav"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"41564920"</span>,<span class="string">"avi"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"2E7261FD"</span>,<span class="string">"ram"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"2E524D46"</span>,<span class="string">"rm"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"000001BA"</span>,<span class="string">"mpg"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"000001B3"</span>,<span class="string">"mpg"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"6D6F6F76"</span>,<span class="string">"mov"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"3026B2758E66CF11"</span>,<span class="string">"asf"</span>),</div><div class="line">        <span class="keyword">array</span>(<span class="string">"4D546864"</span>,<span class="string">"mid"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getFileType</span><span class="params">($filename)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!<span class="keyword">self</span>::$CheckClass) <span class="keyword">self</span>::$CheckClass=<span class="keyword">new</span> <span class="keyword">self</span>($filename);</div><div class="line">        $class=<span class="keyword">self</span>::$CheckClass;</div><div class="line">        <span class="keyword">return</span> $class-&gt;_getFileType($filename);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">$filename=<span class="string">"22.jpg"</span>;</div><div class="line"><span class="keyword">echo</span> $filename,<span class="string">"t"</span>,cFileTypeCheck::getFileType($filename),<span class="string">"rn"</span>;</div><div class="line">$filename=<span class="string">"11.doc"</span>;</div><div class="line"><span class="keyword">echo</span> $filename,<span class="string">"t"</span>,cFileTypeCheck::getFileType($filename),<span class="string">"rn"</span>;</div></pre></td></tr></table></figure>
<p>或者可以这么检测：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$filename = <span class="string">'22.jpg'</span>;</div><div class="line"></div><div class="line">$extname = strtolower(substr($filename, strrpos($filename, <span class="string">'.'</span>) + <span class="number">1</span>));</div><div class="line"><span class="keyword">echo</span> $extname.<span class="string">'&lt;br /&gt;'</span>;</div><div class="line">$file = @fopen($filename, <span class="string">'rb'</span>);</div><div class="line">    <span class="keyword">if</span> ($file)</div><div class="line">    &#123;</div><div class="line">        $str = @fread($file, <span class="number">0x400</span>); <span class="comment">// 读取前 1024 个字节</span></div><div class="line">		<span class="keyword">echo</span> substr($str, <span class="number">0</span>, <span class="number">4</span>);</div><div class="line">        @fclose($file);</div><div class="line">    &#125;</div><div class="line"> 	<span class="keyword">if</span> (substr($str, <span class="number">0</span>, <span class="number">4</span>) == <span class="string">'MThd'</span> &amp;&amp; $extname != <span class="string">'txt'</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'mid'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">elseif</span> (substr($str, <span class="number">0</span>, <span class="number">4</span>) == <span class="string">'RIFF'</span> &amp;&amp; $extname == <span class="string">'wav'</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'wav'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">3</span>) == <span class="string">"/xFF/xD8/xFF"</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'jpg'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">4</span>) == <span class="string">'GIF8'</span> &amp;&amp; $extname != <span class="string">'txt'</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'gif'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">8</span> ) == <span class="string">"/x89/x50/x4E/x47/x0D/x0A/x1A/x0A"</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'png'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">2</span>) == <span class="string">'BM'</span> &amp;&amp; $extname != <span class="string">'txt'</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'bmp'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">elseif</span> ((substr($str ,<span class="number">0</span>, <span class="number">3</span>) == <span class="string">'CWS'</span> || substr($str ,<span class="number">0</span>, <span class="number">3</span>) == <span class="string">'FWS'</span>) &amp;&amp; $extname != <span class="string">'txt'</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'swf'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">4</span>) == <span class="string">"/xD0/xCF/x11/xE0"</span>)</div><div class="line">        &#123;   <span class="comment">// D0CF11E == DOCFILE == Microsoft Office Document</span></div><div class="line">            <span class="keyword">if</span> (substr($str,<span class="number">0x200</span>,<span class="number">4</span>) == <span class="string">"/xEC/xA5/xC1/x00"</span> || $extname == <span class="string">'doc'</span>)</div><div class="line">            &#123;</div><div class="line">                $format = <span class="string">'doc'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">elseif</span> (substr($str,<span class="number">0x200</span>,<span class="number">2</span>) == <span class="string">"/x09/x08"</span> || $extname == <span class="string">'xls'</span>)</div><div class="line">            &#123;</div><div class="line">                $format = <span class="string">'xls'</span>;</div><div class="line">            &#125; <span class="keyword">elseif</span> (substr($str,<span class="number">0x200</span>,<span class="number">4</span>) == <span class="string">"/xFD/xFF/xFF/xFF"</span> || $extname == <span class="string">'ppt'</span>)</div><div class="line">            &#123;</div><div class="line">                $format = <span class="string">'ppt'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">4</span>) == <span class="string">"PK/x03/x04"</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'zip'</span>;</div><div class="line">        &#125; <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">4</span>) == <span class="string">'Rar!'</span> &amp;&amp; $extname != <span class="string">'txt'</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'rar'</span>;</div><div class="line">        &#125; <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">4</span>) == <span class="string">"/x25PDF"</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'pdf'</span>;</div><div class="line">        &#125; <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">3</span>) == <span class="string">"/x30/x82/x0A"</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'cert'</span>;</div><div class="line">        &#125; <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">4</span>) == <span class="string">'ITSF'</span> &amp;&amp; $extname != <span class="string">'txt'</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'chm'</span>;</div><div class="line">        &#125; <span class="keyword">elseif</span> (substr($str ,<span class="number">0</span>, <span class="number">4</span>) == <span class="string">"/x2ERMF"</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'rm'</span>;</div><div class="line">        &#125; <span class="keyword">elseif</span> ($extname == <span class="string">'sql'</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'sql'</span>;</div><div class="line">        &#125; <span class="keyword">elseif</span> ($extname == <span class="string">'txt'</span>)</div><div class="line">        &#123;</div><div class="line">            $format = <span class="string">'txt'</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		<span class="keyword">echo</span> $format;</div></pre></td></tr></table></figure>
<p><a href="http://www.nowamagic.net/librarys/veda/detail/836" target="_blank" rel="external">转自：http://www.nowamagic.net/librarys/veda/detail/836</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件签名一般都在文件的头部，如果你用十六进制方式查看文件，你就可以看到文件的一些签名信息。如用uestudio以十六进制方式查看zip格式的文件，其文件内容头部有50 4B 03 04这样的十六进制信息。同理jpg文件状况有FF D8 FF E0 xx xx 4A 46这样的十六进制信息，其实这此十六进制都是表示一些特殊字条。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>Xdebug之常见问题</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug之常见问题/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>xdebug的使用</p>
</li>
<li><p>xdebug的编译安装</p>
</li>
</ul>
<a id="more"></a>
<h2 id="xdebug的使用"><a href="#xdebug的使用" class="headerlink" title="xdebug的使用"></a>xdebug的使用</h2><p>问：phpinfo（）报告Xdebug已安装和启用，但我仍然不会得到任何堆栈跟踪时发生错误。</p>
<p>A1：你必须搜索所有的PHP库，并包含任何“set_error<em>handler”调用的文件。如果有任何，你必须将其注释掉，或者更改handler函数的主体以调用xdebug</em> * api函数。</p>
<p>A2：您没有在php.ini中将display_errors设置为1</p>
<hr>
<p>问：Xdebug不格式化输出。</p>
<p>A：确保php.ini中的PHP的html_errors设置为1</p>
<hr>
<p>问：调试客户端没有收到任何连接，我怎么办？</p>
<p>A：您可能忘记设置环境变量或向URL中添加必要的信息。有关详细信息，请参阅文档。</p>
<p>A：您检查过防火墙设置了吗？确保Xdebug正在侦听的端口（默认为9000）未被阻止。</p>
<p>A：你使用FastCGI，可能是通过FPM（FastCGI过程管理器）？它默认使用相同的端口作为Xdebug（9000），因此您需要将其中一个更改为不同的数字。在Xdebug，你可以使用xdebug.remote_port。</p>
<p>A：如果你使用SELinux运行，你应该确保它不会阻止连接;查找关于name_connect或与Xdebug端口相关的任何警告。您可能必须明确允许访问。访问此网站或搜索“selinux name_connect apache”有关如何执行此操作的详细信息</p>
<h2 id="xdebug的编译安装"><a href="#xdebug的编译安装" class="headerlink" title="xdebug的编译安装"></a>xdebug的编译安装</h2><p>问：我没有phpize工具。</p>
<p>答：Debian和Ubuntu用户需要用apt安装php5-dev软件包。</p>
<hr>
<p>问：如何处理：Xdebug需要Zend Engine API版本xxxxxxxx。安装的Zend Engine API版本2xxxxxxxx较新。</p>
<p>A：此消息意味着您正在尝试加载Xdebug的PHP版本，它不是为它构建的。如果你自己编译PHP，很可能是因为你编译Xdebug对PHP头，属于你运行的不同的PHP版本。例如，你使用PHP 5.3，你使用的头仍然是PHP 5.2。如果你使用一个预编译的二进制文件，那么你使用的是错误的。</p>
<p>要诊断这是否是您的问题，请执行以下步骤：</p>
<ul>
<li><p>通过查看phpinfo（）（或“php -i”）输出，检查您正在运行的PHP版本的“Zend Extension”API号。您可以在输出的顶部找到它，与PHP徽标和PHP版本在同一个块中。例如，对于PHP 5.2，数字是“220060519”，对于PHP 5.3，它是“220090626”。</p>
</li>
<li><p>当您完成编译步骤时，检查“phpize”的输出。您要查找的数字是在“Zend Extension Api No”的行上。</p>
</li>
</ul>
<p>如果上面的两个数字不匹配，你正在使用错误的PHP头文件进行编译。请参阅下一个常见问题条目以确定要使用的phpize。</p>
<hr>
<p>问：Xdebug仅作为PHP扩展加载，而不是作为Zend扩展。<br>定制的安装指导可能已指向此条目。</p>
<p>为了使Xdebug正常工作，包括断点等，它需要它作为Zend扩展加载，而不只是作为一个普通的PHP扩展。有些安装工具（PEAR / PECL）有时建议您使用extension = xdebug.so加载Xdebug。这是不正确的。为了解决这个问题，请在顶部块中“加载配置文件”和“其他.ini文件解析”下列出的任何INI文件中查找一行extension = xdebug.so。删除此行，并返回到定制安装说明。</p>
<hr>
<p>问：我如何找到使用哪个phpize？</p>
<p>A：运行：“phpize –help”。这将显示phpize的完整路径。此路径应该与您具有CLI二进制文件“php-config”和安装的“pear”和“pecl”二进制文件的路径相同。如果你运行“php-config –version”它应该显示与你运行的PHP版本相同。如果它不匹配，并且可能在路径上找到错误的“phpize”二进制，您可以运行configure如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/full/path/to/php/bin/phpize</div><div class="line">./configure --with-php-config=/full/path/to/php/bin/php-config</div></pre></td></tr></table></figure>
<hr>
<p>问：我使用XAMPP，但我似乎不能得到打包的xdebug扩展正常工作。</p>
<p>A：如果你取消注释“extension = php_xdebug.dll”行，这是预期的。 Xdebug需要加载zend_extension_ts =“C：\ path \ to \ php_xdebug.dll”指令。 你也可能必须禁用加载Zend优化器，因为它默认情况下启用，并且不能很好地与Xdebug。 因此，查找php.ini中的相关条目，并将其注释掉。 从PHP 5.3起，您总是需要使用zend_extension PHP.ini设置名称，而不是zend_extension_ts。<br>问：在Debian，我看到以下问题与Xdebug的构建….任何修复？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/usr/lib/libc_nonshared.a(stat.oS)(.text.__i686.get_pc_thunk.bx+0x0):</div><div class="line">In function `__i686.get_pc_thunk.bx&apos;:</div><div class="line">: multiple definition of `__i686.get_pc_thunk.bx&apos;</div><div class="line">/usr/lib/gcc-lib/i486-linux/3.3.5/crtbeginS.o</div><div class="line">(.gnu.linkonce.t.__i686.get_pc_thunk.bx+0x0): first defined here</div><div class="line">collect2: ld returned 1 exit status</div><div class="line">make: *** [xdebug.la] Error 1</div></pre></td></tr></table></figure>
<p>A：这是Debian本身的问题，有关更多信息，请参阅<a href="http://www.xdebug.org/archives/xdebug-general/0825.html" target="_blank" rel="external">此处</a>和<a href="http://www.xdebug.org/archives/xdebug-general/0825.html" target="_blank" rel="external">此处</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;xdebug的使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;xdebug的编译安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
      <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Xdebug之变量显示功能</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug之堆栈跟踪/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>当Xdebug被激活时，只要PHP决定显示通知，警告，错误等，它将显示一个堆栈跟踪。堆栈跟踪显示的信息以及它们的呈现方式可以配置为满足您的需要。</p>
<p>Xdebug在错误情况下显示的堆栈跟踪（如果display_errors在php.ini中设置为On）在它们显示的信息量上相当保守。 这是因为大量的信息可以减慢脚本的执行和在浏览器中呈现堆栈跟踪本身。 但是，可以使堆栈跟踪显示具有不同设置的更详细信息。</p>
<a id="more"></a>
<h2 id="堆栈跟踪中的变量"><a href="#堆栈跟踪中的变量" class="headerlink" title="堆栈跟踪中的变量"></a>堆栈跟踪中的变量</h2><p>默认情况下，Xdebug现在会在它生成的堆栈跟踪中显示变量信息。 在收集或显示时，可变信息可能需要相当多的资源。 然而，在许多情况下，显示变量信息是有用的，这就是为什么Xdebug具有设置xdebug.collect_params。 下面的脚本结合了该设置的不同值的输出结果，如下例所示。</p>
<p>示例：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">( $a )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $a[<span class="string">'foo'</span>]; $i++) &#123;</div><div class="line">        <span class="keyword">if</span> ($i == <span class="number">500000</span>) xdebug_break();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">set_time_limit(<span class="number">1</span>);</div><div class="line">$c = <span class="keyword">new</span> stdClass;</div><div class="line">$c-&gt;bar = <span class="number">100</span>;</div><div class="line">$a = <span class="keyword">array</span>(</div><div class="line">    <span class="number">42</span> =&gt; <span class="keyword">false</span>, <span class="string">'foo'</span> =&gt; <span class="number">912124</span>,</div><div class="line">    $c, <span class="keyword">new</span> stdClass, fopen( <span class="string">'/etc/passwd'</span>, <span class="string">'r'</span> )</div><div class="line">);</div><div class="line">foo( $a );</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>结果:<br>xdebug.collect_params设置的不同值提供不同的输出，您可以在下面看到：</p>
<ul>
<li>default</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-0@2x.png" alt="default"></p>
<ul>
<li>1<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ini_set(&apos;xdebug.collect_params&apos;, &apos;1&apos;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-1@2x.png" alt="default"></p>
<ul>
<li>2<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ini_set(&apos;xdebug.collect_params&apos;, &apos;2&apos;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-2@2x.png" alt="default"></p>
<ul>
<li>3<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ini_set(&apos;xdebug.collect_params&apos;, &apos;3&apos;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-3@2x.png" alt="default"></p>
<ul>
<li>4<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ini_set(&apos;xdebug.collect_params&apos;, &apos;4&apos;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-4@2x.png" alt="default"></p>
<h2 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h2><p>除了显示传递给每个函数的变量的值之外，Xdebug还可以通过使用xdebug.dump_globals和xdebug.dump.* 设置来选择性地显示关于所选超级元素的信息。 设置xdebug.dump_once和xdebug.dump_undefined会稍微修改可用超级元素显示的时间和信息。 使用xdebug.show_local_vars设置，您可以指示Xdebug为用户定义的函数显示最顶层栈级中可用的所有变量。 下面的示例显示了这一点（脚本从上面的示例中使用）。</p>
<ul>
<li>default</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-5@2x.png" alt="default"></p>
<ul>
<li>dump_superglobals=1<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ini_set(&apos;xdebug.collect_vars&apos;, &apos;on&apos;);</div><div class="line">ini_set(&apos;xdebug.collect_params&apos;, &apos;4&apos;);</div><div class="line">ini_set(&apos;xdebug.dump_globals&apos;, &apos;on&apos;);</div><div class="line">ini_set(&apos;xdebug.dump.SERVER&apos;, &apos;REQUEST_URI&apos;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-6@2x.png" alt="default"></p>
<ul>
<li>show_local_vars=1<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ini_set(&apos;xdebug.collect_vars&apos;, &apos;on&apos;);</div><div class="line">ini_set(&apos;xdebug.collect_params&apos;, &apos;4&apos;);</div><div class="line">ini_set(&apos;xdebug.dump_globals&apos;, &apos;on&apos;);</div><div class="line">ini_set(&apos;xdebug.dump.SERVER&apos;, &apos;REQUEST_URI&apos;);</div><div class="line">ini_set(&apos;xdebug.show_local_vars&apos;, &apos;on&apos;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-8@2x.png" alt="default"></p>
<h2 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h2><h3 id="xdebug-cli-color"><a href="#xdebug-cli-color" class="headerlink" title="xdebug.cli_color"></a><strong>xdebug.cli_color</strong></h3><p>类型：整数，默认值：0，在Xdebug&gt; 2.2中引入</p>
<p>如果此设置为1，则Xdebug将在CLI模式下和输出为tty时对var_dumps和堆栈跟踪输出进行颜色。在Windows上，需要安装ANSICON工具。</p>
<p>如果设置为2，那么无论Xdebug是否连接到tty或是否安装了ANSICON，Xdebug都将始终对var_dumps和堆栈跟踪进行着色。在这种情况下，您可能会看到转义码。</p>
<p>有关更多信息，请参阅此<a href="http://drck.me/clicolor-9cr" target="_blank" rel="external">文章</a>。</p>
<h3 id="xdebug-collect-includes"><a href="#xdebug-collect-includes" class="headerlink" title="xdebug.collect_includes"></a><strong>xdebug.collect_includes</strong></h3><p>类型：布尔值，默认值：1</p>
<p>此设置默认为1，控制Xdebug是否应将include（），include_once（），require（）或require_once（）中使用的文件名写入跟踪文件。</p>
<h3 id="xdebug-collect-params"><a href="#xdebug-collect-params" class="headerlink" title="xdebug.collect_params"></a><strong>xdebug.collect_params</strong></h3><p>类型：整数，默认值：0</p>
<p>此设置默认为0，控制在函数跟踪或堆栈跟踪中记录函数调用时，Xdebug是否应收集传递给函数的参数。</p>
<p>该设置默认为0，因为对于非常大的脚本，它可能使用大量的内存，因此使巨量脚本无法运行。您可以最安全地打开此设置，但是您可以预期在具有大量函数调用和/或巨大的数据结构作为参数的脚本中存在一些问题。</p>
<p>Xdebug 2不会有增加的内存使用这个问题，因为它永远不会将此信息存储在内存中。相反，它将只被写入磁盘。这意味着您需要查看磁盘使用情况。</p>
<p>此设置可以有四个不同的值。对于每个值，示出了不同量的信息。下面你将看到每个值提供什么信息。另请参见功能堆栈跟踪的几个截图的介绍。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>显示参数信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>无。</td>
</tr>
<tr>
<td>1</td>
<td>元素的类型和数量（f.e. string（6），array（8））。</td>
</tr>
<tr>
<td>2</td>
<td>元素的类型和数量，带有完整信息的工具提示1。在CLI版本的PHP它不会有工具提示，而不是在输出文件。</td>
</tr>
<tr>
<td>3</td>
<td>完全变量内容（具有由xdebug.var_display_max_children，xdebug.var_display_max_data和xdebug.var_display_max_depth设置的限制）。</td>
</tr>
<tr>
<td>4</td>
<td>完全变量内容和变量名称。</td>
</tr>
<tr>
<td>5</td>
<td>PHP序列化变量内容，没有名称。 （Xdebug 2.3中的新功能）</td>
</tr>
</tbody>
</table>
<h3 id="xdebug-collect-vars"><a href="#xdebug-collect-vars" class="headerlink" title="xdebug.collect_vars"></a><strong>xdebug.collect_vars</strong></h3><p>类型：布尔值，默认值：0</p>
<p>此设置告诉Xdebug收集有关在某个范围中使用哪些变量的信息。 这个分析可能很慢，因为Xdebug必须逆向工程PHP的操作码数组。 此设置不会记录不同变量具有的值，因为使用xdebug.collect_params。 仅当您希望使用xdebug_get_declared_vars（）时，才需要启用此设置。</p>
<h3 id="xdebug-dump"><a href="#xdebug-dump" class="headerlink" title="xdebug.dump.*"></a><strong>xdebug.dump.*</strong></h3><p>类型：字符串，默认值：空</p>
<p>*可以是COOKIE，FILES，GET，POST，REQUEST，SERVER，SESSION中的任何一个。 这七个设置控制当发生错误情况时来自超级溶剂的数据。</p>
<p>每个php.ini设置可以包括一个逗号分隔的变量从这个超级全局转储，或*所有的。 请确保您在此设置中不添加空格。</p>
<p>为了在发生错误时转储REMOTE_ADDR和REQUEST_METHOD，以及所有GET参数，请添加以下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xdebug.dump.SERVER = REMOTE_ADDR,REQUEST_METHOD</div><div class="line">xdebug.dump.GET = *</div></pre></td></tr></table></figure></p>
<h3 id="xdebug-dump-globals"><a href="#xdebug-dump-globals" class="headerlink" title="xdebug.dump_globals"></a><strong>xdebug.dump_globals</strong></h3><p>类型：布尔值，默认值：1</p>
<p>控制是否应显示由xdebug.dump.*设置定义的超级元素的值。</p>
<h3 id="xdebug-dump-once"><a href="#xdebug-dump-once" class="headerlink" title="xdebug.dump_once"></a><strong>xdebug.dump_once</strong></h3><p>类型：布尔值，默认值：1</p>
<p>控制是否应在所有错误情况（设置为0）或仅在第一个（设置为1）上转储超级元素的值。</p>
<h3 id="xdebug-dump-undefined"><a href="#xdebug-dump-undefined" class="headerlink" title="xdebug.dump_undefined"></a><strong>xdebug.dump_undefined</strong></h3><p>类型：布尔值，默认值：0<br>如果要从超级元组转储未定义的值，您应该将此设置设置为1，否则将其设置为0。</p>
<h3 id="xdebug-file-link-format"><a href="#xdebug-file-link-format" class="headerlink" title="xdebug.file_link_format"></a><strong>xdebug.file_link_format</strong></h3><p>类型：字符串，默认值：，在Xdebug&gt; 2.1中引入</p>
<p>此设置确定在使用文件名的堆栈跟踪显示中进行的链接的格式。 这允许IDE设置一个链接协议，通过单击Xdebug在堆栈跟踪中显示的文件名，可以直接转到行和文件。 示例格式可能如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myide://%f@%l</div></pre></td></tr></table></figure></p>
<p>可能的格式说明符是：</p>
<table>
<thead>
<tr>
<th>说明符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>％f</td>
<td>文件名</td>
</tr>
<tr>
<td>％l</td>
<td>行号</td>
</tr>
</tbody>
</table>
<p>对于各种IDE / OSses，有一些关于如何使这项工作的指示：</p>
<p>Linux上的Firefox</p>
<ul>
<li>打开about：config</li>
<li>添加一个新的布尔设置“network.protocol-handler.expose.xdebug”并将其设置为“false”</li>
<li>将以下内容添加到shell脚本〜/ bin / ff-xdebug.sh中：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/sh</span></div><div class="line">f=`<span class="built_in">echo</span> <span class="variable">$1</span> | cut <span class="_">-d</span> @ <span class="_">-f</span> 1 | sed <span class="string">'s/xdebug:\/\///'</span>`</div><div class="line">l=`<span class="built_in">echo</span> <span class="variable">$1</span> | cut <span class="_">-d</span> @ <span class="_">-f</span> 2`</div></pre></td></tr></table></figure>
</li>
</ul>
<p>添加（取决于你有komodo，vim vs netbeans）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">komodo <span class="variable">$f</span> <span class="_">-l</span> <span class="variable">$l</span></div><div class="line">gvim --remote-tab +<span class="variable">$l</span> <span class="variable">$f</span></div><div class="line">netbeans <span class="string">"<span class="variable">$f</span>:<span class="variable">$l</span>"</span></div></pre></td></tr></table></figure></p>
<ul>
<li>使用chmod + x〜/ bin / ff-xdebug.sh来使脚本可执行</li>
<li>将xdebug.file_link_format设置为xdebug：//％f @％l</li>
</ul>
<p>Windows和netbeans</p>
<ul>
<li>创建文件netbeans.bat并将其保存在您的路径（C：\ Windows）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">setlocal enableextensions enabledelayedexpansion</div><div class="line">set NETBEANS=%1</div><div class="line">set FILE=%~2</div><div class="line">%NETBEANS% --nosplash --console suppress --open &quot;%FILE:~19%&quot;</div><div class="line">nircmd win activate process netbeans.exe</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：如果没有nircmd，请删除最后一行。</p>
<ul>
<li>将以下代码保存在netbeans protocol.reg中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Windows Registry Editor Version 5.00</div><div class="line"></div><div class="line">[HKEY_CLASSES_ROOT\netbeans]</div><div class="line">&quot;URL Protocol&quot;=&quot;&quot;</div><div class="line">@=&quot;URL:Netbeans Protocol&quot;</div><div class="line"></div><div class="line">[HKEY_CLASSES_ROOT\netbeans\DefaultIcon]</div><div class="line">@=&quot;\&quot;C:\\Program Files\\NetBeans 7.1.1\\bin\\netbeans.exe,1\&quot;&quot;</div><div class="line"></div><div class="line">[HKEY_CLASSES_ROOT\netbeans\shell]</div><div class="line"></div><div class="line">[HKEY_CLASSES_ROOT\netbeans\shell\open]</div><div class="line"></div><div class="line">[HKEY_CLASSES_ROOT\netbeans\shell\open\command]</div><div class="line">@=&quot;\&quot;C:\\Windows\\netbeans.bat\&quot; \&quot;C:\\Program Files\\NetBeans 7.1.1\\bin\\netbeans.exe\&quot; \&quot;%1\&quot;&quot;</div></pre></td></tr></table></figure>
<p>注意：确保更改Netbeans（两次）的路径以及netbeans.bat批处理文件（如果将其保存在C：\Windows 以外的其他位置）。</p>
<p>Double click on the netbeans_protocol.reg file to import it into the registry.<br>Set the xdebug.file_link_format setting to</p>
<ul>
<li><p>双击netbeans protocol.reg文件将其导入到注册表中。</p>
</li>
<li><p>将xdebug.file_link_format设置设置为<code>xdebug.file_link_format = &quot;netbeans://open/?f=%f:%l&quot;</code></p>
</li>
</ul>
<h3 id="xdebug-manual-url"><a href="#xdebug-manual-url" class="headerlink" title="xdebug.manual_url"></a><strong>xdebug.manual_url</strong></h3><p>类型：字符串，默认值：http：//www.php.net，在Xdebug &lt;2.2.1中引入</p>
<p>这是从函数跟踪和错误消息到函数的手册页的链接的基本URL。建议将此设置设置为使用最近的镜像。</p>
<h3 id="xdebug-show-exception-trace"><a href="#xdebug-show-exception-trace" class="headerlink" title="xdebug.show_exception_trace"></a><strong>xdebug.show_exception_trace</strong></h3><p>类型：整数，默认值：0</p>
<p>当此设置设置为1时，每当引发异常时，即使此异常实际被捕获，Xdebug也将显示堆栈跟踪。</p>
<h3 id="xdebug-show-local-vars"><a href="#xdebug-show-local-vars" class="headerlink" title="xdebug.show_local_vars"></a><strong>xdebug.show_local_vars</strong></h3><p>类型：整数，默认值：0</p>
<p>当这个设置设置为某事！= 0 Xdebug的错误情况下生成的堆栈转储也将显示最顶层范围中的所有变量。请注意，这可能会生成大量的信息，因此默认情况下关闭。</p>
<h3 id="xdebug-show-mem-delta"><a href="#xdebug-show-mem-delta" class="headerlink" title="xdebug.show_mem_delta"></a><strong>xdebug.show_mem_delta</strong></h3><p>类型：整数，默认值：0</p>
<p>当这个设置设置为某些！= 0 Xdebug的人类可读的生成的跟踪文件将显示在函数调用之间的内存使用的差异。如果Xdebug配置为生成计算机可读的跟踪文件，则它们将始终显示此信息。</p>
<h3 id="xdebug-var-display-max-children"><a href="#xdebug-var-display-max-children" class="headerlink" title="xdebug.var_display_max_children"></a><strong>xdebug.var_display_max_children</strong></h3><p>类型：整数，默认值：128</p>
<p>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的数组子元素和对象的属性的数量。</p>
<p>要禁用任何限制，请使用-1作为值。</p>
<p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p>
<h3 id="xdebug-var-display-max-data"><a href="#xdebug-var-display-max-data" class="headerlink" title="xdebug.var_display_max_data"></a><strong>xdebug.var_display_max_data</strong></h3><p>类型：整数，默认值：512</p>
<p>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的最大字符串长度。</p>
<p>要禁用任何限制，请使用-1作为值。</p>
<p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p>
<h3 id="xdebug-var-display-max-depth"><a href="#xdebug-var-display-max-depth" class="headerlink" title="xdebug.var_display_max_depth"></a><strong>xdebug.var_display_max_depth</strong></h3><p>类型：整数，默认值：3</p>
<p>当使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时，控制数组元素和对象属性的嵌套级别数。</p>
<p>您可以选择的最大值为1023.您还可以使用-1作为值来选择此最大数。</p>
<p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="array-xdebug-get-declared-vars（）"><a href="#array-xdebug-get-declared-vars（）" class="headerlink" title="array xdebug_get_declared_vars（）"></a><strong>array xdebug_get_declared_vars（）</strong></h3><p>返回声明的变量</p>
<p>返回一个数组，其中每个元素是在当前范围中定义的变量名称。 需要启用xdebug.collect_vars设置。</p>
<p>Example:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">strings</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">fix_strings</span><span class="params">($a, $b)</span> </span>&#123;</div><div class="line">            <span class="keyword">foreach</span> ($b <span class="keyword">as</span> $item) &#123;</div><div class="line">            &#125;</div><div class="line">            var_dump(xdebug_get_declared_vars());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    strings::fix_strings(<span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="keyword">array</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>Returns:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array</div><div class="line">  0 =&gt; string &apos;a&apos; (length=1)</div><div class="line">  1 =&gt; string &apos;b&apos; (length=1)</div><div class="line">  2 =&gt; string &apos;item&apos; (length=4)</div></pre></td></tr></table></figure></p>
<p>在5.1之前的PHP版本中，变量名“a”不在返回的数组中，因为它在调用函数xdebug_get_declared_vars（）的作用域中不使用。</p>
<h3 id="array-xdebug-get-function-stack（）"><a href="#array-xdebug-get-function-stack（）" class="headerlink" title="array xdebug_get_function_stack（）"></a><strong>array xdebug_get_function_stack（）</strong></h3><p>返回有关堆栈的信息</p>
<p>返回类似于此点的堆栈跟踪的数组。 示例脚本：</p>
<p>Example:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">strings</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fix_string</span><span class="params">($a)</span></span></div><div class="line">        &#123;</div><div class="line">            var_dump(xdebug_get_function_stack());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fix_strings</span><span class="params">($b)</span> </span>&#123;</div><div class="line">            <span class="keyword">foreach</span> ($b <span class="keyword">as</span> $item) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;fix_string($item);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $s = <span class="keyword">new</span> strings();</div><div class="line">    $ret = $s-&gt;fix_strings(<span class="keyword">array</span>(<span class="string">'Derick'</span>));</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>Returns:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">array</div><div class="line">  0 =&gt;</div><div class="line">    array</div><div class="line">      &apos;function&apos; =&gt; string &apos;&#123;main&#125;&apos; (length=6)</div><div class="line">      &apos;file&apos; =&gt; string &apos;/var/www/xdebug_get_function_stack.php&apos; (length=63)</div><div class="line">      &apos;line&apos; =&gt; int 0</div><div class="line">      &apos;params&apos; =&gt;</div><div class="line">        array</div><div class="line">          empty</div><div class="line">  1 =&gt;</div><div class="line">    array</div><div class="line">      &apos;function&apos; =&gt; string &apos;fix_strings&apos; (length=11)</div><div class="line">      &apos;class&apos; =&gt; string &apos;strings&apos; (length=7)</div><div class="line">      &apos;file&apos; =&gt; string &apos;/var/www/xdebug_get_function_stack.php&apos; (length=63)</div><div class="line">      &apos;line&apos; =&gt; int 18</div><div class="line">      &apos;params&apos; =&gt;</div><div class="line">        array</div><div class="line">          &apos;b&apos; =&gt; string &apos;array (0 =&gt; &apos;Derick&apos;)&apos; (length=21)</div><div class="line">  2 =&gt;</div><div class="line">    array</div><div class="line">      &apos;function&apos; =&gt; string &apos;fix_string&apos; (length=10)</div><div class="line">      &apos;class&apos; =&gt; string &apos;strings&apos; (length=7)</div><div class="line">      &apos;file&apos; =&gt; string &apos;/var/www/xdebug_get_function_stack.php&apos; (length=63)</div><div class="line">      &apos;line&apos; =&gt; int 12</div><div class="line">      &apos;params&apos; =&gt;</div><div class="line">        array</div><div class="line">          &apos;a&apos; =&gt; string &apos;&apos;Derick&apos;&apos; (length=8)</div></pre></td></tr></table></figure></p>
<h3 id="array-xdebug-get-monitored-functions（）"><a href="#array-xdebug-get-monitored-functions（）" class="headerlink" title="array xdebug_get_monitored_functions（）"></a><strong>array xdebug_get_monitored_functions（）</strong></h3><p>返回有关受监视函数的信息</p>
<p>在2.4版本中引入</p>
<p>返回一个结构，其中包含有关在脚本中执行受监视函数的位置的信息。 以下示例显示如何使用此和返回的信息：</p>
<p>Example:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/* Start the function monitor for strrev and array_push: */</span></div><div class="line">xdebug_start_function_monitor( [ <span class="string">'strrev'</span>, <span class="string">'array_push'</span> ] );</div><div class="line"></div><div class="line"><span class="comment">/* Run some code: */</span></div><div class="line"><span class="keyword">echo</span> strrev(<span class="string">"yes!"</span>), <span class="string">"\n"</span>;</div><div class="line"></div><div class="line"><span class="keyword">echo</span> strrev(<span class="string">"yes!"</span>), <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">var_dump(xdebug_get_monitored_functions());</div><div class="line">xdebug_stop_function_monitor();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>Returns:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/tmp/monitor-example.php:10:</div><div class="line">array(2) &#123;</div><div class="line">  [0] =&gt;</div><div class="line">  array(3) &#123;</div><div class="line">    &apos;function&apos; =&gt;</div><div class="line">    string(6) &quot;strrev&quot;</div><div class="line">    &apos;filename&apos; =&gt;</div><div class="line">    string(24) &quot;/tmp/monitor-example.php&quot;</div><div class="line">    &apos;lineno&apos; =&gt;</div><div class="line">    int(6)</div><div class="line">  &#125;</div><div class="line">  [1] =&gt;</div><div class="line">  array(3) &#123;</div><div class="line">    &apos;function&apos; =&gt;</div><div class="line">    string(6) &quot;strrev&quot;</div><div class="line">    &apos;filename&apos; =&gt;</div><div class="line">    string(24) &quot;/tmp/monitor-example.php&quot;</div><div class="line">    &apos;lineno&apos; =&gt;</div><div class="line">    int(8)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="integer-xdebug-get-stack-depth（）"><a href="#integer-xdebug-get-stack-depth（）" class="headerlink" title="integer xdebug_get_stack_depth（）"></a><strong>integer xdebug_get_stack_depth（）</strong></h3><p>返回当前堆栈深度级别</p>
<p>返回堆栈深度级别。 脚本的主体是级别0，每个包含和/或函数调用将向堆栈深度级别添加一个。</p>
<h3 id="none-xdebug-print-function-stack-string-message-int-options"><a href="#none-xdebug-print-function-stack-string-message-int-options" class="headerlink" title="none xdebug_print_function_stack( [ string message [, int options ] ] )"></a><strong>none xdebug_print_function_stack( [ string message [, int options ] ] )</strong></h3><p>显示当前函数栈</p>
<p>以类似于Xdebug在错误情况下显示的方式显示当前函数堆栈。</p>
<p>“message”参数允许您使用自己的头部替换消息。 （在Xdebug 2.1中引入）。</p>
<p>Example:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">( $far, $out )</span></span></div><div class="line">&#123;</div><div class="line">    xdebug_print_function_stack( <span class="string">'Your own message'</span> );</div><div class="line">&#125;</div><div class="line">foo( <span class="number">42</span>, <span class="number">3141592654</span> );</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>Returns:</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-9@2x.png" alt="img"></p>
<p>位掩码“options”允许您配置一些额外的选项。 目前支持以下选项：</p>
<ul>
<li>XDEBUG_STACK_NO_DESC<blockquote>
<p>如果设置了此选项，则打印的堆栈跟踪将不具有标题。 如果要从自己的错误处理程序打印堆栈跟踪，否则打印位置是从中调用xdebug_print_function_stack（）时，这是有用的。 （在Xdebug 2.3中引入）。</p>
</blockquote>
</li>
</ul>
<h3 id="void-xdebug-start-function-monitor（array-list-of-functions-to-monitor）"><a href="#void-xdebug-start-function-monitor（array-list-of-functions-to-monitor）" class="headerlink" title="void xdebug_start_function_monitor（array $ list_of_functions_to_monitor）"></a><strong>void xdebug_start_function_monitor（array $ list_of_functions_to_monitor）</strong></h3><p>开始功能监控</p>
<p>在2.4版本中引入</p>
<p>此函数开始监视列表中给出的函数作为此函数的参数。 函数监视允许您找到代码中提供的作为参数的函数在哪里调用。 这可以用于跟踪使用旧的或不鼓励的函数的位置。</p>
<p>Example:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">xdebug_start_function_monitor( [ <span class="string">'strrev'</span>, <span class="string">'array_push'</span> ] );</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>您还可以向定义要监视的函数的数组添加类方法和静态方法。 例如，要捕获对DramModel :: canSee的静态调用和对Whisky-&gt; drink的动态调用，您将启动监视器：</p>
<p>Example:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">xdebug_start_function_monitor( [ <span class="string">'DramModel::canSee'</span>, <span class="string">'Whisky-&gt;drink'</span>] );</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>定义的函数区分大小写，并且不会捕获对静态方法的动态调用。</p>
<h3 id="void-xdebug-stop-function-monitor（）"><a href="#void-xdebug-stop-function-monitor（）" class="headerlink" title="void xdebug_stop_function_monitor（）"></a><strong>void xdebug_stop_function_monitor（）</strong></h3><p>停止监视功能</p>
<p>在2.4版本中引入</p>
<p>此功能停止功能监视器。 为了获得受监视函数的列表，您需要使用xdebug_get_monitored_functions（）函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当Xdebug被激活时，只要PHP决定显示通知，警告，错误等，它将显示一个堆栈跟踪。堆栈跟踪显示的信息以及它们的呈现方式可以配置为满足您的需要。&lt;/p&gt;
&lt;p&gt;Xdebug在错误情况下显示的堆栈跟踪（如果display_errors在php.ini中设置为On）在它们显示的信息量上相当保守。 这是因为大量的信息可以减慢脚本的执行和在浏览器中呈现堆栈跟踪本身。 但是，可以使堆栈跟踪显示具有不同设置的更详细信息。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
      <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Xdebug之远程调试</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug之远程调试/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Xdebug为与运行PHP脚本交互的调试器客户端提供了一个接口。 本节介绍如何设置PHP和Xdebug来允许这一点，并介绍一些客户端。</p>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Xdebug的（远程）调试器允许您检查数据结构，交互式地浏览和调试您的代码。 正在使用的协议是打开的，称为DBGp。 此协议在Xdebug 2中实现，并替换不再支持的旧的GDB类协议。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Xdebug 2捆绑了一个用于DBGp协议的简单命令行客户端。 还有一些其他客户端实现（免费和商业）。 我不是任何这些的作者，所以请参考原作者的支持：</p>
<ul>
<li>Dev-PHP (IDE: Windows)</li>
<li>Eclipse plugin (IDE).</li>
<li>Emacs plugin (Editor Plugin).</li>
<li>KDevelop (IDE: Linux (KDE); Open Source).</li>
<li>ActiveState’s Komodo (IDE: Windows, Linux, Mac; Commercial).</li>
<li>MacGDBP (Standalone client for Mac OS X; Free)</li>
<li>NetBeans (IDE: Windows, Linux, Mac OS X and Solaris).</li>
<li>Notepad++ plugin (Editor: Windows).</li>
<li>WaterProof’s PHPEdit (IDE, from version 2.10: Windows; Commercial).</li>
<li>PHPEclipse (Editor Plugin).</li>
<li>Devsense’s PHP Tools for Visual Studio (MS Visual Studio Plugin; Commercial).</li>
<li>JetBrain’s PhpStorm (IDE; Commercial).</li>
<li>Protoeditor (Editor: Linux).</li>
<li>pugdebug (Standalone client for Linux, Windows and Mac OS X; Open Source).</li>
<li>VIM plugin (Editor Plugin).</li>
<li>jcx software’s VS.Php (MS Visual Studio Plugin; Commercial).</li>
<li>Xdebug Chrome App (Chrome Application; Open Source)</li>
<li>XDebugClient (Standalone client for Windows).</li>
</ul>
<p>用于调试的简单命令行客户机与debugclient目录中的Xdebug捆绑在一起。</p>
<h2 id="启动调试器"><a href="#启动调试器" class="headerlink" title="启动调试器"></a>启动调试器</h2><p>为了启用Xdebug的调试器，您需要在php.ini中进行一些配置设置。 这些设置为xdebug.remote_enable以启用调试器xdebug.remote_host和xdebug.remote_port来配置调试器应连接到的IP地址和端口。 还有一个xdebug.remote_connect_back设置，如果您的开发服务器与多个开发人员共享，则可以使用此设置。</p>
<p>如果希望调试器在发生错误情况（PHP错误或异常）时启动会话，则还需要更改xdebug.remote_mode设置。 此设置的允许值为“req”（默认值），这使得调试器在脚本启动时启动会话，或者“jit”，当会话只应在错误时启动。</p>
<p>完成所有这些设置后，Xdebug仍然不会在脚本运行时自动启动调试会话。 你需要激活Xdebug的调试器，你可以通过三种方式：</p>
<p>1、当从命令行运行脚本时，您需要设置一个环境变量，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export XDEBUG_CONFIG=&quot;idekey=session_name&quot;</div><div class="line">php myscript.php</div></pre></td></tr></table></figure></p>
<p>您还可以在此相同的环境变量中配置xdebug.remote_host，xdebug.remote_port，xdebug.remote_mode和xdebug.remote_handler，只要使用空格分隔值即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export XDEBUG_CONFIG=&quot;idekey=session_name remote_host=localhost profiler_enable=1&quot;</div></pre></td></tr></table></figure></p>
<p>通过XDEBUG_CONFIG设置可以获得的所有设置也可以使用正常的php.ini设置进行设置。</p>
<p>2、如果要调试通过Web浏览器启动的脚本，只需将XDEBUG_SESSION_START = session_name作为参数添加到URL。 而不是使用GET参数，您还可以将XDEBUG_SESSION_START设置为POST参数，或通过cookie。 请参阅下一节，了解调试会话如何在浏览器窗口中工作。</p>
<p>3、通过Web服务器运行PHP时激活调试器的另一种方法是安装以下四个浏览器扩展之一。 它们中的每一个都允许您通过单击一个按钮来启用调试器。 当这些扩展是活动的，他们直接设置XDEBUG_SESSION cookie，而不是通过XDEBUG_SESSION_START进一步的HTTP调试会话中描述。 扩展名为：</p>
<ul>
<li><p>The easiest Xdebug</p>
<blockquote>
<p>这个扩展的Firefox是为了使IDE的调试更容易。 您可以在<a href="https://addons.mozilla.org/en-US/firefox/addon/the-easiest-xdebug/找到扩展程序。" target="_blank" rel="external">https://addons.mozilla.org/en-US/firefox/addon/the-easiest-xdebug/找到扩展程序。</a></p>
</blockquote>
</li>
<li><p>Xdebug Helper for Chrome</p>
<blockquote>
<p>Chrome的此扩展程序将帮助您通过一次点击启用/禁用调试和分析。 您可以在<a href="https://chrome.google.com/extensions/detail/eadndfjplgieldjbigjakmdgkmoaaaoc找到扩展程序。" target="_blank" rel="external">https://chrome.google.com/extensions/detail/eadndfjplgieldjbigjakmdgkmoaaaoc找到扩展程序。</a></p>
</blockquote>
</li>
<li><p>Xdebug Toggler for Safari</p>
<blockquote>
<p>Safari的这个扩展允许你从Safari中自动启动Xdebug调试。 你可以从Github <a href="https://github.com/benmatselby/xdebug-toggler获取它。" target="_blank" rel="external">https://github.com/benmatselby/xdebug-toggler获取它。</a></p>
</blockquote>
</li>
<li><p>Xdebug launcher for Opera</p>
<blockquote>
<p>这个扩展的Opera允许您从Opera启动Xdebug会话。</p>
</blockquote>
</li>
</ul>
<p>在你开始你的脚本之前，你需要告诉你的客户端它可以接收调试连接，请参考具体客户端的文档如何做到这一点。 要使用捆绑的客户端，只需在编译和安装后启动它。 您可以通过运行“debugclient”启动它。</p>
<p>当debugclient启动时，它将显示以下信息，然后等待，直到调试服务器启动连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Xdebug Simple DBGp client (0.10.0)</div><div class="line">Copyright 2002-2007 by Derick Rethans.</div><div class="line">- libedit support: enabled</div><div class="line"></div><div class="line">Waiting for debug server to connect.</div></pre></td></tr></table></figure></p>
<p>在建立连接后，将显示调试服务器的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Connect</div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;</div><div class="line">&lt;init xmlns=&quot;urn:debugger_protocol_v1&quot;</div><div class="line">      xmlns:xdebug=&quot;http://xdebug.org/dbgp/xdebug&quot;</div><div class="line">      fileuri=&quot;file:///home/httpd/www.xdebug.org/html/docs/index.php&quot;</div><div class="line">      language=&quot;PHP&quot;</div><div class="line">      protocol_version=&quot;1.0&quot;</div><div class="line">      appid=&quot;13202&quot;</div><div class="line">      idekey=&quot;derick&quot;&gt;</div><div class="line">  &lt;engine version=&quot;2.0.0RC4-dev&quot;&gt;&lt;![CDATA[Xdebug]]&gt;&lt;/engine&gt;</div><div class="line">  &lt;author&gt;&lt;![CDATA[Derick Rethans]]&gt;&lt;/author&gt;</div><div class="line">  &lt;url&gt;&lt;![CDATA[http://xdebug.org]]&gt;&lt;/url&gt;</div><div class="line">  &lt;copyright&gt;&lt;![CDATA[Copyright (c) 2002-2007 by Derick Rethans]]&gt;&lt;/copyright&gt;</div><div class="line">&lt;/init&gt;</div><div class="line">(cmd)</div></pre></td></tr></table></figure></p>
<p>现在，您可以使用DBGp文档页面中说明的命令集。 当脚本结束时，调试服务器与客户端断开连接，并且调试客户端在等待新连接时恢复。</p>
<h2 id="通讯建立"><a href="#通讯建立" class="headerlink" title="通讯建立"></a>通讯建立</h2><h3 id="使用静态IP-单个开发者"><a href="#使用静态IP-单个开发者" class="headerlink" title="使用静态IP /单个开发者"></a>使用静态IP /单个开发者</h3><p>通过远程调试，嵌入在PHP中的Xdebug就像客户端，而IDE作为服务器。 以下动画显示了通信通道的设置：</p>
<p><img src="https://xdebug.org/images/docs/dbgp-setup.gif" alt="img"></p>
<ul>
<li>服务器的IP是10.0.1.2，HTTP在端口80上</li>
<li>IDE在IP 10.0.1.42上，因此xdebug.remote_host设置为10.0.1.42</li>
<li>IDE侦听端口9000，因此xdebug.remote_port设置为9000</li>
<li>HTTP请求在运行IDE的计算机上启动</li>
<li>Xdebug连接到10.0.1.42:9000</li>
<li>调试运行，提供HTTP响应</li>
</ul>
<h3 id="与未知IP-多开发者"><a href="#与未知IP-多开发者" class="headerlink" title="与未知IP /多开发者"></a>与未知IP /多开发者</h3><p>如果使用xdebug.remote_connect_back，设置稍有不同：</p>
<p><img src="https://xdebug.org/images/docs/dbgp-setup2.gif" alt="img"></p>
<ul>
<li>服务器的IP是10.0.1.2，HTTP在端口80上</li>
<li>IDE处于未知IP，因此xdebug.remote_connect_back设置为1</li>
<li>IDE侦听端口9000，因此xdebug.remote_port设置为9000</li>
<li>发出HTTP请求后，Xdebug将从HTTP头中检测IP地址</li>
<li>Xdebug连接到端口9000上检测到的IP（10.0.1.42）</li>
<li>调试运行，提供HTTP响应</li>
</ul>
<h2 id="HTTP调试会话"><a href="#HTTP调试会话" class="headerlink" title="HTTP调试会话"></a>HTTP调试会话</h2><p>Xdebug包含通过浏览器启动时跟踪调试会话的功能：Cookie。 这是这样工作：</p>
<ul>
<li><p>当URL变量XDEBUG_SESSION_START = name附加到URL或通过具有相同名称的POST变量时，-Xdebug会发出名为“XDEBUG_SESSION”的cookie，并将值设置为XDEBUG_SESSION_START URL参数的值。 cookie的到期时间为1小时。 当连接到“idekey”属性中的debugclient时，DBGp协议也将此相同的值传递给init包。</p>
</li>
<li><p>当有一个GET（或POST）变量XDEBUG_SESSION_START或XDEBUG_SESSION cookie被设置时，Xdebug将尝试连接到一个调试客户端。</p>
</li>
<li><p>要停止调试会话（并销毁cookie），只需添加URL参数XDEBUG_SESSION_STOP即可。 Xdebug将不再尝试连接到调试客户端。</p>
</li>
</ul>
<h2 id="多用户调试"><a href="#多用户调试" class="headerlink" title="多用户调试"></a>多用户调试</h2><p>Xdebug仅允许您在执行远程调试时指定一个IP地址与xdebug.remote_host连接。它不会自动连接回浏览器运行的计算机的IP地址，除非您使用xdebug.remote_connect_back。</p>
<p>如果所有开发人员在同一（开发）服务器上的不同项目上工作，则可以通过Apache的.htaccess功能为每个目录设置xdebug.remote_host设置，方法是使用php_value xdebug.remote_host = 10.0.0.5。但是，对于多个开发人员在同一代码上工作的情况，.htaccess技巧不工作，因为代码所在的目录是相同的。</p>
<p>有两个解决方案。首先，你可以使用DBGp代理。有关如何使用此代理的概述，请参阅多个用户调试中的文章。您可以在ActiveState的网站上下载代理作为python远程调试包的一部分。 Komodo FAQ中还有一些文档。</p>
<p>其次，您可以使用Xdebug 2.1中引入的xdebug.remote_connect_back设置。</p>
<h2 id="实施细则"><a href="#实施细则" class="headerlink" title="实施细则"></a>实施细则</h2><p>Xdebug的DBGp协议的context_names命令的实现不依赖于栈级别。 在每个调试器会话期间返回的值总是相同的，因此，可以安全地缓存。</p>
<h2 id="相关的设置"><a href="#相关的设置" class="headerlink" title="相关的设置"></a>相关的设置</h2><h3 id="xdebug-extended-info"><a href="#xdebug-extended-info" class="headerlink" title="xdebug.extended_info"></a>xdebug.extended_info</h3><p>类型：整数，默认值：1</p>
<p>控制Xdebug是否应该为PHP解析器强制执行’extended_info’模式;这允许Xdebug使用远程调试器执行文件/行断点。当跟踪或剖析脚本时，通常希望关闭此选项，因为PHP生成的oparrays将增加大约三分之一的大小减慢脚本。此设置不能在带有ini_set（）的脚本中设置，但只能在php.ini中设置。</p>
<h3 id="xdebug-idekey"><a href="#xdebug-idekey" class="headerlink" title="xdebug.idekey"></a>xdebug.idekey</h3><p>类型：字符串，默认值：<em> complex </em></p>
<p>控制哪个IDE密钥Xdebug应该传递到DBGp调试器处理程序。默认值基于环境设置。首先查询环境设置DBGP_IDEKEY，然后查询USER和最后一个USERNAME。默认值设置为找到的第一个环境变量。如果找不到，则设置为默认的“”。如果设置此设置，它始终覆盖环境变量。</p>
<h3 id="xdebug-remote-addr-header"><a href="#xdebug-remote-addr-header" class="headerlink" title="xdebug.remote_addr_header"></a>xdebug.remote_addr_header</h3><p>类型：字符串，默认值：“”，在Xdebug&gt; 2.4中引入</p>
<p>如果xdebug.remote_addr_header配置为非空字符串，那么该值将用作$ SERVER超全局数组中的键，以确定用于查找用于“连接回”的IP地址或主机名的头。此设置仅与xdebug.remote_connect_back结合使用，否则将被忽略。</p>
<h3 id="xdebug-remote-autostart"><a href="#xdebug-remote-autostart" class="headerlink" title="xdebug.remote_autostart"></a>xdebug.remote_autostart</h3><p>类型：布尔值，默认值：0</p>
<p>通常，您需要使用特定的HTTP GET / POST变量来启动远程调试（请参阅远程调试）。当此设置设置为1时，Xdebug将始终尝试启动远程调试会话并尝试连接到客户端，即使GET / POST / COOKIE变量不存在。</p>
<h3 id="xdebug-remote-connect-back"><a href="#xdebug-remote-connect-back" class="headerlink" title="xdebug.remote_connect_back"></a>xdebug.remote_connect_back</h3><p>类型：boolean，默认值：0，在Xdebug&gt; 2.1中引入</p>
<p>如果启用，xdebug.remote_host设置将被忽略，Xdebug将尝试连接到发出HTTP请求的客户端。它检查$_SERVER [‘HTTP_X_FORWARDED_FOR’]和$_SERVER [‘REMOTE_ADDR’]变量以找出要使用的IP地址。</p>
<p>如果配置了xdebug.remote_addr_header，那么将在$_SERVER [‘HTTP_X_FORWARDED_FOR’]和$_SERVER [‘REMOTE_ADDR’]变量之前检查具有配置名称的$ SERVER变量。</p>
<p>此设置不适用于通过CLI进行调试，因为$ SERVER标题变量在那里不可用。</p>
<p>请注意，没有可用的过滤器，任何可以连接到Web服务器的人都能够启动调试会话，即使他们的地址与xdebug.remote_host不匹配。</p>
<h3 id="xdebug-remote-cookie-expire-time"><a href="#xdebug-remote-cookie-expire-time" class="headerlink" title="xdebug.remote_cookie_expire_time"></a>xdebug.remote_cookie_expire_time</h3><p>类型：整数，默认值：3600，在Xdebug&gt; 2.1中引入</p>
<p>此设置可用于增加（或减少）远程调试会话通过会话cookie保持活动的时间。</p>
<h3 id="xdebug-remote-enable"><a href="#xdebug-remote-enable" class="headerlink" title="xdebug.remote_enable"></a>xdebug.remote_enable</h3><p>类型：布尔值，默认值：0</p>
<p>此开关控制Xdebug是否应尝试联系正在侦听主机上的调试客户端，并使用设置xdebug.remote_host和xdebug.remote_port设置的端口。如果无法建立连接，脚本将继续，就像此设置为0。</p>
<h3 id="xdebug-remote-handler"><a href="#xdebug-remote-handler" class="headerlink" title="xdebug.remote_handler"></a>xdebug.remote_handler</h3><p>类型：字符串，默认值：dbgp</p>
<p>可以是“php3”选择旧的PHP 3式调试器输出，“gdb”启用GDB像调试器接口或’dbgp’ - 调试器协议。 DBGp协议是唯一支持的协议。</p>
<p>注意：Xdebug 2.1和更高版本只支持’db​​gp’作为协议。</p>
<h3 id="xdebug-remote-host"><a href="#xdebug-remote-host" class="headerlink" title="xdebug.remote_host"></a>xdebug.remote_host</h3><p>类型：字符串，默认值：localhost<br>选择运行调试客户端的主机，您可以使用主机名或IP地址。如果启用xdebug.remote_connect_back，将忽略此设置。</p>
<h3 id="xdebug-remote-log"><a href="#xdebug-remote-log" class="headerlink" title="xdebug.remote_log"></a>xdebug.remote_log</h3><p>类型：字符串，默认值：</p>
<p>如果设置为某个值，则将其用作所有远程调试器通信记录到的文件的文件名。 该文件始终以附加模式打开，因此默认情况下不会被覆盖。 没有可用的并发保护。 该文件的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Log opened at 2007-05-27 14:28:15</div><div class="line">-&gt; &lt;init xmlns=&quot;urn:debugger_protocol_v1&quot; xmlns:xdebug=&quot;http://xdebug.org/dbgp/x ... ight&gt;&lt;/init&gt;</div><div class="line"></div><div class="line">&lt;- step_into -i 1</div><div class="line">-&gt; &lt;response xmlns=&quot;urn:debugger_protocol_v1&quot; xmlns:xdebug=&quot;http://xdebug.org/db ... &gt;&lt;/response&gt;</div></pre></td></tr></table></figure></p>
<h3 id="xdebug-remote-mode"><a href="#xdebug-remote-mode" class="headerlink" title="xdebug.remote_mode"></a>xdebug.remote_mode</h3><p>类型：字符串，默认值：req</p>
<p>选择启动调试连接的时间。 此设置可以有两个不同的值：</p>
<ul>
<li><p>req</p>
<blockquote>
<p>一旦脚本启动，Xdebug将尝试连接到调试客户端。</p>
</blockquote>
</li>
<li><p>jit</p>
<blockquote>
<p>Xdebug只会在出现错误情况时尝试连接到调试客户端。</p>
</blockquote>
</li>
</ul>
<h3 id="xdebug-remote-port"><a href="#xdebug-remote-port" class="headerlink" title="xdebug.remote_port"></a>xdebug.remote_port</h3><p>类型：整数，默认值：9000</p>
<p>Xdebug尝试在远程主机上连接的端口。 端口9000是客户端和捆绑的debugclient的默认值。 由于许多客户端使用此端口号，最好保持此设置不变。</p>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="bool-xdebug-break（）"><a href="#bool-xdebug-break（）" class="headerlink" title="bool xdebug_break（）"></a>bool xdebug_break（）</h3><p>向调试客户端发出断点。</p>
<p>此函数使调试器在特定行上断开，就好像在此行上设置了正常的文件/行断点。</p>
<p>over~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xdebug为与运行PHP脚本交互的调试器客户端提供了一个接口。 本节介绍如何设置PHP和Xdebug来允许这一点，并介绍一些客户端。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
      <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Xdebug之PHP脚本剖析</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8BPHP%E8%84%9A%E6%9C%AC%E5%89%96%E6%9E%90/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug之PHP脚本剖析/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2016-11-29T02:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Xdebug内置分析器允许您在脚本中找到瓶颈，并使用外部工具（如KCacheGrind或WinCacheGrind）可视化这些瓶颈。</p>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Xdebug的Profiler是一个强大的工具，使您能够分析您的PHP代码并确定瓶颈，或者通常查看代码的哪些部分很慢，并可以使用速度提升。<br>Xdebug 2中的分析器以高速缓存磨削兼容文件的形式输出分析信息。这允许您使用优秀的KCacheGrind工具（Linux，KDE）来分析概要分析数据。</p>
<ul>
<li><p>如果你在Linux上，你可以安装KCacheGrind通过你最喜欢的包管理器。</p>
</li>
<li><p>如果你在Windows上，有预编译的QCacheGrind二进制文件可用。 （QCacheGrind是没有KDE绑定的KCacheGrind）。</p>
</li>
<li><p>如果你在Mac OSX上，还有如何构建QCacheGrind的说明。</p>
</li>
</ul>
<p>Windows的用户可以选择使用WinCacheGrind。该功能不同于KCacheGrind，因此在此页面上记录使用KCacheGrind的部分不适用于此程序。 WinCacheGrind目前不支持Xdebug 2.3引入的cachegrind文件的文件和函数压缩。</p>
<p>还有一个替代的配置文件信息呈现工具xdebugtoolkit，一个称为Webgrind的基于Web的前端，以及一个名为XCallGraph的基于Java的工具。</p>
<p>如果您不能使用KDE（或不想使用KDE），kcachegrind软件包也会附带一个perl脚本“ct_annotate”，该脚本从profiler跟踪文件生成ASCII输出。</p>
<h2 id="启动Profiler"><a href="#启动Profiler" class="headerlink" title="启动Profiler"></a>启动Profiler</h2><p>通过在php.ini中将xdebug.profiler_enable设置为1来启用分析。<br>这将指示Xdebug开始将分析信息写入使用xdebug.profiler_output_dir指令配置的转储目录。<br>生成的文件的名称始终以“cachegrind.out”开头。并以PHP（或Apache）进程的PID（进程ID）或包含最初调试的脚本的目录的crc32哈希结束。<br>请确保您的xdebug.profiler_output_dir中有足够的空间，因为分析器生成的信息量对于复杂脚本非常大，例如对于像eZ Publish这样的复杂应用程序，最多可以有500MB的空间。</p>
<p>您还可以选择性地启用分析器，将xdebug.profiler_enable_trigger设置为1.<br>如果设置为1，那么可以使用名为XDEBUG_PROFILE的GET / POST或COOKIE变量启用分析器。<br>可以用于启用调试器（请参阅HTTP调试会话）的FireFox 2扩展也可以与此设置一起使用。为了使触发器正常工作，xdebug.profiler_enable需要设置为0。</p>
<h2 id="分析Profiler"><a href="#分析Profiler" class="headerlink" title="分析Profiler"></a>分析Profiler</h2><p>生成配置文件信息文件后，可以使用 <a href="https://kcachegrind.github.io/" target="_blank" rel="external">KCacheGrind</a> 打开它：</p>
<p><img src="https://xdebug.org/images/docs/kc-open.png" alt="img"></p>
<p>一旦打开文件，您就可以在KCacheGrind的不同窗格中获得大量信息。在左侧，找到“Flat Profile”窗格，其中显示了脚本中按照此函数中的时间花费及其所有子项排序的所​​有函数。第二列“Self”显示此函数（没有其子项）的时间花费，第三列“Called”显示特定函数的调用频率，最后一列“Function”显示函数的名称。 Xdebug通过用“php ::”作为前缀来更改内部PHP函数名称，并且包含文件也以特殊方式处理。调用include（和include_one，require和require_once）后跟“::”和包含文件的文件名。在左边的截图中你可以看到“include :: / home / httpd / ez_34 / v …”，内部PHP函数的例子是“php :: mysql_query”。前两列中的数字可以是脚本的完整运行时间的百分比（如在示例中）或绝对时间（1单位是1 / 1,000,000秒）。您可以使用右侧显示的按钮在两种模式之间切换。</p>
<p><img src="https://xdebug.org/images/docs/kc-profile.png" alt="img"></p>
<p>右侧的窗格包含上窗格和下窗格。 上面的图显示了有关称为当前所选函数的函数的信息（“eztemplatedesignresource-&gt; executecompiledtemplate”）。下面的窗格显示当前所选函数调用的函数的信息。</p>
<p><img src="https://xdebug.org/images/docs/kc-right-call.png" alt="img"></p>
<p>上方窗格中的“成本”列显示从列表中的函数调用时当前所选函数的时间花费。 添加的“费用”列中的数字将始终为100％。 下方窗格中的“成本”列显示从列表中调用函数所花费的时间。 在添加此列表中的数字时，您很可能永远不会达到100％，因为所选的函数本身也需要时间来执行。</p>
<p><img src="https://xdebug.org/images/docs/kc-right-callers.png" alt="img"></p>
<p>“所有呼叫者”和“所有呼叫”选项卡不仅显示从其调用该函数的直接调用，而且还显示所有直接调用的函数调用，还显示函数调用更多级别上下调用。 左侧屏幕截图中的上部窗格显示了所有调用当前所选函数的函数，直接和间接地使用堆栈上它们之间的其他函数。 “距离”列显示列出的和当前选择的函数调用之间有多少个函数调用（-1）。 如果两个函数之间有不同的距离，则显示为一个范围（例如“5-24”）。 括号中的数字是中值距离。 下面的窗格是类似的，除了它显示从当前选择的函数调用的函数的信息，再次是直接或间接。</p>
<h2 id="相关的设置"><a href="#相关的设置" class="headerlink" title="相关的设置"></a>相关的设置</h2><h3 id="xdebug-profiler-append"><a href="#xdebug-profiler-append" class="headerlink" title="xdebug.profiler_append"></a>xdebug.profiler_append</h3><p>类型：整数，默认值：0</p>
<p>当此设置设置为1时，当新请求映射到同一文件时（不在xdebug.profiler_output_name设置上），将不会覆盖分析器文件，而是使用新配置文件附加文件。</p>
<h3 id="xdebug-profiler-enable"><a href="#xdebug-profiler-enable" class="headerlink" title="xdebug.profiler_enable"></a>xdebug.profiler_enable</h3><p>类型：整数，默认值：0</p>
<p>启用Xdebug的概要分析器，它在概要文件输出目录中创建文件。这些文件可以由KCacheGrind读取以可视化您的数据。<br>无法使用ini_set（）在脚本中设置此设置。如果要选择性地启用分析器，请将xdebug.profiler_enable_trigger设置为1，而不使用此设置。</p>
<h3 id="xdebug-profiler-enable-trigger"><a href="#xdebug-profiler-enable-trigger" class="headerlink" title="xdebug.profiler_enable_trigger"></a>xdebug.profiler_enable_trigger</h3><p>类型：整数，默认值：0</p>
<p>当此设置设置为1时，可以使用XDEBUG_PROFILE GET / POST参数触发剖析器文件的生成，或者设置名为XDEBUG_PROFILE的cookie。<br>这将然后将分析器数据写入定义的目录。为了防止profiler为每个请求生成概要文件文件，您需要将xdebug.profiler_enable设置为0.对触发器本身的访问可以通过xdebug.profiler_enable_trigger_value配置。</p>
<h3 id="xdebug-profiler-enable-trigger-value"><a href="#xdebug-profiler-enable-trigger-value" class="headerlink" title="xdebug.profiler_enable_trigger_value"></a>xdebug.profiler_enable_trigger_value</h3><p>类型：字符串，默认值：“”，在Xdebug&gt; 2.3中引入</p>
<p>此设置可用于限制谁可以使用xdebug.profiler_enable_trigger中概述的XDEBUG_PROFILE功能。当从空字符串的默认值更改时，cookie，GET或POST参数的值需要使用此设置匹配共享机密集，<br>以便分析器启动。</p>
<h3 id="xdebug-profiler-output-dir"><a href="#xdebug-profiler-output-dir" class="headerlink" title="xdebug.profiler_output_dir"></a>xdebug.profiler_output_dir</h3><p>类型：字符串，默认值：/ tmp</p>
<p>将写入分析器输出的目录，确保PHP将运行的用户具有对该目录的写入权限。无法使用ini_set（）在脚本中设置此设置。</p>
<h3 id="xdebug-profiler-output-name"><a href="#xdebug-profiler-output-name" class="headerlink" title="xdebug.profiler_output_name"></a>xdebug.profiler_output_name</h3><p>类型：字符串，默认值：cachegrind.out。％p</p>
<p>此设置确定用于将跟踪转储到的文件的名称。设置使用格式说明符指定格式，非常类似于sprintf（）和strftime（）。有几个格式说明符可以用于格式化文件名。</p>
<p>有关受支持的说明符，请参见 <a href="https://xdebug.org/docs/all_settings#trace_output_name" target="_blank" rel="external">xdebug.trace_output_name</a> 文档。</p>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="string-xdebug-get-profiler-filename（）"><a href="#string-xdebug-get-profiler-filename（）" class="headerlink" title="string xdebug get profiler filename（）"></a>string xdebug get profiler filename（）</h3><p>返回配置文件信息文件名</p>
<p>返回用于将配置文件信息保存到的文件的名称。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xdebug内置分析器允许您在脚本中找到瓶颈，并使用外部工具（如KCacheGrind或WinCacheGrind）可视化这些瓶颈。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
      <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
</feed>
