<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>行云流水</title>
  <subtitle>却也碎碎念念</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weizhimiao.github.io/"/>
  <updated>2017-03-09T08:57:13.000Z</updated>
  <id>https://weizhimiao.github.io/</id>
  
  <author>
    <name>zhimiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP中常见的密码处理方式与建议</title>
    <link href="https://weizhimiao.github.io/2017/02/22/PHP%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%86%E7%A0%81%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%BB%BA%E8%AE%AE/"/>
    <id>https://weizhimiao.github.io/2017/02/22/PHP中常见的密码处理方式与建议/</id>
    <published>2017-02-22T12:30:00.000Z</published>
    <updated>2017-03-09T08:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>密码安全的重要性我们就不用再去强调，随着在线攻击的增多，如果我们对密码没有进行合适的处理或做防御措施，我们的应用就会肯定会收到来自各方的威胁和攻击。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170223/QQTuPian20170223093340.png" alt="password"></p>
<p>所以作为开发者，我们需要对用户的密码做好预防措施。</p>
<a id="more"></a>
<h2 id="关于密码我们应该遵守的一些原则"><a href="#关于密码我们应该遵守的一些原则" class="headerlink" title="关于密码我们应该遵守的一些原则"></a>关于密码我们应该遵守的一些原则</h2><h3 id="绝对不能知道用户的密码"><a href="#绝对不能知道用户的密码" class="headerlink" title="绝对不能知道用户的密码"></a>绝对不能知道用户的密码</h3><ul>
<li>我们绝对不能知道用户的密码，也不能有获取用户密码的方式。</li>
<li><strong>知道的越少（包括我们开发者自己）越安全。</strong></li>
</ul>
<h3 id="绝对不去约束用户的密码"><a href="#绝对不去约束用户的密码" class="headerlink" title="绝对不去约束用户的密码"></a>绝对不去约束用户的密码</h3><ul>
<li><p>最好不要去约束密码的长度、格式等。</p>
</li>
<li><p>如果要求密码符合一个特定的模式，其实对于那些不怀好意的人也提供了攻击的途径。</p>
</li>
<li><p>如果必须要约束的话，建议只限制最小长度。并把常用的密码或基于字典创建的密码加入黑名单，也是一个好主意。</p>
</li>
</ul>
<h3 id="绝对不通过电子邮件发送用户的密码"><a href="#绝对不通过电子邮件发送用户的密码" class="headerlink" title="绝对不通过电子邮件发送用户的密码"></a>绝对不通过电子邮件发送用户的密码</h3><p>对于一个web应用来说，重置或修改密码时，我们应该在邮件里发送用于设定或修改密码的 <code>URL</code> 。而且这个<code>URL</code>中应该会包含一个唯一的令牌，这个令牌只能在设定或修改密码时使用一次。在设定或修改密码之后，我们就应该把这个令牌置为失效。</p>
<h2 id="使用-bcrypt-计算用户密码的哈希值"><a href="#使用-bcrypt-计算用户密码的哈希值" class="headerlink" title="使用 bcrypt 计算用户密码的哈希值"></a>使用 <code>bcrypt</code> 计算用户密码的哈希值</h2><blockquote>
<p>目前，通过大量的审查，最安全的哈希算法是 <code>bcrypt</code> 。</p>
</blockquote>
<p>首先，我们明确两个概念，哈希、加密。哈希和加密有什么区别？</p>
<ul>
<li><p>加密</p>
<blockquote>
<p>加密是双向算法，加密的数据之后通过解密还可以得到。</p>
</blockquote>
</li>
<li><p>哈希</p>
<blockquote>
<p>哈希是单向算法，哈希后的数据不能再还原成原始值。<br>哈希算法的用途，</p>
<ul>
<li>验证数据的完整性（要求算法速度快）</li>
<li>用户提高密码等需要单向验证的数据的安全性（要求安全性高，甚至故意要求时间慢）</li>
</ul>
</blockquote>
</li>
</ul>
<p>一般我们在数据库中保存的应该是计算出来的密码的哈希值。这样即使我们的数据库泄露了，他们也只能看到这些无意义的密码的哈希值。</p>
<p>哈希的算法有很多种，</p>
<ul>
<li><p><code>MD5</code></p>
<blockquote>
<p><code>MD5</code>即<code>Message-Digest Algorithm 5</code>（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有<code>MD5</code>实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，<code>MD5</code>的前身有<code>MD2</code>、<code>MD3</code>和<code>MD4</code>。</p>
</blockquote>
</li>
<li><p><code>SHA1</code></p>
<blockquote>
<p>安全哈希算法（<code>Secure Hash Algorithm</code>）主要适用于数字签名标准 （<code>Digital Signature Standard DSS</code>）里面定义的数字签名算法（<code>Digital Signature Algorithm DSA</code>）。对于长度小于<code>2^64</code>位的消息，<code>SHA1</code>会产生一个<code>160</code>位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 <code>SHA1</code>有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要,(但会有<code>1x10 ^ 48</code>分之一的机率出现相同的消息摘要,一般使用时忽略)。</p>
</blockquote>
</li>
<li><p><code>bcrypt</code></p>
<blockquote>
<p><code>bcrypt</code>是专门为密码存储而设计的算法，基于<code>Blowfish</code>加密算法变形而来，由<code>Niels Provos</code>和<code>David Mazières</code>发表于<code>1999</code>年的<code>USENIX</code>。　<code>bcrypt</code>最大的好处是有一个参数（<code>work factor</code>)，可用于调整计算强度，而且<code>work factor</code>是包括在输出的摘要中的。随着攻击者计算能力的提高，使用者可以逐步增大<code>work factor</code>，而且不会影响已有用户的登陆。　<code>bcrypt</code>经过了很多安全专家的仔细分析，使用在以安全著称的<code>OpenBSD</code>中，一般认为它比<code>PBKDF2</code>更能承受随着计算能力加强而带来的风险。<strong>bcrypt也有广泛的函数库支持，因此我们建议使用这种方式存储密码</strong>。</p>
</blockquote>
</li>
<li><p><code>scrypt</code></p>
<blockquote>
<p>scrypt不仅计算所需时间长，而且占用的内存也多，使得并行计算多个摘要异常困难，因此利用<code>rainbow table</code>进行暴力攻击更加困难。<strong>scrypt没有在生产环境中大规模应用，并且缺乏仔细的审察和广泛的函数库支持</strong> 。但是，<code>scrypt</code>在算法层面只要没有破绽，它的安全性应该高于<code>PBKDF2</code>和<code>bcrypt</code>。</p>
</blockquote>
</li>
</ul>
<p>目前，通过大量的审查，最安全的哈希算法是 <code>bcrypt</code> 。与 <code>MD5</code> 和 <code>SHA1</code> 不同， <code>bcrypt</code> 算法会自动加盐，来防止潜在的彩虹表攻击。 <code>bcrypt</code> 算法会花费大量的时间反复处理数据，来生成安全的哈希值。在这个过程中，处理数据的次数叫工作因子（<code>work factor</code>）。工作因子的值越高，破解密码哈希值的时间会成指数倍增长。</p>
<p><code>bcrypt</code> 算法永不过时，如果计算机的运算速度变快了，我们只需要提高工作因子即可。</p>
<p>顺带说一下，任何情况下尽可能的不要使用 <code>md5</code> 算法，至少也要使用 SHA 系列的哈希算法。因为<code>md5</code>算法以目前计算机的计算能力来说显得比较简单，而 <code>md5</code> 的性能优势现在也已经完全可以忽略不计了。</p>
<h2 id="密码哈希API"><a href="#密码哈希API" class="headerlink" title="密码哈希API"></a>密码哈希API</h2><p>上面我们说到 <code>bcrypt</code> 算法最安全，最适合对我们的密码进行哈希。 <code>PHP</code> 在 <code>PHP5.5.0+</code> 的版本中提供了原生的<code>密码哈希API</code>供我们使用，这个<code>密码哈希API</code>默认使用的就是 <code>bcrypt</code> 哈希算法，从而大大简化了我们计算密码哈希值和验证密码的操作。</p>
<h3 id="PHP原生密码哈希API"><a href="#PHP原生密码哈希API" class="headerlink" title="PHP原生密码哈希API"></a>PHP原生密码哈希API</h3><p>密码哈希函数：</p>
<ul>
<li><p><code>password_get_info</code></p>
<blockquote>
<p>返回指定的哈希值的相关信息</p>
</blockquote>
</li>
<li><p><code>password_hash</code></p>
<blockquote>
<p>创建密码的哈希（hash）</p>
</blockquote>
</li>
<li><p><code>password_needs_rehash</code></p>
<blockquote>
<p>检查给定的哈希是否与给定的选项匹配</p>
</blockquote>
</li>
<li><p><code>password_verify</code></p>
<blockquote>
<p>验证密码是否和哈希匹配</p>
</blockquote>
</li>
</ul>
<h4 id="password-get-info"><a href="#password-get-info" class="headerlink" title="password_get_info"></a>password_get_info</h4><p>说明<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">array</span> password_get_info ( string $hash )</div></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li><code>hash</code>, 一个由 password_hash() 创建的散列值。</li>
</ul>
<p>示例，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">var_dump(password_get_info($hash));</div><div class="line"><span class="comment">// Example</span></div><div class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</div><div class="line">  [<span class="string">"algo"</span>]=&gt;</div><div class="line">  int(<span class="number">1</span>)</div><div class="line">  [<span class="string">"algoName"</span>]=&gt;</div><div class="line">  string(<span class="number">6</span>) <span class="string">"bcrypt"</span></div><div class="line">  [<span class="string">"options"</span>]=&gt;</div><div class="line">  <span class="keyword">array</span>(<span class="number">1</span>) &#123;</div><div class="line">    [<span class="string">"cost"</span>]=&gt;</div><div class="line">    int(<span class="number">10</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="password-hash"><a href="#password-hash" class="headerlink" title="password_hash"></a>password_hash</h4><p><strong>说明</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string password_hash ( string $password , integer $algo [, <span class="keyword">array</span> $options ] )</div></pre></td></tr></table></figure></p>
<p>password_hash() 使用足够强度的单向散列算法创建密码的哈希（hash）。 password_hash() 兼容 crypt()。 所以， crypt() 创建的密码哈希也可用于 password_hash()。</p>
<p>当前支持的算法：</p>
<ul>
<li><p><code>PASSWORD_DEFAULT</code></p>
<blockquote>
<p>使用 <code>bcrypt</code> 算法 (PHP 5.5.0 默认)。 注意，该常量会随着 <code>PHP</code> 加入更新更高强度的算法而改变。 所以，使用此常量生成结果的长度将在未来有变化。 因此，数据库里储存结果的列可超过60个字符（最好是255个字符）。</p>
</blockquote>
</li>
<li><p><code>PASSWORD_BCRYPT</code></p>
<blockquote>
<p>使用 <code>CRYPT_BLOWFISH</code> 算法创建哈希。 这会产生兼容使用 “<code>$2y$</code>“ 的 crypt()。 结果将会是 60 个字符的字符串， 或者在失败时返回 <code>FALSE。</code></p>
</blockquote>
</li>
</ul>
<p>支持的选项：</p>
<ul>
<li><p><code>salt</code> - 手动提供哈希密码的盐值（<code>salt</code>）。这将避免自动生成盐值（<code>salt</code>）。</p>
<blockquote>
<p>省略此值后，password_hash() 会为每个密码哈希自动生成随机的盐值。这种操作是有意的模式。</p>
<p><strong>Warning 盐值（salt）选项从 PHP 7.0.0 开始被废弃（deprecated）了。 现在最好选择简单的使用默认产生的盐值。</strong></p>
</blockquote>
</li>
<li><p><code>cost</code> - 代表算法使用的 <code>cost</code>。crypt() 页面上有 <code>cost</code> 值的例子。</p>
<blockquote>
<p>省略时，默认值是 10。 这个 <code>cost</code> 是个不错的底线，但也许可以根据自己硬件的情况，加大这个值。</p>
</blockquote>
</li>
</ul>
<p><strong>参数</strong></p>
<ul>
<li><p><code>password</code>, 用户的密码。</p>
<blockquote>
<p> 使用 <code>PASSWORD_BCRYPT</code> 做算法，将使 <code>password</code> 参数最长为72个字符，超过会被截断。</p>
</blockquote>
</li>
<li><p><code>algo</code>, 一个用来在散列密码时指示算法的密码算法常量。</p>
</li>
<li><p><code>options</code>, 一个包含有选项的关联数组。目前支持两个选项：</p>
<ul>
<li><code>salt</code>，在散列密码时加的盐（干扰字符串），</li>
<li><code>cost</code>，用来指明算法递归的层数。这两个值的例子可在 crypt() 页面找到。<blockquote>
<p>省略后，将使用随机盐值与默认 <code>cost</code>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>示例</strong><br>示例1，使用默认算法哈希密码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 我们想要使用默认算法哈希密码</div><div class="line"> * 当前是 BCRYPT，并会产生 60 个字符的结果。</div><div class="line"> *</div><div class="line"> * 请注意，随时间推移，默认算法可能会有变化，</div><div class="line"> * 所以需要储存的空间能够超过 60 字（255字不错）</div><div class="line"> */</div><div class="line"><span class="keyword">echo</span> password_hash(<span class="string">"rasmuslerdorf"</span>, PASSWORD_DEFAULT).<span class="string">"\n"</span>;</div><div class="line"><span class="meta">?&gt;</span></div><div class="line"><span class="comment">// 输出类似于：</span></div><div class="line"><span class="comment">// $2y$10$.vGA1O9wmRjrwAVXD98HNOgsNpDczlqm3Jq7KnEd1rVAGv3Fykk1a</span></div></pre></td></tr></table></figure></p>
<p>示例2，手动设置 <code>cost</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 在这个案例里，我们为 BCRYPT 增加 cost 到 12。</div><div class="line"> * 注意，我们已经切换到了，将始终产生 60 个字符。</div><div class="line"> */</div><div class="line">$options = [</div><div class="line">    <span class="string">'cost'</span> =&gt; <span class="number">12</span>,</div><div class="line">];</div><div class="line"><span class="keyword">echo</span> password_hash(<span class="string">"rasmuslerdorf"</span>, PASSWORD_BCRYPT, $options).<span class="string">"\n"</span>;</div><div class="line"><span class="meta">?&gt;</span></div><div class="line"><span class="comment">// 输出类似于：</span></div><div class="line"><span class="comment">// $2y$12$QjSH496pcT5CEbzjD/vtVeH03tfHKFy36d4J0Ltp3lRtee9HDxY3K</span></div></pre></td></tr></table></figure></p>
<p>示例3，如何选择一个适合当前服务器的 cost</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 这个例子对服务器做了基准测试（benchmark），检测服务器能承受多高的 cost</div><div class="line"> * 在不明显拖慢服务器的情况下可以设置最高的值</div><div class="line"> * 8-10 是个不错的底线，在服务器够快的情况下，越高越好。</div><div class="line"> * 以下代码目标为  ≤ 50 毫秒（milliseconds），</div><div class="line"> * 适合系统处理交互登录。</div><div class="line"> */</div><div class="line">$timeTarget = <span class="number">0.05</span>; <span class="comment">// 50 毫秒（milliseconds）</span></div><div class="line"></div><div class="line">$cost = <span class="number">8</span>;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    $cost++;</div><div class="line">    $start = microtime(<span class="keyword">true</span>);</div><div class="line">    password_hash(<span class="string">"test"</span>, PASSWORD_BCRYPT, [<span class="string">"cost"</span> =&gt; $cost]);</div><div class="line">    $end = microtime(<span class="keyword">true</span>);</div><div class="line">&#125; <span class="keyword">while</span> (($end - $start) &lt; $timeTarget);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> <span class="string">"Appropriate Cost Found: "</span> . $cost . <span class="string">"\n"</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>输出类似于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Appropriate Cost Found: 10</div></pre></td></tr></table></figure></p>
<h4 id="password-needs-rehash"><a href="#password-needs-rehash" class="headerlink" title="password_needs_rehash"></a>password_needs_rehash</h4><p>说明<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean password_needs_rehash ( string $hash , integer $algo [, <span class="keyword">array</span> $options ] )</div></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li><code>hash</code>, 一个由 password_hash() 创建的散列值。</li>
<li><code>algo</code>, 一个用来在散列密码时指示算法的密码算法常量。</li>
<li><code>options</code>, 一个包含有选项的关联数组。目前支持两个选项：<ul>
<li><code>salt</code>，在散列密码时加的盐（干扰字符串），</li>
<li><code>cost</code>，用来指明算法递归的层数。这两个值的例子可在 crypt() 页面找到。</li>
</ul>
</li>
</ul>
<p>示例，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$password = <span class="string">'rasmuslerdorf'</span>;</div><div class="line">$hash = <span class="string">'$2y$10$YCFsG6elYca568hBi2pZ0.3LDL5wjgxct1N8w/oLR/jfHsiQwCqTS'</span>;</div><div class="line"></div><div class="line"><span class="comment">// cost 参数可随硬件的提升也不断提升</span></div><div class="line">$options = <span class="keyword">array</span>(<span class="string">'cost'</span> =&gt; <span class="number">11</span>);</div><div class="line"></div><div class="line"><span class="comment">// 使用纯文本密码 验证存储的散列</span></div><div class="line"><span class="keyword">if</span> (password_verify($password, $hash)) &#123;</div><div class="line">    <span class="comment">// 检查是否有更新的散列算法可用或 cost 是否已经改变</span></div><div class="line">    <span class="keyword">if</span> (password_needs_rehash($hash, PASSWORD_DEFAULT, $options)) &#123;</div><div class="line">        <span class="comment">// 如果是，请创建一个新的哈希值，并替换旧的哈希值</span></div><div class="line">        $newHash = password_hash($password, PASSWORD_DEFAULT, $options);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 用户登录验证完成</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="password-verify"><a href="#password-verify" class="headerlink" title="password_verify"></a>password_verify</h4><p>说明<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean password_verify ( string $password , string $hash )</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 password_hash() 返回的哈希包含了算法、 cost 和盐值。 因此，所有需要的信息都包含内。使得验证函数不需要储存额外盐值等信息即可验证哈希。</p>
</blockquote>
<p>参数</p>
<ul>
<li><code>password</code>, 用户的密码。</li>
<li><code>hash</code>, 一个由 password_hash() 创建的散列值。</li>
</ul>
<p>示例，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// 想知道以下字符从哪里来，可参见 password_hash() 的例子</span></div><div class="line">$hash = <span class="string">'$2y$07$BCryptRequires22Chrcte/VlQH0piJtjXl.0t1XkA8pw9dMXTpOq'</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (password_verify(<span class="string">'rasmuslerdorf'</span>, $hash)) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'Password is valid!'</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'Invalid password.'</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Password is valid!</div></pre></td></tr></table></figure></p>
<h3 id="PHP5-50-之前的密码哈希-API"><a href="#PHP5-50-之前的密码哈希-API" class="headerlink" title="PHP5.50 之前的密码哈希 API"></a>PHP5.50 之前的密码哈希 API</h3><p>安东尼·费拉拉（PHP原生密码哈希 API的开发者）为PHP5.5.0 以下的版本也提供了 <code>ircmaxell/password-compat</code>组件（<a href="https://packagist.org/packages/ircmaxell/password-compat）。" target="_blank" rel="external">https://packagist.org/packages/ircmaxell/password-compat）。</a></p>
<p>这个组件也实现了PHP密码哈希API中的所有函数，</p>
<ul>
<li><p><code>password_get_info</code></p>
</li>
<li><p><code>password_hash</code></p>
</li>
<li><p><code>password_needs_rehash</code></p>
</li>
<li><p><code>password_verify</code></p>
</li>
</ul>
<p>我们可以直接使用 <code>Composer</code> 把这个组件添加到我们的应用中就行了。例如，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer require ircmaxell/password-compat</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;密码安全的重要性我们就不用再去强调，随着在线攻击的增多，如果我们对密码没有进行合适的处理或做防御措施，我们的应用就会肯定会收到来自各方的威胁和攻击。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20170223/QQTuPian20170223093340.png&quot; alt=&quot;password&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以作为开发者，我们需要对用户的密码做好预防措施。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
      <category term="密码" scheme="https://weizhimiao.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
      <category term="哈希" scheme="https://weizhimiao.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计中的范式理论小结</title>
    <link href="https://weizhimiao.github.io/2017/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E8%8C%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
    <id>https://weizhimiao.github.io/2017/02/12/数据库设计中的范式理论/</id>
    <published>2017-02-12T10:30:00.000Z</published>
    <updated>2017-03-09T08:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>关系数据库中的关系必须满足一定的要求，数据库的设计范式简单的说就是数据库设计的规范。只有理解数据库的设计范式，才能设计出高效率、优雅的数据库。</p>
<a id="more"></a>
<h2 id="范式有哪些"><a href="#范式有哪些" class="headerlink" title="范式有哪些"></a>范式有哪些</h2><p>按照满足设计规范的不同程度,范式又被划分多个等级。目前，主要有六种范式：</p>
<ul>
<li>第一范式、</li>
<li>第二范式、</li>
<li>第三范式、</li>
<li>BC范式、</li>
<li>第四范式、</li>
<li>第五范式。</li>
</ul>
<p>他们的关系是，满足最低要求的叫第一范式，简称1NF。在第一范式基础上进一步满足一些要求的为第二范式，简称2NF。其余依此类推。</p>
<h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><blockquote>
<p>简单的说，即每一个属性都是原子项，不可分割。<br><strong>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值</strong></p>
</blockquote>
<p>1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。关系数据库设计研究的关系规范化是在1NF之上进行的。</p>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><blockquote>
<p>简单的说，第二范式要满足以下的条件：</p>
<ul>
<li>首先,要满足第一范式，</li>
<li>其次,每个非主属性要完全函数依赖与候选键，或者是主键。(即，<strong>数据库表中的每个实例或行必须可以被唯一地区分</strong>)</li>
</ul>
</blockquote>
<p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><blockquote>
<ul>
<li>首先要满足第二范式，</li>
<li>其次非主属性之间不存在函数依赖。(即，属性不依赖于其它非主属性)</li>
</ul>
</blockquote>
<p>简而言之，第三范式（3NF）要求 <strong>一个数据库表中不包含已在其它表中已包含的非主关键字信息</strong>。<br>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。<br>那么在其他的信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入其他的信息中。</p>
<p>简单的说：</p>
<ul>
<li>一范式就是属性不可分割。（属性就是表中的字段）</li>
<li>二范式就是要有主键，要求其他字段都依赖于主键。</li>
<li>三范式就是要消除传递依赖，方便理解，可以看做是“消除冗余”</li>
</ul>
<h2 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h2><p>反范式是通过增加冗余数据或数据分组来提高数据库读性能的过程。<br>在某些情况下， 反范式有助于掩盖关系型数据库软件的低效。<br>关系型的范式数据库即使做过优化， 也常常会带来沉重的访问负载。</p>
<h2 id="范式与反范式的选择"><a href="#范式与反范式的选择" class="headerlink" title="范式与反范式的选择"></a>范式与反范式的选择</h2><p>范式可以避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦，但是操作困难，因为需要联系多个表才能得到所需要数据，而且范式越高性能就会越差。要权衡是否使用更高范式是比较麻烦的。</p>
<p>但是，反范式数据模型与没有范式化的数据模型不同。 只有在范式化已经达到一定的满意水平并且所需的约束和规则都已经建立起来， 我们才进行反范式化。例如，所有的关系都属于第三范式， 连接的关系和多值依赖得到了妥善处理。</p>
<p>一般在项目中，用得最多的也就是第三范式，我认为使用到第三范式也就足够了，性能好而且方便管理数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关系数据库中的关系必须满足一定的要求，数据库的设计范式简单的说就是数据库设计的规范。只有理解数据库的设计范式，才能设计出高效率、优雅的数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
      <category term="范式" scheme="https://weizhimiao.github.io/tags/%E8%8C%83%E5%BC%8F/"/>
    
      <category term="反范式" scheme="https://weizhimiao.github.io/tags/%E5%8F%8D%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>keepalived实现Nginx双机高可用</title>
    <link href="https://weizhimiao.github.io/2017/02/11/keepalived%E5%AE%9E%E7%8E%B0%E5%8F%8C%E6%9C%BA%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>https://weizhimiao.github.io/2017/02/11/keepalived实现双机高可用/</id>
    <published>2017-02-11T14:30:00.000Z</published>
    <updated>2017-03-09T08:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Keepalived</code> 是一个基于<code>VRRP</code>协议来实现的<code>LVS</code>服务高可用方案，可以利用其来避免单点故障。一个<code>LVS</code>服务至少会有2台服务器运行<code>Keepalived</code>，一台为主服务器（<code>MASTER</code>），一台为备份服务器（<code>BACKUP</code>），但是对外表现为一个<code>虚拟IP</code>，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管<code>虚拟IP</code>，继续提供服务，从而保证服务的高可用性。</p>
<a id="more"></a>
<h2 id="keepalived的工作原理"><a href="#keepalived的工作原理" class="headerlink" title="keepalived的工作原理"></a><code>keepalived</code>的工作原理</h2><p><code>Keepalived</code>是 <code>VRRP</code> 的完美实现，因此在介绍 <code>keepalived</code> 之前，先介绍一下 <code>VRRP</code> 的原理。</p>
<h3 id="VRRP-简介"><a href="#VRRP-简介" class="headerlink" title="VRRP 简介"></a>VRRP 简介</h3><p><code>VRRP（Virtual Router Redundancy Protocol）</code>虚拟路由冗余协议,在 <code>VRRP</code> 中有两组重要的概念：</p>
<ul>
<li><p><code>VRRP</code> 路由器 和 虚拟路由器，</p>
<blockquote>
<ul>
<li><code>VRRP</code>路由器 是指运行<code>VRRP</code>的路由器，是物理实体，</li>
<li>虚拟路由器是指<code>VRRP</code>协议创建的，是逻辑概念。</li>
</ul>
<p>一组<code>VRRP</code>路由器协同工作，共同构成一台虚拟路由器。</p>
</blockquote>
</li>
<li><p>主控路由器 和 备份路由器。</p>
<blockquote>
<p><code>VRRP</code> 中存在着一种选举机制，用以选出提供服务的路由即主控路由，其他的则成了备份路由。当主控路由失效后，备份路由中会重新选举出一个主控路由，来继续工作，来保障不间断服务。</p>
</blockquote>
</li>
</ul>
<p>在现实的网络环境中，两台需要通信的主机大多数情况下并没有直接的物理连接。对于这样的情况，通常的解决方法有以下两种：</p>
<ul>
<li>在主机上使用动态路由协议(RIP、OSPF等)</li>
<li>在主机上配置静态路由</li>
</ul>
<p>很明显，在主机上配置动态路由是非常不切实际的，因为管理、维护成本以及是否支持等诸多问题。配置静态路由就变得十分流行，但路由器(或者说默认网关<code>default gateway</code>)却经常成为单点故障。<code>VRRP</code>的目的就是为了解决静态路由单点故障问题，<code>VRRP</code>通过一竞选(<code>election</code>)协议来动态的将路由任务交给<code>LAN</code>中虚拟路由器中的某台<code>VRRP</code>路由器。</p>
<h3 id="VRRP-工作流程"><a href="#VRRP-工作流程" class="headerlink" title="VRRP 工作流程"></a>VRRP 工作流程</h3><h4 id="1-初始化："><a href="#1-初始化：" class="headerlink" title="(1).初始化："></a>(1).初始化：</h4><p>路由器启动时，如果路由器的优先级是255(最高优先级，路由器拥有路由器地址)，要发送<code>VRRP</code>通告信息，并发送广播ARP信息通告路由器IP地址对应的MAC地址为路由虚拟MAC，设置通告信息定时器准备定时发送<code>VRRP</code>通告信息，转为<code>MASTER</code>状态；否则进入<code>BACKUP</code>状态，设置定时器检查定时检查是否收到<code>MASTER</code>的通告信息。</p>
<h4 id="2-Master"><a href="#2-Master" class="headerlink" title="(2).Master"></a>(2).Master</h4><ul>
<li>设置定时通告定时器；</li>
<li>用<code>VRRP</code> <code>虚拟MAC</code>地址响应路由器<code>IP</code>地址的<code>ARP</code>请求；</li>
<li>转发目的<code>MAC</code>是<code>VRRP</code>虚拟<code>MAC</code>的数据包；</li>
<li>如果是虚拟路由器<code>IP</code>的拥有者，将接受目的地址是虚拟路由器<code>IP</code>的数据包，否则丢弃；</li>
<li>当收到<code>shutdown</code>的事件时删除定时通告定时器，发送优先权级为0的通告包，转初始化状态；</li>
<li>如果定时通告定时器超时时，发送<code>VRRP</code>通告信息；</li>
<li>收到<code>VRRP</code>通告信息时，如果优先权为0，发送<code>VRRP</code>通告信息；否则判断数据的优先级是否高于本机，或相等而且实际<code>IP</code>地址大于本地实际<code>IP</code>，设置定时通告定时器，复位主机超时定时器，转<code>BACKUP</code>状态；否则的话，丢弃该通告包；</li>
</ul>
<h4 id="3-Backup"><a href="#3-Backup" class="headerlink" title="(3).Backup"></a>(3).Backup</h4><ul>
<li>设置主机超时定时器；</li>
<li>不能响应针对虚拟路由器<code>IP</code>的<code>ARP</code>请求信息；</li>
<li>丢弃所有目的<code>MAC</code>地址是虚拟路由器<code>MAC</code>地址的数据包；</li>
<li>不接受目的是虚拟路由器<code>IP</code>的所有数据包；</li>
<li>当收到<code>shutdown</code>的事件时删除主机超时定时器，转初始化状态；</li>
<li>主机超时定时器超时的时候，发送<code>VRRP</code>通告信息，广播<code>ARP</code>地址信息，转<code>MASTER</code>状态；</li>
<li>收到<code>VRRP</code>通告信息时，如果优先权为<code>0</code>，表示进入<code>MASTER</code>选举；否则判断数据的优先级是否高于本机，如果高的话承认<code>MASTER</code>有效，复位主机超时定时器；否则的话，丢弃该通告包；</li>
</ul>
<h3 id="ARP查询处理"><a href="#ARP查询处理" class="headerlink" title="ARP查询处理"></a>ARP查询处理</h3><p>ARP（Address Resolution Protocol），即地址解析协议。是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址.</p>
<p>所以当内部主机通过<code>ARP</code>查询虚拟路由器<code>IP</code>地址对应的<code>MAC</code>地址时，<code>MASTER</code>路由器回复的<code>MAC</code>地址为虚拟的<code>VRRP</code>的<code>MAC</code>地址，而不是实际网卡的 <code>MAC</code>地址，这样在路由器切换时让内网机器觉察不到；</p>
<p>而在路由器重新启动时，也不能主动发送本机网卡的实际<code>MAC</code>地址。如果虚拟路由器开启的ARP代理 (<code>proxy_arp</code>)功能，代理的<code>ARP</code>回应也回应<code>VRRP</code>虚拟MAC地址；</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="http://n.sinaimg.cn/games/3ece443e/20170207/ShiLiJiaGouShiYiTu.png" alt="示例架构示意图"></p>
<ul>
<li><code>Master</code> 和 <code>BackUp</code> 两台服务器作为负载均衡器，<code>BackUp</code> 为 <code>Master</code> 的热备份。</li>
<li><code>Node_x</code> 作为我们的业务机</li>
</ul>
<h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><ul>
<li><code>CentOS 6.8 X86_64</code></li>
<li><code>keepalived</code>、<code>ipvsadm</code>,实现 <code>Master</code> 和 <code>BackUp</code> 双机高可用。</li>
<li><code>Nginx</code>,在 <code>Master</code> 和 <code>BackUp</code> 上作为 7层负载均衡器，在 <code>Node_x</code> 节点作为 web 服务器来使用。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>1、同步各服务器的时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ntpdate 202.120.2.101</div></pre></td></tr></table></figure>
</li>
<li><p>2、网络设置</p>
<blockquote>
<ul>
<li><strong>Master</strong>：192.168.1.201</li>
<li><strong>BackUp</strong>：192.168.1.202</li>
<li><strong>Node_1</strong>：192.168.1.210</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>3、安装 <code>Nginx</code></li>
</ul>
<p>分别在 <code>Master</code>、<code>BackUp</code>、<code>Node_1</code>节点上安装 <code>Nginx</code>。</p>
<p>先安装<code>nginx</code>的<code>yum</code>源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm</div></pre></td></tr></table></figure></p>
<p>查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum info nginx</div></pre></td></tr></table></figure></p>
<p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install nginx</div></pre></td></tr></table></figure></p>
<ul>
<li>4、安装 <code>keepalived</code></li>
</ul>
<p>分别在 <code>Master</code>、<code>BackUp</code> 上安装 <code>keepalived</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y keepalived</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li><code>Master</code>、<code>BackUp</code> 节点上 <code>Nginx</code> 配置(负载均衡)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">cat /etc/nginx/conf.d/default.conf</div><div class="line">upstream app &#123;</div><div class="line">	server 192.168.1.210:80;</div><div class="line">  # server 192.168.1.xxx:80;</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  localhost;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">				proxy_pass http://app;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>Master</code>、<code>BackUp</code> 节点上分别启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service nginx start</div></pre></td></tr></table></figure></p>
<ul>
<li><code>Node_1</code> 节点上 <code>Nginx</code> 配置（web服务器）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cat /etc/nginx/conf.d/default.conf</div><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  localhost;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        root   /usr/share/nginx/html;</div><div class="line">        index  index.html index.htm;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>启动 <code>Nginx</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service nginx start</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>Master</code> 节点 <code>keepalived</code> 配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cat /etc/keepalived/keepalived.conf</div><div class="line">global_defs &#123;  </div><div class="line">    router_id NodeA  </div><div class="line">&#125;  </div><div class="line">vrrp_instance VI_1 &#123;  </div><div class="line">    state MASTER    #设置为主服务器  </div><div class="line">    interface eth0  #监测网络接口  </div><div class="line">    virtual_router_id 51  #主、备必须一样  </div><div class="line">    priority 100   #(主、备机取不同的优先级，主机值较大，备份机值较小,值越大优先级越高)  </div><div class="line">    advert_int 1   #VRRP Multicast广播周期秒数  </div><div class="line">    authentication &#123;  </div><div class="line">    auth_type PASS  #VRRP认证方式，主备必须一致  </div><div class="line">    auth_pass 1111   #(密码)  </div><div class="line"></div><div class="line">    virtual_ipaddress &#123;  </div><div class="line">        192.168.1.200/24  #VRRP HA虚拟地址  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>BackUp</code> 节点 <code>keepalived</code> 配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cat /etc/keepalived/keepalived.conf</div><div class="line">global_defs &#123;  </div><div class="line">    router_id NodeB  </div><div class="line">&#125;  </div><div class="line">vrrp_instance VI_1 &#123;  </div><div class="line">    state BACKUP    #设置为主服务器  </div><div class="line">    interface eth0  #监测网络接口  </div><div class="line">    virtual_router_id 51  #主、备必须一样  </div><div class="line">    priority 90   #(主、备机取不同的优先级，主机值较大，备份机值较小,值越大优先级越高)  </div><div class="line">    advert_int 1   #VRRP Multicast广播周期秒数  </div><div class="line">    authentication &#123;  </div><div class="line">    auth_type PASS  #VRRP认证方式，主备必须一致  </div><div class="line">    auth_pass 1111   #(密码)  </div><div class="line"></div><div class="line">    virtual_ipaddress &#123;  </div><div class="line">        192.168.1.200/24  #VRRP HA虚拟地址  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>分别启动主节点和备用节点的 <code>keepalived</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service keepalived start</div></pre></td></tr></table></figure></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul>
<li>1、分别查看 <code>keepalived</code> 、<code>Nginx</code> 是否启动</li>
</ul>
<p><strong><code>Nginx</code>:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# service nginx status</div><div class="line">nginx (pid  1185) 正在运行...</div></pre></td></tr></table></figure></p>
<p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ps aux | grep nginx</div><div class="line">root      1185  0.0  0.0   8596   740 ?        Ss   Feb06   0:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf</div><div class="line">nginx     1188  0.0  0.1   8600  1584 ?        S    Feb06   0:00 nginx: worker process                   </div><div class="line">root      2115  0.0  0.0   5724   548 pts/0    S+   Feb06   0:00 tail -f /var/log/nginx/access.log</div><div class="line">root      2635  0.0  0.0   6052   780 pts/2    S+   00:05   0:00 grep nginx</div></pre></td></tr></table></figure></p>
<p><strong><code>keepalived</code>:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# service keepalived status</div><div class="line">keepalived (pid  1925) 正在运行...</div></pre></td></tr></table></figure></p>
<p>或:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ps aux | grep keepalived</div><div class="line">root      1925  0.0  0.1  17200  1092 ?        Ss   Feb06   0:00 /usr/sbin/keepalived -D</div><div class="line">root      1927  0.0  0.2  17256  2584 ?        S    Feb06   0:00 /usr/sbin/keepalived -D</div><div class="line">root      1928  0.0  0.1  17256  1896 ?        S    Feb06   0:01 /usr/sbin/keepalived -D</div><div class="line">root      3553  0.0  0.0   6052   780 pts/2    S+   00:09   0:00 grep keepalived</div></pre></td></tr></table></figure></p>
<blockquote>
<p>为了确保稳定性，<code>keepalived</code> 守护程序分为3个不同的进程。父进程，负责监控两个子进程，两个子进程，一个负责<code>VRRP</code>框架，另一个负责健康检查。</p>
</blockquote>
<p>开启 <code>Master</code> 上 <code>keepalived</code> ,<code>Master</code> 会广播ARP消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# tail -f /var/log/messages</div><div class="line"></div><div class="line">Feb  7 04:50:06 localhost Keepalived[9864]: Starting Keepalived v1.2.13 (03/19,2015)</div><div class="line">Feb  7 04:50:06 localhost Keepalived[9865]: Starting Healthcheck child process, pid=9867</div><div class="line">Feb  7 04:50:06 localhost Keepalived[9865]: Starting VRRP child process, pid=9868</div><div class="line">Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Netlink reflector reports IP 192.168.1.201 added</div><div class="line">Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Netlink reflector reports IP fe80::a00:27ff:fe89:8c8 added</div><div class="line">Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Registering Kernel netlink reflector</div><div class="line">Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Registering Kernel netlink command channel</div><div class="line">Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Registering gratuitous ARP shared channel</div><div class="line">Feb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Netlink reflector reports IP 192.168.1.201 added</div><div class="line">Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Opening file &apos;/etc/keepalived/keepalived.conf&apos;.</div><div class="line">Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Configuration is using : 35102 Bytes</div><div class="line">Feb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Netlink reflector reports IP fe80::a00:27ff:fe89:8c8 added</div><div class="line">Feb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Registering Kernel netlink reflector</div><div class="line">Feb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Registering Kernel netlink command channel</div><div class="line">Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Using LinkWatch kernel netlink reflector...</div><div class="line">Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(10,11)]</div><div class="line">Feb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Opening file &apos;/etc/keepalived/keepalived.conf&apos;.</div><div class="line">Feb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Configuration is using : 5225 Bytes</div><div class="line">Feb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Using LinkWatch kernel netlink reflector...</div><div class="line">Feb  7 04:50:07 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Transition to MASTER STATE</div><div class="line">Feb  7 04:50:08 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Entering MASTER STATE</div><div class="line">Feb  7 04:50:08 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) setting protocol VIPs.</div><div class="line">Feb  7 04:50:08 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200</div><div class="line">Feb  7 04:50:08 localhost avahi-daemon[1013]: Registering new address record for 192.168.1.200 on eth0.IPv4.</div><div class="line">Feb  7 04:50:08 localhost Keepalived_healthcheckers[9867]: Netlink reflector reports IP 192.168.1.200 added</div><div class="line">Feb  7 04:50:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200</div></pre></td></tr></table></figure>
<p>同样，开启 <code>BackUp</code> 上 <code>keepalived</code> 时的日志信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# tail -f /var/log/messages</div><div class="line"></div><div class="line">Feb  7 04:40:45 localhost Keepalived[3771]: Starting Keepalived v1.2.13 (03/19,2015)</div><div class="line">Feb  7 04:40:45 localhost Keepalived[3772]: Starting Healthcheck child process, pid=3774</div><div class="line">Feb  7 04:40:45 localhost Keepalived[3772]: Starting VRRP child process, pid=3775</div><div class="line">Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: Netlink reflector reports IP 192.168.1.202 added</div><div class="line">Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: Netlink reflector reports IP fe80::a00:27ff:fec9:2d9 added</div><div class="line">Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: Registering Kernel netlink reflector</div><div class="line">Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: Registering Kernel netlink command channel</div><div class="line">Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: Registering gratuitous ARP shared channel</div><div class="line">Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: Opening file &apos;/etc/keepalived/keepalived.conf&apos;.</div><div class="line">Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Netlink reflector reports IP 192.168.1.202 added</div><div class="line">Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: Configuration is using : 35100 Bytes</div><div class="line">Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: Using LinkWatch kernel netlink reflector...</div><div class="line">Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(10,11)]</div><div class="line">Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Netlink reflector reports IP fe80::a00:27ff:fec9:2d9 added</div><div class="line">Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Registering Kernel netlink reflector</div><div class="line">Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Registering Kernel netlink command channel</div><div class="line">Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Opening file &apos;/etc/keepalived/keepalived.conf&apos;.</div><div class="line">Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Configuration is using : 5223 Bytes</div><div class="line">Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Using LinkWatch kernel netlink reflector...</div><div class="line">Feb  7 04:40:46 localhost Keepalived_vrrp[3775]: VRRP_Instance(VI_1) Transition to MASTER STATE</div><div class="line">Feb  7 04:40:46 localhost Keepalived_vrrp[3775]: VRRP_Instance(VI_1) Received higher prio advert</div><div class="line">Feb  7 04:40:46 localhost Keepalived_vrrp[3775]: VRRP_Instance(VI_1) Entering BACKUP STATE</div></pre></td></tr></table></figure></p>
<blockquote>
<p>在日志的最后三行，是 <code>keepalived</code> 选举 <code>Master状态</code> 的记录<br>在启动 BackUp 节点的 <code>keepalived</code> 时，Master 的日志中会新增如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Feb  7 04:50:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200</div><div class="line">Feb  7 04:51:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Received lower prio advert, forcing new election</div><div class="line">Feb  7 04:51:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200</div><div class="line">Feb  7 04:51:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Received lower prio advert, forcing new election</div><div class="line">Feb  7 04:51:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200</div><div class="line">Feb  7 04:54:26 localhost dhclient[9723]: parse_option_buffer: malformed option dhcp.x-display-manager (code 49): option length exceeds option buffer length.</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>2、通过浏览器（<code>192.168.1.100</code>） 访问 <code>http://192.168.1.200</code></li>
</ul>
<p>我们通过查看 <code>Node_1</code> 节点的 访问日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# tail -f /var/log/nginx/access.log</div><div class="line">192.168.1.201 - - [06/Feb/2017:22:51:27 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;</div></pre></td></tr></table></figure></p>
<p>发现 访问路径为 ： <code>浏览器（192.168.1.100）</code> –&gt; <code>Master(192.168.1.201)</code> –&gt; <code>Node_1(192.168.1.210)</code></p>
<p>这时我们 关闭 <code>Master</code>(<code>192.168.1.201</code>) 的网卡，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service network stop</div></pre></td></tr></table></figure></p>
<p>之后，再次通过 <code>浏览器（192.168.1.100）</code> 访问 <code>http://192.168.1.200</code>，再次查看 <code>Node_1</code> 节点的 访问日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# tail -f /var/log/nginx/access.log</div><div class="line">192.168.1.201 - - [06/Feb/2017:22:51:27 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;</div><div class="line">192.168.1.202 - - [06/Feb/2017:23:02:49 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;</div></pre></td></tr></table></figure></p>
<p>我们发现 访问路径已经切换成： <code>浏览器（192.168.1.100）</code> –&gt; <code>BackUp(192.168.1.202)</code> –&gt; <code>Node_1</code>(<code>192.168.1.210</code>)</p>
<p>再次开启，<code>Master(192.168.1.201)</code> 的网卡，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service network restart</div></pre></td></tr></table></figure></p>
<p>使用<code>浏览器（192.168.1.100）</code> 访问 <code>http://192.168.1.200</code>，<code>Node_1</code> 节点的 访问日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# tail -f /var/log/nginx/access.log</div><div class="line">192.168.1.201 - - [06/Feb/2017:23:02:27 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;</div><div class="line">192.168.1.202 - - [06/Feb/2017:23:02:49 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;</div><div class="line">192.168.1.201 - - [06/Feb/2017:23:03:46 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;</div></pre></td></tr></table></figure></p>
<p>访问路径有变回到， <code>浏览器（192.168.1.100）</code> –&gt; <code>BackUp(192.168.1.202)</code> –&gt; <code>Node_1(192.168.1.210)</code></p>
<p>至此，使用 <code>keepalived</code> 实现一个双机高可用的基本架构就算搭建完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Keepalived&lt;/code&gt; 是一个基于&lt;code&gt;VRRP&lt;/code&gt;协议来实现的&lt;code&gt;LVS&lt;/code&gt;服务高可用方案，可以利用其来避免单点故障。一个&lt;code&gt;LVS&lt;/code&gt;服务至少会有2台服务器运行&lt;code&gt;Keepalived&lt;/code&gt;，一台为主服务器（&lt;code&gt;MASTER&lt;/code&gt;），一台为备份服务器（&lt;code&gt;BACKUP&lt;/code&gt;），但是对外表现为一个&lt;code&gt;虚拟IP&lt;/code&gt;，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管&lt;code&gt;虚拟IP&lt;/code&gt;，继续提供服务，从而保证服务的高可用性。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="keepalived" scheme="https://weizhimiao.github.io/tags/keepalived/"/>
    
  </entry>
  
  <entry>
    <title>keepalived配置整理</title>
    <link href="https://weizhimiao.github.io/2017/02/11/keepalived%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2017/02/11/keepalived配置整理/</id>
    <published>2017-02-11T13:30:00.000Z</published>
    <updated>2017-03-09T08:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>keepalived只有一个配置文件 keepalived.conf ，里面主要包括以下几个配置区域，分别是</p>
<ul>
<li><p><strong>global_defs</strong></p>
<blockquote>
<p>主要是配置故障发生时的通知对象以及机器标识</p>
</blockquote>
</li>
<li><p>static_ipaddress</p>
<blockquote>
<p>配置的是是本节点的IP信息。（如果当前服务器上已经配置了IP，那么这这个区域可以不用配置）</p>
</blockquote>
</li>
<li><p>static_routes</p>
<blockquote>
<p>配置的是是本节点的路由信息。（如果当前服务器上已经配置了路由，那么这这个区域可以不用配置）</p>
</blockquote>
</li>
<li><p>vrrp_script</p>
<blockquote>
<p>用来做健康检查的，当时检查失败时会将<code>vrrp_instance</code>的<code>priority</code>减少相应的值。</p>
</blockquote>
</li>
<li><p><strong>vrrp_instance</strong></p>
<blockquote>
<p>用来定义对外提供服务的VIP区域及其相关属性。</p>
</blockquote>
</li>
<li><p>vrrp_sync_group</p>
<blockquote>
<p>用来定义<code>vrrp_intance</code>组，使得这个组内成员动作一致。</p>
</blockquote>
</li>
<li><p><strong>virtual_server</strong></p>
<blockquote>
<p>虚拟服务器，来源<code>vrrp_instance</code> 中配置的 的虚拟IP地址，后面加空格加端口号</p>
</blockquote>
</li>
<li><p>virtual_server_group</p>
<blockquote>
<p>用来定义<code>virtual_server</code> 组，一般在超大型的LVS中用到，一般LVS用不过这东西。</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h2 id="配置说明："><a href="#配置说明：" class="headerlink" title="配置说明："></a>配置说明：</h2><ul>
<li>注释以“＃”或“！”开头到行尾，可以从一行的任何位置开始。</li>
<li>关键字 <code>include</code> 允许在主配置文件中包含其他配置文件。</li>
<li>keepalived 还支持条件配置。(根据在启动 keepalived 时的命令行选项 -i 后面的参数，来确定指定命令是否生效)<blockquote>
<p>这样做的目的是允许单个配置文件用于多个系统，keepalived 中多个系统上的配置文件有区别的配置，可能只有以下几个配置，</p>
<ul>
<li>router_id，</li>
<li>vrrp实例优先级，</li>
<li>以及可能的接口名称。</li>
</ul>
</blockquote>
</li>
</ul>
<p>条件配置具体方法，示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">global_defs</div><div class="line">&#123;</div><div class="line">  @main router_id main_router</div><div class="line">  @backup router_id backup_router</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>以“@”开头的任何配置行都是条件配置行。 ‘@’字符紧接着的（即没有任何空格）字符串，会与使用 <code>-i</code> 命令行选项指定的字符串进行比较，如果不匹配匹配，则这条配置行被会被忽略。如，上面的配置，当使用 <code>/usr/local/keepalived/sbin/keepalived -f /etc/keepalived/keepalived.conf -i main</code> 启动 <code>keepalived</code> 时，则 <code>router_id</code> 将设置为 <code>main_router</code>。当使用 <code>-i backup</code> 参数启动时，则 <code>router_id</code> 将设置为 <code>backup_router</code>。</p>
<p><strong>注意</strong>：如果不使用 <code>-i</code> 或者 <code>-i</code> 后面是其他不匹配的参数启动时，则 <code>router_id</code> 将不会被设置。</p>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>包含的子块有，</p>
<ul>
<li>Global definitions，</li>
<li>static_ipaddress，</li>
<li>static_routes</li>
</ul>
<h3 id="Global-definitions"><a href="#Global-definitions" class="headerlink" title="Global definitions"></a>Global definitions</h3><h4 id="global-defs-区块"><a href="#global-defs-区块" class="headerlink" title="global_defs 区块"></a>global_defs 区块</h4><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">global_defs &#123;</div><div class="line">   # 故障发生时给谁发邮件通知。</div><div class="line">   notification_email &#123;</div><div class="line">     acassen@firewall.loc</div><div class="line">     # ....</div><div class="line">   &#125;</div><div class="line">   # 通知邮件从哪个地址发出。</div><div class="line">   notification_email_from Alexandre.Cassen@firewall.loc</div><div class="line">   smtp_server 192.168.200.1</div><div class="line">   smtp_connect_timeout 30</div><div class="line"></div><div class="line">   router_id LVS_DEVEL</div><div class="line"></div><div class="line">   vrrp_skip_check_adv_addr</div><div class="line">   vrrp_strict</div><div class="line">   vrrp_garp_interval 0</div><div class="line">   vrrp_gna_interval 0</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>notification_email 故障发生时给谁发邮件通知。</li>
<li>notification_email_from 通知邮件从哪个地址发出。</li>
<li><p>smtp_server 通知邮件的smtp地址。</p>
<blockquote>
<p>格式：smtp_server 127.0.0.1 [<port>] # 带可选端口号的IP地址或域名（默认为25）</port></p>
</blockquote>
</li>
<li><p>smtp_helo_name</p>
<blockquote>
<p>格式：smtp_helo_name <host_name> # 在HELO消息中使用的名称（默认为本地主机名）</host_name></p>
</blockquote>
</li>
<li><p>smtp_connect_timeout 连接smtp服务器的超时时间。</p>
</li>
<li>router_id 标识本节点的字条串，通常为hostname，但不一定非得是hostname。故障发生时，邮件通知会用到。</li>
</ul>
<ul>
<li>vrrp_mcast_group4 224.0.0.18 # 可选, 默认为 224.0.0.18</li>
<li>vrrp_mcast_group6 ff02::12   # 可选, 默认为 ff02::12</li>
<li><p>default_interface p33p1.3    # 设置静态地址的默认接口，默认为eth0</p>
</li>
<li><p>lvs_sync_daemon <interface> <vrrp_instance> [id <sync_id>] [maxlen <len>] [port <port>] [ttl <ttl>] [group <ip addr="">]</ip></ttl></port></len></sync_id></vrrp_instance></interface></p>
<blockquote>
<ul>
<li>＃绑定接口，vrrp实例  </li>
<li>＃syncid for lvs syncd</li>
<li>＃syncid（0 to 255）for lvs syncd</li>
<li>＃maxlen（1..65507）最大包长度</li>
<li>＃port（1..65535）要使用的UDP端口号</li>
<li>＃ttl（1..255）</li>
<li>＃group - 组播组地址（IPv4或IPv6）</li>
<li>＃注意：maxlen，port，ttl和group仅在Linux 4.3或更高版本上可用。</li>
</ul>
</blockquote>
</li>
<li><p>lvs_flush＃在启动时刷新任何现有的LVS配置</p>
</li>
<li><p>vrrp_garp_master_delay 10    # 秒，默认值5 ,0表示没有设置秒数</p>
<blockquote>
<p>在转换到MASTER之后的第二组ARP的延迟</p>
</blockquote>
</li>
<li><p>vrrp_garp_master_repeat 1    # default 5</p>
<blockquote>
<p>在转换到MASTER之后一次发送的ARP消息的数量</p>
</blockquote>
</li>
<li><p>vrrp_garp_lower_prio_delay 10</p>
<blockquote>
<p>当 MASTER 接收的较低优先级的 advert 延迟第二组ARP发送</p>
</blockquote>
</li>
<li><p>vrrp_garp_lower_prio_repeat 1</p>
<blockquote>
<p>当MASTER接收到较低优先级的广播之后，一次发送的RP消息的数量</p>
</blockquote>
</li>
<li><p>vrrp_garp_master_refresh 60  # secs, default 0 (no refreshing)</p>
<blockquote>
<p>MASTER 刷新<code>gratuitous ARPs</code>的最小时间间隔</p>
</blockquote>
</li>
<li><p>vrrp_garp_master_refresh_repeat 2 # default 1</p>
<blockquote>
<p>在 MASTER 状态时发送的<code>gratuitous ARPs</code>消息的数量</p>
</blockquote>
</li>
<li><p>vrrp_garp_interval 0.001          # decimal, seconds (resolution usecs). Default 0.</p>
<blockquote>
<p>接口发送的<code>gratuitous ARPs</code>的延迟时间（毫秒）</p>
</blockquote>
</li>
<li><p>vrrp_gna_interval 0.000001        # decimal, seconds (resolution usecs). Default 0.</p>
<blockquote>
<p>接口发送的 主动NA消息 之间的延迟（ms）</p>
</blockquote>
</li>
<li><p>vrrp_lower_prio_no_advert [<bool>]</bool></p>
<blockquote>
<p>如果收到较低优先级的广告，请不要发送另一个广告。 默认为false，除非设置了strict_mode。</p>
</blockquote>
</li>
<li><p>vrrp_version <2 3="" or="">        # default version 2</2></p>
<blockquote>
<p>设置要使用的默认VRRP版本</p>
</blockquote>
</li>
<li><p>vrrp_iptables keepalived     # default INPUT</p>
<blockquote>
<ul>
<li>＃指定 iptables链 以确保版本3实例不对其不拥有的地址做出响应。</li>
<li>＃注意：指定的 链 必须存在于 <code>iptables</code>/<code>ip6tables</code>配置中，并且链从<code>iptables</code>配置中的适当点调用。</li>
<li>＃可能需要在接受任何<code>ESTABLISHED</code>，<code>RELATED</code>数据包之后进行此过滤，因为<code>IPv4</code>可能选择<code>VIP</code>作为传出连接的源地址。</li>
</ul>
</blockquote>
</li>
<li><p>vrrp_iptables keepalived_in keepalived_out</p>
<blockquote>
<ul>
<li>＃或用于出站过滤</li>
<li>＃注意，出站过滤将不适用于IPv4，因为可以选择VIP作为出站连接的源地址。 对于IPv6，由于地址已过时，因此不太可能。</li>
</ul>
</blockquote>
</li>
<li><p>vrrp_iptables</p>
<blockquote>
<p>或者不添加任何iptables规则：</p>
</blockquote>
</li>
<li><p>vrrp_ipset [keepalived [keepalived6 [keepalived_if6]]]</p>
<blockquote>
<ul>
<li>＃Keepalived可以选择使用iptables结合使用ipetsets。</li>
<li>＃如果是这样，那么可以指定 ipset 名称，默认如下。</li>
<li>＃如果未指定名称，则不使用 ipsets，否则将通过向先前指定的名称添加“<code>_if</code>”和/或“<code>6</code>”来构造任何省略的名称。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>vrrp_check_unicast_src<blockquote>
<p>＃以下启用检查在单播模式下，VRRP数据包的源地址是我们的单播对等体之一。</p>
</blockquote>
</li>
</ul>
<ul>
<li>vrrp_skip_check_adv_addr     # Default - don’t skip<blockquote>
<ul>
<li>＃查看接收到的VRRP报文中的所有地址可能比较耗时。</li>
<li>＃设置此标志表示如果广告来自与接收的上一个广告相同的主路由器，则不执行检查。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>vrrp_strict<blockquote>
<p>＃严格遵守VRRP协议。 这将禁止：</p>
<ul>
<li>0 VIPs</li>
<li>unicast peers (单播对等体)</li>
<li>IPv6 addresses in VRRP version 2(VRRP版本2中的IPv6地址)</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<p>如果vrrp或检查程序超时，则可以使用以下4个选项。 这可以通过备份vrrp实例成为主，即使是因为主或备份系统太忙，无法处理vrrp数据包，但主服务器仍然运行的情况。</p>
<ul>
<li>vrrp_priority &lt;-20 to 19&gt;    # 设置vrrp子进程优先级 。 （负值增加优先级）</li>
<li>checker_priority &lt;-20 to 19&gt; # 设置 子进程检查器优先级</li>
<li>vrrp_no_swap                 # 设置vrrp子进程不可交换</li>
<li>checker_no_swap              # 设置 子进程检查器不可交换</li>
</ul>
<hr>
<p>如果 <code>Keepalived</code> 已构建与SNMP支持，以下关键字可用</p>
<blockquote>
<p>注意：Keepalived, checker 和 RFC支持 可以单独启用/禁用</p>
</blockquote>
<ul>
<li>snmp_socket udp:1.2.3.4:705  # 指定用于连接到SNMP主代理的套接字（默认<code>unix:/var/agentx/master</code>）<pre><code># 除非使用网络命名空间，默认为udp：`udp:localhost:705`
</code></pre></li>
<li>enable_snmp_keepalived       # 启用SNMP处理KEEPALIVED MIB的vrrp元素</li>
<li>enable_snmp_checker          # 启用SNMP处理KEEPALIVED MIB的checker元素</li>
<li>enable_snmp_rfc              # 启用SNMP处理 RFC2787 和 RFC6527 VRRP MIB</li>
<li>enable_snmp_rfcv2            # 启用SNMP处理 RFC2787 VRRP MIB</li>
<li>enable_snmp_rfcv3            # 启用SNMP处理 RFC6527 VRRP MIB</li>
<li>enable_traps                 # 启用SNMP陷阱</li>
</ul>
<hr>
<p>如果Keepalived已构建与DBus支持，以下关键字可用</p>
<ul>
<li><p>enable_dbus                  # 启用DBus接口</p>
</li>
<li><p>script_user username [groupname] # 如果未指定groupname，则其默认为用户的组</p>
<blockquote>
<ul>
<li>＃指定要在其下运行脚本的默认<code>用户名</code>/<code>组名</code>。</li>
<li>＃如果未指定此选项，则用户默认为 <code>keepalived_script</code>（如果该用户存在），否则为<code>root</code>。</li>
</ul>
</blockquote>
</li>
<li><p>enable_script_security       # 如果非必要，请不要配置为以<code>root</code>身份运行的脚本。</p>
</li>
</ul>
<h4 id="其它全局配置"><a href="#其它全局配置" class="headerlink" title="其它全局配置"></a>其它全局配置</h4><ul>
<li>net_namespace NAME         # 用于在单独的网络命名空间中运行keepalived<blockquote>
<ul>
<li>＃设置运行的网络命名空间<code>/var/run/keepalived</code>目录将创建为非共享挂载点，例如pid文件。</li>
<li>syslog条目将<code>_NAME</code>附加到 <code>ident</code>。<br><strong>注意：</strong> 不能在配置重新加载时更改命名空间</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>namespace_with_ipsets        </p>
<blockquote>
<p>＃<code>Linux 3.13</code>之前，网络命名空间找不到 <code>ipetsets</code> ，因此如果运行在早期版本的内核，默认情况下，如果使用命名空间和<code>vrrp_ipsets</code>没有指定， <code>ipsets</code> 是被禁用的。 此选项覆盖默认值，并允许将 <code>ipsets</code> 与 <code>3.11</code> 之前的内核上的命名空间一起使用。</p>
</blockquote>
</li>
<li><p>instance NAME               </p>
<blockquote>
<p>＃如果 <code>keepalived</code> 的多个实例在同一命名空间中运行，这将创建 pid 文件，其中 NAME 是文件名的一部分，在<code>/var/run/keepalived</code>中。</p>
<p>注意：不能在配置重新加载时更改实例名称</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>use_pid_dir              # 在 <code>/var/run/keepalived</code> 创建 <code>pid</code> 文件</p>
</li>
<li><p>linkbeat_use_polling         # 轮询检测媒体链路故障，否则尝试使用 <code>ETHTOOL</code> 或 <code>MII</code> 接口</p>
</li>
</ul>
<h3 id="Static-routes-addresses-rules"><a href="#Static-routes-addresses-rules" class="headerlink" title="Static routes/addresses/rules"></a>Static routes/addresses/rules</h3><p>Keepalived可以配置静态地址，路由和规则。 如果我们的计算机上已有IP和路由，并且可以互相ping通，则不需要此部分。<br>规则和路由的语法与<code>ip rule add/ip route add</code>相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static_ipaddress</div><div class="line">&#123;</div><div class="line">        192.168.1.1/24 dev eth0 scope global</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static_routes</div><div class="line">&#123;</div><div class="line">  192.168.2.0/24 via 192.168.1.100 dev eth0</div><div class="line">  192.168.100.0/24 table 6909 nexthop via 192.168.101.1 dev wlan0 onlink weight 1  nexthop  via  192.168.101.2  dev  wlan0 onlink weight 2</div><div class="line">  192.168.200.0/24  dev  p33p1.2 table 6909 tos 0x04 protocol bird scope link priority 12 mtu 1000 hoplimit 100 advmss 101 rtt 102 rttvar 103 reordering 104 window 105 cwnd 106 ssthresh lock 107 realms PQA/0x14 rto_min 108 initcwnd 109 initrwnd 110 features ecn</div><div class="line">  2001:470:69e9:1:2::4  dev  p33p1.2 table 6909 tos 0x04 protocol bird scope link priority 12 mtu 1000 hoplimit 100 advmss 101 rtt 102 rttvar 103 reordering 104 window 105 cwnd 106 ssthresh lock 107 rto_min 108 initcwnd 109  initrwnd  110  features ecn</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static_rules</div><div class="line">&#123;</div><div class="line">  from 192.168.2.0/24 table 1</div><div class="line">  to 192.168.2.0/24 table 1</div><div class="line">  from  192.168.28.0/24  to 192.168.29.0/26 table small iif p33p1 oif wlan0 tos 22 fwmark 24/12 preference 39 realms 30/20 goto 40</div><div class="line">  to 1:2:3:4:5:6:7:0/112 from 7:6:5:4:3:2::/96 table 6908</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="VRRPD配置"><a href="#VRRPD配置" class="headerlink" title="VRRPD配置"></a>VRRPD配置</h2><p>包含的子块有，</p>
<ul>
<li>VRRP script(s),VRRP脚本</li>
<li>VRRP synchronization group(s), VRRP同步组</li>
<li>VRRP gratuitous ARP ,</li>
<li>unsolicited neighbour advert delay group(s), 主动邻居广播延迟组</li>
<li>VRRP instance(s),VRRP实例</li>
</ul>
<h3 id="VRRP-script-s"><a href="#VRRP-script-s" class="headerlink" title="VRRP script(s)"></a>VRRP script(s)</h3><p>添加要定期执行的脚本。 VRRP instances 会根据 脚本的退出码来调整优先级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">vrrp_script &lt;SCRIPT_NAME&gt; &#123;</div><div class="line">  script &lt;STRING&gt;|&lt;QUOTED-STRING&gt; # 脚本的路径执行</div><div class="line">  interval &lt;INTEGER&gt;  # 脚本调用之间的间隔，默认1秒</div><div class="line">  timeout &lt;INTEGER&gt;   # 脚本运行超时时间</div><div class="line">  weight &lt;INTEGER:-254..254&gt;  # 按此权重调整优先级，默认为2</div><div class="line">  rise &lt;INTEGER&gt;              # 转换为OK状态，所需的成功数量</div><div class="line">  fall &lt;INTEGER&gt;              # 转换为KO状态，所需的成功数量</div><div class="line">  user USERNAME [GROUPNAME]   # 运行脚本的 用户/组名 （组默认为用户组）</div><div class="line">  init_fail                   # 假设脚本最初处于失败状态</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="VRRP-synchronization-group-s-，VRRP同步组"><a href="#VRRP-synchronization-group-s-，VRRP同步组" class="headerlink" title="VRRP synchronization group(s)，VRRP同步组"></a>VRRP synchronization group(s)，VRRP同步组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#VG_1, 一起故障转移的IP组的名称</div><div class="line">vrrp_sync_group VG_1 &#123;</div><div class="line">   group &#123;</div><div class="line">     inside_network   # vrrp_instance的名称（见下文）</div><div class="line">     outside_network  # One for each movable IP</div><div class="line">     ...</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   # 通知脚本和警报（可选）</div><div class="line">   #</div><div class="line">   ＃filenames的脚本在转换时运行，可以不加引号（如果只是文件名）或加引号（如果它有参数）用户名和组名指定脚本应该运行的用户和组。</div><div class="line">   ＃如果指定了username，则组默认为用户的组。</div><div class="line">   ＃如果未指定username，则它们默认为全局 script_user 和 script_group 到 MASTER 转换</div><div class="line"></div><div class="line">   notify_master /path/to_master.sh [username [groupname]]</div><div class="line">   # 转换成 BACKUP 状态</div><div class="line">   notify_backup /path/to_backup.sh [username [groupname]]</div><div class="line">   # 转换成 FAULT</div><div class="line">   notify_fault &quot;/path/fault.sh VG_1&quot; [username [groupname]]</div><div class="line"></div><div class="line">   # for ANY state transition.</div><div class="line">   # &quot;notify&quot; script is called AFTER the</div><div class="line">   # notify_* script(s) and is executed</div><div class="line">   # with 3 arguments provided by Keepalived</div><div class="line">   # (so don’t include parameters in the notify line).</div><div class="line">   # arguments</div><div class="line"></div><div class="line">   ＃ 对于任何状态的转换。</div><div class="line">   ＃ “notify”脚本在 notify_* 脚本之后调用，并使用 Keepalived 提供的3个参数执行（不包括通知行中的参数）。</div><div class="line">   ＃ 参数：</div><div class="line">   #    $1 = &quot;GROUP&quot;|&quot;INSTANCE&quot;</div><div class="line">   #    $2 = 组或实例的名称</div><div class="line">   #    $3 = 转型目标状态 (&quot;MASTER&quot;|&quot;BACKUP&quot;|&quot;FAULT&quot;)</div><div class="line">   notify /path/notify.sh [username [groupname]]</div><div class="line"></div><div class="line">   # 在状态转换期间使用global_defs中的地址发送电子邮件通知。</div><div class="line">   smtp_alert</div><div class="line"></div><div class="line">   global_tracking     # 所有VRRP共享相同的跟踪配置</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="VRRP-gratuitous-ARP-and-unsolicited-neighbour-advert-delay-group-s"><a href="#VRRP-gratuitous-ARP-and-unsolicited-neighbour-advert-delay-group-s" class="headerlink" title="VRRP gratuitous ARP and unsolicited neighbour advert delay group(s)"></a>VRRP gratuitous ARP and unsolicited neighbour advert delay group(s)</h3><p>指定发送 gratuitous ARPs 和未经请求的邻居 advert 的延迟的设置。 这是为了防止上游交换机无法处理 ARPs/NAs 泛滥。</p>
<ul>
<li>当限制适用于单个物理接口时使用接口。</li>
<li>当一组接口链接到同一交换机时使用接口，则限制适用于整个交换机。</li>
</ul>
<p>如果设置了全局<code>vrrp_garp_interval</code>或<code>vrrp_gna_interval</code>，那么在<code>garp_group</code>中未指定的任何接口时，将继承全局设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">garp_group &#123;</div><div class="line">  # 设置免费ARP之间的间隔（以秒，微秒为单位）</div><div class="line">  garp_interval &lt;DECIMAL&gt;</div><div class="line">  # 设置非请求 NA 之间的默认间隔（以秒，微秒为单位）</div><div class="line">  gna_interval &lt;DECIMAL&gt;</div><div class="line">  # 应用间隔的物理接口</div><div class="line">  interface &lt;STRING&gt;</div><div class="line">  # 聚合延迟的接口列表。</div><div class="line">  interfaces &#123;</div><div class="line">     &lt;STRING&gt;</div><div class="line">     &lt;STRING&gt;</div><div class="line">     ...</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="VRRP-instance-s"><a href="#VRRP-instance-s" class="headerlink" title="VRRP instance(s)"></a>VRRP instance(s)</h3><p>描述了<code>vrrp_sync_group</code>中组的每个实例的IP。 这里描述两个IP（在<code>inside_network</code>和在<code>outer_network</code>），在机器“<code>my_hostname</code>”，属于组<code>VG_1</code>并且将在任何状态更改时一起转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div></pre></td><td class="code"><pre><div class="line"># 除inside_network外，还需要为outer_network编写另一个块。</div><div class="line">vrrp_instance inside_network &#123;</div><div class="line">  # 初始状态，MASTER | BACKUP</div><div class="line">  # 一旦其他机器启动，将进行选举，具有最高优先级的机器将变为MASTER。</div><div class="line">  # 所以这里的配置并不重要。</div><div class="line">  state MASTER</div><div class="line"></div><div class="line">  # 为 inside_network 配置网络接口, 由 vrrp 绑定</div><div class="line">  interface eth0</div><div class="line"></div><div class="line">  # 使用VRRP虚拟MAC。</div><div class="line">  use_vmac [&lt;VMAC_INTERFACE&gt;]</div><div class="line"></div><div class="line">  # 从基本接口（而不是VMAC接口）发送/恢复VRRP消息</div><div class="line">  vmac_xmit_base</div><div class="line"></div><div class="line">  native_ipv6         # 强制实例使用IPv6（混合IPv4和IPv6配置时）。</div><div class="line"></div><div class="line">  # 忽略VRRP接口故障（默认未设置）</div><div class="line">  dont_track_primary</div><div class="line"></div><div class="line">  # 可选，监视</div><div class="line">  # 如果任何一个下降，进入FAULT状态。</div><div class="line">  track_interface &#123;</div><div class="line">    eth0</div><div class="line">    eth1</div><div class="line">    eth2 weight &lt;-254..254&gt;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  # 向接口添加跟踪脚本（&lt;SCRIPT_NAME&gt;是vrrp_script条目的名称）</div><div class="line">  track_script &#123;</div><div class="line">      &lt;SCRIPT_NAME&gt;</div><div class="line">      &lt;SCRIPT_NAME&gt; weight &lt;-254..254&gt;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  # 默认 vrrpd 绑定的 IP 是接口上的主 IP 。 （可选的）</div><div class="line">  # 如果要隐藏 vrrpd 的位置，请将此 IP 当做 src_addr 用于组播或单播 vrrp 数据包。 （</div><div class="line">  # 因为它是多播，vrrpd 将获得答复数据包，无论使用什么 src_addr ）。</div><div class="line">  mcast_src_ip &lt;IPADDR&gt;</div><div class="line">  unicast_src_ip &lt;IPADDR&gt;</div><div class="line"></div><div class="line">  version &lt;2 or 3&gt;            # VRRP版本在接口上运行</div><div class="line">                              # default是全局参数vrrp_version。</div><div class="line"></div><div class="line">  # 不要通过 VRRP 组播组发送 VRRP adverts</div><div class="line">  # 相反，它使用单播将 adverts 发送到以下IP地址列表。 在不支持多播的网络环境中使用VRRP FSM和功能可能很酷！</div><div class="line">  # 指定的IP地址可以是IPv4和IPv6。</div><div class="line">  unicast_peer &#123;</div><div class="line">    &lt;IPADDR&gt;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  # 接口特定设置，与全局参数相同; 默认为全局参数</div><div class="line">  garp_master_delay 10</div><div class="line">  garp_master_repeat 1</div><div class="line">  garp_lower_prio_delay 10</div><div class="line">  garp_lower_prio_repeat 1</div><div class="line">  garp_master_refresh 60</div><div class="line">  garp_master_refresh_repeat 2</div><div class="line">  garp_interval 100</div><div class="line">  gna_interval 100</div><div class="line"></div><div class="line">  lower_prio_no_advert [&lt;BOOL&gt;]</div><div class="line"></div><div class="line">  # 从0到255的任意唯一编号，用于区分在同一NIC（和相同的套接字）上运行的vrrpd的多个实例。</div><div class="line">  virtual_router_id 51</div><div class="line"></div><div class="line">  # 用于选择MASTER，最高优先级的会被选举出来。</div><div class="line">  # 超过50个以上的其它机器的设置，会被选为 MASTER</div><div class="line">  priority 100</div><div class="line"></div><div class="line">  # VRRP广告间隔（以秒为单位）（例如0.92）（使用默认值）</div><div class="line">  advert_int 1</div><div class="line"></div><div class="line">  # 注意：在2004年，RFC3768 从 VRRPv2 规范中删除了身份验证。</div><div class="line">  # 此选项的使用不符合规定，可能会导致问题;</div><div class="line">  # 所以尽可能避免使用，除非使用单播。</div><div class="line">  authentication &#123;     # 验证块</div><div class="line">      # PASS||AH</div><div class="line">      #   PASS - 简单密码（建议）</div><div class="line">      #   AH - IPSEC（不推荐）</div><div class="line">      auth_type PASS</div><div class="line">      # 访问vrrpd的密码。</div><div class="line">      # 应在所有机器上相同。</div><div class="line">      # 只使用前八（8）个字符。</div><div class="line">      auth_pass 1234</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  # 设置虚拟IP地址，所有的机器上应该都使用相同的配置</div><div class="line">  virtual_ipaddress &#123;</div><div class="line">      &lt;IPADDR&gt;/&lt;MASK&gt; brd &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPE&gt; label &lt;LABEL&gt;</div><div class="line">      192.168.200.17/24 dev eth1</div><div class="line">      192.168.200.18/24 dev eth2 label eth2:1</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  # 从可选的VRRP中排除VRRP IP。</div><div class="line">  # 对于在同一接口上有大量（例如200）的IP的情况。 要减少广告中发送的数据包数量，我们可以从广告中排除大多数IP。</div><div class="line"></div><div class="line">  # 为virtual_ipaddress添加或者删除。</div><div class="line">  # 因为virtual_ipaddress中的所有地址必须是同一系列，所以如果我们希望能够添加IPv4和IPv6地址的混合，也可以使用，virtual_ipaddress_excluded 来进行配置。</div><div class="line">  virtual_ipaddress_excluded &#123;</div><div class="line">   &lt;IPADDR&gt;/&lt;MASK&gt; brd &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPE&gt;</div><div class="line">   &lt;IPADDR&gt;/&lt;MASK&gt; brd &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPE&gt;</div><div class="line">      ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  # 设置接口上的promote_secondaries标志，以便在删除其中一个时，停止删除同一CIDR中的其他地址。例如，如果在接口上同时配置了10.1.1.2/24和10.1.1.3/24，一旦删除了一个，除非接口上设置了 promote_secondaries 标志，否则其他地址也将会被删除。</div><div class="line">  prompte_secondaries</div><div class="line"></div><div class="line">  # 当转换成 MASTER 时添加下面的routes，当转换成 BACKUP 时，会删除下面的routes 配置</div><div class="line">  # 有关详细信息，请参阅static_routes</div><div class="line">  virtual_routes &#123;</div><div class="line">      # src &lt;IPADDR&gt; [to] &lt;IPADDR&gt;/&lt;MASK&gt; via|gw &lt;IPADDR&gt; [or &lt;IPADDR&gt;] dev &lt;STRING&gt; scope &lt;SCOPE&gt; table &lt;TABLE&gt;</div><div class="line">      src 192.168.100.1 to 192.168.109.0/24 via 192.168.200.254 dev eth1</div><div class="line">      192.168.110.0/24 via 192.168.200.254 dev eth1</div><div class="line">      192.168.111.0/24 dev eth2</div><div class="line">      192.168.112.0/24 via 192.168.100.254</div><div class="line">      192.168.113.0/24 via 192.168.200.254 or 192.168.100.254 dev eth1</div><div class="line">      blackhole 192.168.114.0/24</div><div class="line">      0.0.0.0/0 gw 192.168.0.1 table 100  # To set a default gateway into table 100.</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  # 当转换成 MASTER 时添加下面的 rules ，当转换成 BACKUP 时，会删除下面的 rules 配置</div><div class="line">  # 有关详细信息，请参阅static_rules</div><div class="line">  virtual_rules &#123;</div><div class="line">      from 192.168.2.0/24 table 1</div><div class="line">      to 192.168.2.0/24 table 1</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  # VRRPv3有一个 接受模式，以允许虚拟路由器在没有地址所有者时接收发往VIP的数据包。 这是默认设置，除非设置了strict模式。</div><div class="line">  # 作为扩展，这也适用于VRRPv2（RFC 3768没有定义接受模式）。</div><div class="line">  accept          # 接受数据包到非地址所有者</div><div class="line">  no_accept       # 丢弃数据包到非地址所有者。</div><div class="line"></div><div class="line">  # 当较高优先级机器联机时，VRRP通常抢占较低优先级机器。 “nopreempt”允许较低优先级机器维护主机角色，即使较高优先级机器恢复在线时也是如此。</div><div class="line">  # 注意：要使其工作，此条目的初始状态必须为BACKUP。</div><div class="line">  nopreempt</div><div class="line">  preempt             # 用于向后兼容</div><div class="line"></div><div class="line"></div><div class="line">   # 请参见全局vrrp_skip_check_adv_addr的描述，它设置默认值。 默认为vrrp_skip_check_adv_addr</div><div class="line">   skip_check_adv_addr [on|off|true|false|yes|no]      # 如果没有指定，默认开启</div><div class="line"></div><div class="line">   # 请参见全局vrrp_strict的描述</div><div class="line">   # 如果未指定vrrp_strict，则它使用vrrp_strict的值</div><div class="line">   # 如果指定了不带参数的strict_mode，则其默认为on</div><div class="line">   strict_mode [on|off|true|false|yes|no]</div><div class="line"></div><div class="line">   # 启动后的秒数或看到较低优先级主机直到抢占（如果未由“nopreempt”禁用）。</div><div class="line">   # Range: 0 (default) to 1000</div><div class="line">   # 注意：要使其工作，此条目的初始状态必须为BACKUP。</div><div class="line">   preempt_delay 300    # 等待5分钟</div><div class="line"></div><div class="line">   # 调试级别，尚未实现。</div><div class="line">   debug &lt;LEVEL&gt;        # LEVEL是0到4范围内的数字</div><div class="line"></div><div class="line">   # 通知脚本，警报如上</div><div class="line">   notify_master &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]</div><div class="line">   notify_backup &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]</div><div class="line">   notify_fault &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]</div><div class="line">   notify_stop &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]      # 在停止vrrp时执行</div><div class="line">   notify &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]</div><div class="line">   smtp_alert</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 用于SSL_GET检查的参数。</div><div class="line"># 如果未指定任何参数，则将自动生成SSL上下文。</div><div class="line">SSL &#123;</div><div class="line">   password &lt;STRING&gt;   # 密码</div><div class="line">   ca &lt;STRING&gt;         # ca文件</div><div class="line">   certificate &lt;STRING&gt;  # 证书文件</div><div class="line">   key &lt;STRING&gt;        # 密钥文件</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LVS-配置"><a href="#LVS-配置" class="headerlink" title="LVS 配置"></a>LVS 配置</h2><p>包含的子块有，</p>
<ul>
<li>Virtual server group(s) ,虚拟服务器组</li>
<li>Virtual server(s) ,虚拟服务器</li>
</ul>
<p>子块包含了 ipvsadm（8）的参数。  了解 ipvsadm（8）将会有助于我们的配置。</p>
<h3 id="Virtual-server-group-s-虚拟服务器组"><a href="#Virtual-server-group-s-虚拟服务器组" class="headerlink" title="Virtual server group(s) ,虚拟服务器组"></a>Virtual server group(s) ,虚拟服务器组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 可选配置项</div><div class="line"># 此组允许real_server上的服务属于多个虚拟服务，并且只进行一次健康检查。</div><div class="line"># 仅适用于非常大的LVS。</div><div class="line">virtual_server_group &lt;STRING&gt; &#123;</div><div class="line">       #VIP port</div><div class="line">       &lt;IPADDR&gt; &lt;PORT&gt;</div><div class="line">       &lt;IPADDR&gt; &lt;PORT&gt;</div><div class="line">       ...</div><div class="line">       # &lt;IPADDR RANGE&gt; 的格式为 XXX.YYY.ZZZ.WWW-VVV，例如 192.168.200.1-10 范围包括.1到.10地址</div><div class="line">       &lt;IPADDR RANGE&gt; &lt;PORT&gt;# VIP  VPORT 范围</div><div class="line">       &lt;IPADDR RANGE&gt; &lt;PORT&gt;</div><div class="line">       ...</div><div class="line">       fwmark &lt;INT&gt;  # fwmark</div><div class="line">       fwmark &lt;INT&gt;</div><div class="line">       ...  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Virtual-server-s-虚拟服务器"><a href="#Virtual-server-s-虚拟服务器" class="headerlink" title="Virtual server(s) ,虚拟服务器"></a>Virtual server(s) ,虚拟服务器</h3><p>virtual_server是一个<code>vip vport (IPADDR PORT pair)</code> 或  <code>fwmark &lt;INT&gt;</code> 的声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div></pre></td><td class="code"><pre><div class="line">(virtual server) group &lt;STRING&gt;</div><div class="line"></div><div class="line"># 设置服务</div><div class="line">virtual_server IP port |</div><div class="line">virtual_server fwmark int |</div><div class="line">virtual_server group string</div><div class="line">&#123;</div><div class="line"># 延迟定时器用于服务轮询</div><div class="line">delay_loop &lt;INT&gt;</div><div class="line"></div><div class="line"># LVS调度器</div><div class="line">lb_algo rr|wrr|lc|wlc|lblc|sh|dh</div><div class="line"></div><div class="line"># 启用散列条目</div><div class="line">hashed</div><div class="line"># 启用 flag-1 调度器 (-b flag-1 in ipvsadm)</div><div class="line">flag-1</div><div class="line"># 启用 flag-2 调度器(-b flag-2 in ipvsadm)</div><div class="line">flag-2</div><div class="line"># 启用 flag-3 调度器 (-b flag-3 in ipvsadm)</div><div class="line">flag-3</div><div class="line"># 启用 sh-port 调度器 (-b sh-port in ipvsadm)</div><div class="line">sh-port</div><div class="line"># 启用 sh-fallback 调度器  (-b sh-fallback in ipvsadm)</div><div class="line">sh-fallback</div><div class="line"></div><div class="line"># 为UDP启用单分组调度（在ipvsadm中为-O）</div><div class="line">ops</div><div class="line"># LVS转发方法</div><div class="line">lb_kind NAT|DR|TUN</div><div class="line"># LVS持久超时，秒</div><div class="line">persistence_timeout &lt;INT&gt;</div><div class="line"># LVS粒度掩码（ipvsadm中的-M）</div><div class="line">persistence_granularity &lt;NETMASK&gt;</div><div class="line"># 仅实现TCP</div><div class="line">protocol TCP</div><div class="line"># 如果没有设置VS IP地址，则暂停healthchecker的活动</div><div class="line">ha_suspend</div><div class="line"></div><div class="line"># 用于HTTP_GET或SSL_GET的VirtualHost字符串</div><div class="line"># 例如 virtualhost www.firewall.loc</div><div class="line">virtualhost &lt;STRING&gt;</div><div class="line"></div><div class="line"># 假定所有RS关闭,并且在启动时检查运行状况失败。</div><div class="line"># 这有助于防止启动时的假的积极操作。 默认情况下禁用Alpha模式。</div><div class="line">alpha</div><div class="line"></div><div class="line"># 在守护程序关闭时，在适当的情况下，考虑降低仲裁和RS通知程序执行。</div><div class="line"># 默认情况下禁用Omega模式。</div><div class="line">omega</div><div class="line"></div><div class="line"># Minimum total weight of all live servers in</div><div class="line"># the pool necessary to operate VS with no</div><div class="line"># quality regression. Defaults to 1.</div><div class="line">quorum &lt;INT&gt;</div><div class="line"></div><div class="line"># Tolerate this much weight units compared to the</div><div class="line"># nominal quorum, when considering quorum gain</div><div class="line"># or loss. A flap dampener. Defaults to 0.</div><div class="line">hysteresis &lt;INT&gt;</div><div class="line"></div><div class="line"># 获得 quorum 时启动的脚本。</div><div class="line">quorum_up &lt;STRING&gt;|&lt;QUOTED-STRING&gt;</div><div class="line"></div><div class="line"># 丢失quorum时启动的脚本。</div><div class="line">quorum_down &lt;STRING&gt;|&lt;QUOTED-STRING&gt;</div><div class="line"></div><div class="line"># 设置 realserver(s)</div><div class="line"></div><div class="line"># 在所有 realserver 都关闭时生效</div><div class="line">sorry_server &lt;IPADDR&gt; &lt;PORT&gt;</div><div class="line"># 将 inhibit_on_failure 行为应用于前面的 sorry_server 指令</div><div class="line">sorry_server_inhibit</div><div class="line"></div><div class="line"># 每个realserver,一个条目</div><div class="line">real_server &lt;IPADDR&gt; &lt;PORT&gt;</div><div class="line">  &#123;</div><div class="line">      # 相对权重，默认：1</div><div class="line">      weight &lt;INT&gt;</div><div class="line">      # 健康检查器检测到故障时，将权重设置为0</div><div class="line">      inhibit_on_failure</div><div class="line"></div><div class="line">      # 当运行状况检查器将服务视为启动时启动的脚本。</div><div class="line">      notify_up &lt;STRING&gt;|&lt;QUOTED-STRING&gt;</div><div class="line">      # 当运行状况检查器将服务视为停机时启动的脚本。</div><div class="line">      notify_down &lt;STRING&gt;|&lt;QUOTED-STRING&gt;</div><div class="line"></div><div class="line">      # 选择一个健康检查</div><div class="line">      # HTTP_GET|SSL_GET|TCP_CHECK|SMTP_CHECK|MISC_CHECK</div><div class="line"></div><div class="line">      # HTTP和SSL健康检查程序</div><div class="line">      HTTP_GET|SSL_GET</div><div class="line">      &#123;</div><div class="line">          # 一个url测试</div><div class="line">          # 可以有多个条目</div><div class="line">          url &#123;</div><div class="line">            # 例如 path / , or path /mrtg2/</div><div class="line">            path &lt;STRING&gt;</div><div class="line">            # healthcheck需要status_code或status_code和digest</div><div class="line">            # 摘要用genhash计算</div><div class="line">            # 例如 digest 9b3a0c85a887a256d6939da88aabd8cd</div><div class="line">            digest &lt;STRING&gt;</div><div class="line">            # HTTP标头中返回的状态代码</div><div class="line">            # 例如 status_code 200</div><div class="line">            status_code &lt;INT&gt;</div><div class="line">          &#125;</div><div class="line">          # 获取重试次数</div><div class="line">          nb_get_retry &lt;INT&gt;</div><div class="line">          # 延迟后重试</div><div class="line">          delay_before_retry &lt;INT&gt;</div><div class="line"></div><div class="line">          # ======== 通用连接选项</div><div class="line">          # 要连接的可选IP地址。</div><div class="line">          # 默认值为真实服务器的IP</div><div class="line">          connect_ip &lt;IP ADDRESS&gt;</div><div class="line">          # 可选，端口，如果没有连接</div><div class="line">          # 默认值为真实服务器的端口</div><div class="line">          connect_port &lt;PORT&gt;</div><div class="line">          # 用于发起连接的可选接口</div><div class="line">          bindto &lt;IP ADDRESS&gt;</div><div class="line">          # 用于发起连接的可选源端口</div><div class="line">          bind_port &lt;PORT&gt;</div><div class="line">          # 可选，连接超时（秒）。</div><div class="line">          # 默认值为5秒</div><div class="line">          connect_timeout &lt;INTEGER&gt;</div><div class="line">          # 可选，用于标记所有传出检查程序包的fwmark</div><div class="line">          fwmark &lt;INTEGER&gt;</div><div class="line"></div><div class="line">          # 可选的，随机延迟最大N秒后开始初始检查。</div><div class="line">          # 用于将多个同时检查分散到同一个RS。 默认情况下启用，最大值为delay_loop。 指定 0 为禁用</div><div class="line">          warmup &lt;INT&gt;</div><div class="line">      &#125; # HTTP_GET|SSL_GET</div><div class="line"></div><div class="line">      # TCP健康检查器（绑定到IP端口）</div><div class="line">      TCP_CHECK</div><div class="line">      &#123;</div><div class="line">          # ======== 通用连接选项</div><div class="line">          # 可选，要连接的IP地址。</div><div class="line">          # 默认值为真实服务器的IP</div><div class="line">          connect_ip &lt;IP ADDRESS&gt;</div><div class="line">          # 可选，连接端口</div><div class="line">          # 默认值为真实服务器的端口</div><div class="line">          connect_port &lt;PORT&gt;</div><div class="line">          # 可选，发起连接使用的接口</div><div class="line">          bindto &lt;IP ADDRESS&gt;</div><div class="line">          # 可选，发起连接源端口</div><div class="line">          bind_port &lt;PORT&gt;</div><div class="line">          # 可选，连接超时（以秒为单位）。</div><div class="line">          # 默认值为5秒</div><div class="line">          connect_timeout &lt;INTEGER&gt;</div><div class="line">          # 可选， 用于标记所有传出检查程序包的fwmark</div><div class="line">          fwmark &lt;INTEGER&gt;</div><div class="line"></div><div class="line">          # 可选， 随机延迟最大N秒后开始初始检查。</div><div class="line">          # 用于将多个同时检查分散到同一个RS。 默认情况下启用，最大值为delay_loop。 指定 0 为禁用</div><div class="line">          warmup &lt;INT&gt;</div><div class="line">      &#125; #TCP_CHECK</div><div class="line"></div><div class="line">      # SMTP健康检查器</div><div class="line">      SMTP_CHECK</div><div class="line">      &#123;</div><div class="line">          # 可选，主机接口检查。</div><div class="line">          # 如果没有主机指令，则只检查真实服务器的IP地址。</div><div class="line">          host &#123;</div><div class="line">            # ======== 通用连接选项</div><div class="line">            # 可选，要连接的IP地址。</div><div class="line">            # 默认值为真实服务器的IP</div><div class="line">            connect_ip &lt;IP ADDRESS&gt;</div><div class="line">            # 可选，连接端口</div><div class="line">            # 默认值为25</div><div class="line">            connect_port &lt;PORT&gt;</div><div class="line">            # 可选，发起连接使用的接口</div><div class="line">            bindto &lt;IP ADDRESS&gt;</div><div class="line">            # 可选，发起连接源端口</div><div class="line">            bind_port &lt;PORT&gt;</div><div class="line">            # 可选，每个主机连接超时。</div><div class="line">            # Default is outer-scope connect_timeout</div><div class="line">            connect_timeout &lt;INTEGER&gt;</div><div class="line">            # 可选， 用于标记所有传出检查程序包的fwmark</div><div class="line">            fwmark &lt;INTEGER&gt;</div><div class="line">         &#125;</div><div class="line">         # 连接超时时间</div><div class="line">         connect_timeout &lt;INTEGER&gt;</div><div class="line">         # 重试失败检查的次数</div><div class="line">         retry &lt;INTEGER&gt;</div><div class="line">         # 重试前延迟秒</div><div class="line">         delay_before_retry &lt;INTEGER&gt;</div><div class="line">         # 用于smtp HELO请求的可选字符串</div><div class="line">         helo_name &lt;STRING&gt;|&lt;QUOTED-STRING&gt;</div><div class="line"></div><div class="line">         # 可选， 随机延迟最大N秒后开始初始检查。</div><div class="line">         # 用于将多个同时检查分散到同一个RS。 默认情况下启用，最大值为delay_loop。 指定 0 为禁用</div><div class="line">         warmup &lt;INT&gt;</div><div class="line">      &#125; #SMTP_CHECK</div><div class="line"></div><div class="line">      # 运行外部程序，进行MISC健康检查</div><div class="line">      MISC_CHECK</div><div class="line">      &#123;</div><div class="line">          # 外部系统脚本或程序</div><div class="line">          misc_path &lt;STRING&gt;|&lt;QUOTED-STRING&gt;</div><div class="line">          # 脚本执行超时</div><div class="line">          misc_timeout &lt;INT&gt;</div><div class="line"></div><div class="line">          # 可选， 随机延迟最大N秒后开始初始检查。</div><div class="line">          # 用于将多个同时检查分散到同一个RS。 默认情况下启用，最大值为delay_loop。 指定 0 为禁用</div><div class="line">          warmup &lt;INT&gt;</div><div class="line"></div><div class="line">          # 如果设置，将会根据  healthchecker 退出状态码动态调整权重如下：</div><div class="line">          #   exit status 0: svc检查成功，权重不变。</div><div class="line">          #   exit status 1: svc检查失败.</div><div class="line">          #   exit status 2-255: svc检查成功，权重更改为小于退出状态2的值。</div><div class="line">          #   (示例：退出状态为 255 会将权重设置为 253 )</div><div class="line">          misc_dynamic</div><div class="line">          # 指定脚本应在其下运行的用户名/组名。 如果未指定GROUPNAME，则使用用户的组</div><div class="line">          user USERNAME [GROUPNAME]</div><div class="line">      &#125;</div><div class="line">  &#125; # realserver 定义</div><div class="line">&#125; # virtual service</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;keepalived只有一个配置文件 keepalived.conf ，里面主要包括以下几个配置区域，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;global_defs&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要是配置故障发生时的通知对象以及机器标识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static_ipaddress&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置的是是本节点的IP信息。（如果当前服务器上已经配置了IP，那么这这个区域可以不用配置）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static_routes&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置的是是本节点的路由信息。（如果当前服务器上已经配置了路由，那么这这个区域可以不用配置）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;vrrp_script&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来做健康检查的，当时检查失败时会将&lt;code&gt;vrrp_instance&lt;/code&gt;的&lt;code&gt;priority&lt;/code&gt;减少相应的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vrrp_instance&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来定义对外提供服务的VIP区域及其相关属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;vrrp_sync_group&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来定义&lt;code&gt;vrrp_intance&lt;/code&gt;组，使得这个组内成员动作一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;virtual_server&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟服务器，来源&lt;code&gt;vrrp_instance&lt;/code&gt; 中配置的 的虚拟IP地址，后面加空格加端口号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;virtual_server_group&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来定义&lt;code&gt;virtual_server&lt;/code&gt; 组，一般在超大型的LVS中用到，一般LVS用不过这东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="keepalived" scheme="https://weizhimiao.github.io/tags/keepalived/"/>
    
  </entry>
  
  <entry>
    <title>keepalived安装与配置</title>
    <link href="https://weizhimiao.github.io/2017/02/11/keepalived%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://weizhimiao.github.io/2017/02/11/keepalived安装配置/</id>
    <published>2017-02-11T12:30:00.000Z</published>
    <updated>2017-03-09T08:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.keepalived.org/download.html" target="_blank" rel="external">keepalived 源码包下载地址:http://www.keepalived.org/download.html</a></p>
<h2 id="服务器内核要求"><a href="#服务器内核要求" class="headerlink" title="服务器内核要求"></a>服务器内核要求</h2><p>需要服务器内核支持：</p>
<ul>
<li><p>Kernel/User netlink socket</p>
<blockquote>
<p>netlink是基于socket的通信机制，由于socket本身的双工性、突发性、不阻塞性等特点，能够很好地满足内核空间与用户空间小量数据的及时交互，因此在Linux 2.6内核开始被广泛使用，例如内核态的netfilter与用户态的iptables的数据交换就是通过netlink机制完成的。</p>
</blockquote>
</li>
<li><p>LinuxVirtualServer</p>
<blockquote>
<p>在大部分 linux 发行版中，ipvs 被默认安装。如果没有安装则需要安装。<br>检查当前加载的内核模块，看是否存在 ip_vs 模块。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@hd-4 ipvsadm-1.24]# lsmod|grep ip_vs</div><div class="line">ip_vs 77569 0</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="安装-ipvs"><a href="#安装-ipvs" class="headerlink" title="安装 ipvs"></a>安装 ipvs</h3><blockquote>
<p>Ipvs 具体实现是由 ipvsadm 这个程序来完成，因此判断一个系统是否具备 ipvs 功能，也可以查看 ipvsadm 程序是否被安装。查看 ipvsadm 程序最简单的办法就是在任意路径执行命令 ipvsadm。</p>
</blockquote>
<p>ipvs 版本的选择：</p>
<blockquote>
<p>由于IPVS与用户空间的接口在不同的Linux内核版本中不同，因此在不同的Linux内核版本中有不同版本的 ipvsadm 用于IPVS。</p>
<ul>
<li>对于Linux内核2.6中的IPVS，需要使用ipvsadm 1.24版或更高版本。</li>
<li>对于Linux内核2.4中的IPVS，需要使用ipvsadm 1.21系列。</li>
<li>对于Linux内核2.2的IPVS补丁，需要使用ipvsadm版本1.15。</li>
</ul>
<p>当前我使用的Linux内核是 <code>2.6.32-642.6.2.el6.i686</code> ,所以选择了 <code>ipvsadm-1.26</code>.</p>
</blockquote>
<p><a href="http://www.linuxvirtualserver.org/software/ipvs.html" target="_blank" rel="external">ipvsadm 下载地址：http://www.linuxvirtualserver.org/software/ipvs.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# wget http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz</div><div class="line">[root@localhost ~]# tar zxvf ipvsadm-1.26.tar.gz</div><div class="line">[root@localhost ~]# cd ipvsadm-1.26</div><div class="line">[root@localhost ipvsadm-1.26]# make</div><div class="line">[root@localhost ipvsadm-1.26]# make install</div></pre></td></tr></table></figure>
<p>装完之后，ipvsadm 产生的文件列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/sbin/ipvsadm</div><div class="line">/sbin/ipvsadm-save</div><div class="line">/sbin/ipvsadm-restore</div><div class="line">/usr/man/man8/ipvsadm.8</div><div class="line">/usr/man/man8/ipvsadm-save.8</div><div class="line">/usr/man/man8/ipvsadm-restore.8</div><div class="line">/etc/rc.d/init.d/ipvsadm</div></pre></td></tr></table></figure></p>
<p>执行 ipvsadm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ipvsadm-1.26]# ipvsadm</div><div class="line">IP Virtual Server version 1.2.1 (size=4096)</div><div class="line">Prot LocalAddress:Port Scheduler Flags</div><div class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</div></pre></td></tr></table></figure></p>
<p>查看当前加载的内核模块，看是否已经存在 ip_vs 模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ipvsadm-1.26]# lsmod | grep ip_vs</div><div class="line">ip_vs                 103551  0</div><div class="line">libcrc32c                841  1 ip_vs</div><div class="line">ipv6                  271777  16 ip_vs,ip6t_REJECT,nf_conntrack_ipv6,nf_defrag_ipv6</div></pre></td></tr></table></figure></p>
<p>至此，ipvs 就已经安装成功。</p>
<p><strong>安装 ipvs 时，可能会遇到的问题：</strong></p>
<ul>
<li>1、<code>can&#39;t find file &#39;netlink/netlink.h&#39;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">make -C libipvs</div><div class="line">make[1]: Entering directory `/root/ipvsadm-1.26/libipvs&apos;</div><div class="line">gcc -Wall -Wunused -Wstrict-prototypes -g -fPIC -DLIBIPVS_USE_NL  -DHAVE_NET_IP_VS_H -c -o libipvs.o libipvs.c</div><div class="line">在包含自 libipvs.h：13 的文件中，</div><div class="line">                 从 libipvs.c：23:</div><div class="line">ip_vs.h:15:29: 错误：netlink/netlink.h：没有那个文件或目录</div><div class="line">ip_vs.h:16:31: 错误：netlink/genl/genl.h：没有那个文件或目录</div><div class="line">ip_vs.h:17:31: 错误：netlink/genl/ctrl.h：没有那个文件或目录</div><div class="line">In file included from libipvs.h:13,</div><div class="line">                 from libipvs.c:23:</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>解决方法：安装 <code>libnl</code> 和 <code>popt</code> 相关的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install libnl* popt*</div></pre></td></tr></table></figure></p>
<ul>
<li>2、</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"># make</div><div class="line">make -C libipvs</div><div class="line">make[1]: Entering directory `/var/tmp/ipvsadm-1.24/libipvs&apos;</div><div class="line">gcc -Wall -Wunused -Wstrict-prototypes -g -O2 -I/usr/src/linux/include  -DHAVE_NET_IP_VS_H -c -o libipvs.o libipvs.c</div><div class="line">In file included from libipvs.c:23:</div><div class="line">libipvs.h:14:23: net/ip_vs.h: No such file or directory</div><div class="line">In file included from libipvs.c:23:</div><div class="line">libipvs.h:119: error: syntax error before &quot;fwmark&quot;</div><div class="line">libipvs.h:119: warning: function declaration isn&apos;t a prototype</div><div class="line">libipvs.c:27: error: field `svc&apos; has incomplete type</div><div class="line">libipvs.c:28: error: field `dest&apos; has incomplete type</div><div class="line">libipvs.c: In function `ipvs_init&apos;:</div><div class="line">libipvs.c:40: error: invalid application of `sizeof&apos; to incomplete type `ip_vs_getinfo&apos;</div><div class="line">libipvs.c:44: error: `IP_VS_SO_GET_INFO&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:44: error: (Each undeclared identifier is reported only once</div><div class="line">libipvs.c:44: error: for each function it appears in.)</div><div class="line">libipvs.c: In function `ipvs_getinfo&apos;:</div><div class="line">libipvs.c:56: error: invalid application of `sizeof&apos; to incomplete type `ip_vs_getinfo&apos;</div><div class="line">libipvs.c:57: error: `IP_VS_SO_GET_INFO&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: In function `ipvs_version&apos;:</div><div class="line">libipvs.c:64: error: invalid use of undefined type `struct ip_vs_getinfo&apos;</div><div class="line">libipvs.c: In function `ipvs_flush&apos;:</div><div class="line">libipvs.c:70: error: `IP_VS_SO_SET_FLUSH&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: In function `ipvs_add_service&apos;:</div><div class="line">libipvs.c:79: error: `IP_VS_SO_SET_ADD&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:79: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c: In function `ipvs_update_service&apos;:</div><div class="line">libipvs.c:87: error: `IP_VS_SO_SET_EDIT&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:87: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c: In function `ipvs_del_service&apos;:</div><div class="line">libipvs.c:95: error: `IP_VS_SO_SET_DEL&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:95: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c: In function `ipvs_zero_service&apos;:</div><div class="line">libipvs.c:103: error: `IP_VS_SO_SET_ZERO&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:103: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c: In function `ipvs_add_dest&apos;:</div><div class="line">libipvs.c:109: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:109: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:112: error: `IP_VS_SO_SET_ADDDEST&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: In function `ipvs_update_dest&apos;:</div><div class="line">libipvs.c:119: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:119: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:122: error: `IP_VS_SO_SET_EDITDEST&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: In function `ipvs_del_dest&apos;:</div><div class="line">libipvs.c:129: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:129: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:132: error: `IP_VS_SO_SET_DELDEST&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: In function `ipvs_set_timeout&apos;:</div><div class="line">libipvs.c:140: error: `IP_VS_SO_SET_TIMEOUT&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:141: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c: In function `ipvs_start_daemon&apos;:</div><div class="line">libipvs.c:148: error: `IP_VS_SO_SET_STARTDAEMON&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:149: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c: In function `ipvs_stop_daemon&apos;:</div><div class="line">libipvs.c:156: error: `IP_VS_SO_SET_STOPDAEMON&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:157: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c: In function `ipvs_get_services&apos;:</div><div class="line">libipvs.c:166: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:167: error: invalid application of `sizeof&apos; to incomplete type `libipvs.h&apos;</div><div class="line">libipvs.c:167: error: invalid use of undefined type `struct ip_vs_getinfo&apos;</div><div class="line">libipvs.c:172: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:172: error: invalid use of undefined type `struct ip_vs_getinfo&apos;</div><div class="line">libipvs.c:174: error: `IP_VS_SO_GET_SERVICES&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: In function `ipvs_cmp_services&apos;:</div><div class="line">libipvs.c:189: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:189: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:193: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:193: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:197: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:197: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:201: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:201: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c: In function `ipvs_sort_services&apos;:</div><div class="line">libipvs.c:208: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:208: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:209: error: invalid application of `sizeof&apos; to incomplete type `libipvs.h&apos;</div><div class="line">libipvs.c: In function `ipvs_get_dests&apos;:</div><div class="line">libipvs.c:218: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:218: error: invalid application of `sizeof&apos; to incomplete type `libipvs.h&apos;</div><div class="line">libipvs.c:218: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:224: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:224: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:225: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:225: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:226: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:226: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:227: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:227: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:228: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:228: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:231: error: `IP_VS_SO_GET_DESTS&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: In function `ipvs_cmp_dests&apos;:</div><div class="line">libipvs.c:243: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:243: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:247: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:247: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c: In function `ipvs_sort_dests&apos;:</div><div class="line">libipvs.c:253: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:253: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:254: error: invalid application of `sizeof&apos; to incomplete type `libipvs.h&apos;</div><div class="line">libipvs.c: At top level:</div><div class="line">libipvs.c:259: error: syntax error before &quot;fwmark&quot;</div><div class="line">libipvs.c:260: warning: function declaration isn&apos;t a prototype</div><div class="line">libipvs.c: In function `ipvs_get_service&apos;:</div><div class="line">libipvs.c:264: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:270: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:270: error: `fwmark&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:271: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:271: error: `protocol&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:272: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:272: error: `addr&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:273: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:273: error: `port&apos; undeclared (first use in this function)</div><div class="line">libipvs.c:274: error: `IP_VS_SO_GET_SERVICE&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: In function `ipvs_get_timeout&apos;:</div><div class="line">libipvs.c:288: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:293: error: `IP_VS_SO_GET_TIMEOUT&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: In function `ipvs_get_daemon&apos;:</div><div class="line">libipvs.c:309: error: dereferencing pointer to incomplete type</div><div class="line">libipvs.c:315: error: `IP_VS_SO_GET_DAEMON&apos; undeclared (first use in this function)</div><div class="line">libipvs.c: At top level:</div><div class="line">libipvs.c:33: error: storage size of `ipvs_info&apos; isn&apos;t known</div><div class="line">make[1]: *** [libipvs.o] Error 1</div><div class="line">make[1]: Leaving directory `/var/tmp/ipvsadm-1.24/libipvs&apos;</div><div class="line">make: *** [libs] Error 2</div></pre></td></tr></table></figure>
<p>这个问题一般是编译器找不到 服务器 kernel 的源码路径。解决方法是，创建一个当前系统的 kernel 源码路径的 连接到 <code>/usr/src/linux</code>。如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln –sv /usr/src/kernels/2.6.32-642.6.2.el6.i686 /usr/src/linux</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意一定要与当前的运行的内核相一致，因为 <code>/usr/src/kernels</code> 目录下可多个目录。</p>
<p>若<code>/usr/src/kernel</code>目录下没有内核目录，则需要安装内核开发包：</p>
<ul>
<li>用命令<code>uname -a</code>查看内核版本，</li>
<li>然后可以在这里查找对应的 <code>kernel</code> 开发包(<a href="https://www.kernel.org/pub/linux/kernel/v2.6/" target="_blank" rel="external">https://www.kernel.org/pub/linux/kernel/v2.6/</a>)</li>
</ul>
<p>不推荐使用 <code>yum install -y kernel-devel</code> 安装</p>
</blockquote>
<h2 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h2><ul>
<li>gcc、gcc-c++</li>
<li>openssl-dev</li>
</ul>
<p>报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">configure: error:</div><div class="line">  !!! OpenSSL is not properly installed on your system. !!!</div><div class="line">  !!! Can not include OpenSSL headers files.            !!!</div></pre></td></tr></table></figure></p>
<p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install openssl-devel -y</div></pre></td></tr></table></figure></p>
<ul>
<li>libnfnetlink-devel</li>
</ul>
<p>报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">configure: error:</div><div class="line">    !!! Please install libnfnetlink headers.              !!!</div></pre></td></tr></table></figure></p>
<p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y libnfnetlink-devel</div></pre></td></tr></table></figure></p>
<h2 id="keepalived-安装"><a href="#keepalived-安装" class="headerlink" title="keepalived 安装"></a>keepalived 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# wget http://www.keepalived.org/software/keepalived-1.3.2.tar.gz</div><div class="line">[root@localhost ~]# tar zxvf keepalived-1.3.2.tar.gz</div><div class="line">[root@localhost ~]# cd keepalived-1.3.2</div><div class="line">[root@localhost keepalived-1.3.2]# ./configure --prefix=/usr/local/keepalived</div><div class="line">...</div><div class="line">Keepalived configuration</div><div class="line">------------------------</div><div class="line">Keepalived version       : 1.3.2</div><div class="line">Compiler                 : gcc</div><div class="line">Preprocessor flags       :  -I/usr/include/libnl3  </div><div class="line">Compiler flags           : -Wall -Wunused -Wstrict-prototypes -Wextra -g -O2   </div><div class="line">Linker flags             :</div><div class="line">Extra Lib                : -ldl -lssl -lcrypto  -lnl-3 -lnl-genl-3 -lnl-route-3</div><div class="line">Use IPVS Framework       : Yes</div><div class="line">IPVS use libnl           : Yes</div><div class="line">IPVS syncd attributes    : No</div><div class="line">IPVS 64 bit stats        : No</div><div class="line">fwmark socket support    : Yes</div><div class="line">Use VRRP Framework       : Yes</div><div class="line">Use VRRP VMAC            : Yes</div><div class="line">Use VRRP authentication  : Yes</div><div class="line">With ip rules/routes     : Yes</div><div class="line">SNMP vrrp support        : No</div><div class="line">SNMP checker support     : No</div><div class="line">SNMP RFCv2 support       : No</div><div class="line">SNMP RFCv3 support       : No</div><div class="line">DBUS support             : No</div><div class="line">SHA1 support             : No</div><div class="line">Use Debug flags          : No</div><div class="line">Stacktrace support       : No</div><div class="line">Memory alloc check       : No</div><div class="line">libnl version            : 3</div><div class="line">Use IPv4 devconf         : No</div><div class="line">Use libiptc              : No</div><div class="line">Use libipset             : No</div><div class="line">init type                : upstart</div><div class="line">Build genhash            : Yes</div><div class="line">Build documentation      : No</div><div class="line">[root@localhost keepalived-1.3.2]# make &amp;&amp; make install</div><div class="line"></div><div class="line">[root@localhost keepalived-1.3.2]# cd /usr/local/keepalived/</div><div class="line">[root@localhost keepalived]# tree .</div><div class="line">.</div><div class="line">├── bin</div><div class="line">│   └── genhash</div><div class="line">├── etc</div><div class="line">│   ├── init</div><div class="line">│   │   └── keepalived.conf</div><div class="line">│   ├── keepalived</div><div class="line">│   │   ├── keepalived.conf</div><div class="line">│   │   └── samples</div><div class="line">│   │       ├── client.pem</div><div class="line">│   │       ├── dh1024.pem</div><div class="line">│   │       ├── keepalived.conf.fwmark</div><div class="line">│   │       ├── keepalived.conf.HTTP_GET.port</div><div class="line">│   │       ├── keepalived.conf.inhibit</div><div class="line">│   │       ├── keepalived.conf.IPv6</div><div class="line">│   │       ├── keepalived.conf.misc_check</div><div class="line">│   │       ├── keepalived.conf.misc_check_arg</div><div class="line">│   │       ├── keepalived.conf.quorum</div><div class="line">│   │       ├── keepalived.conf.sample</div><div class="line">│   │       ├── keepalived.conf.SMTP_CHECK</div><div class="line">│   │       ├── keepalived.conf.SSL_GET</div><div class="line">│   │       ├── keepalived.conf.status_code</div><div class="line">│   │       ├── keepalived.conf.track_interface</div><div class="line">│   │       ├── keepalived.conf.virtualhost</div><div class="line">│   │       ├── keepalived.conf.virtual_server_group</div><div class="line">│   │       ├── keepalived.conf.vrrp</div><div class="line">│   │       ├── keepalived.conf.vrrp.localcheck</div><div class="line">│   │       ├── keepalived.conf.vrrp.lvs_syncd</div><div class="line">│   │       ├── keepalived.conf.vrrp.routes</div><div class="line">│   │       ├── keepalived.conf.vrrp.rules</div><div class="line">│   │       ├── keepalived.conf.vrrp.scripts</div><div class="line">│   │       ├── keepalived.conf.vrrp.static_ipaddress</div><div class="line">│   │       ├── keepalived.conf.vrrp.sync</div><div class="line">│   │       ├── root.pem</div><div class="line">│   │       └── sample.misccheck.smbcheck.sh</div><div class="line">│   └── sysconfig</div><div class="line">│       └── keepalived</div><div class="line">├── sbin</div><div class="line">│   └── keepalived</div><div class="line">└── share</div><div class="line">    ├── man</div><div class="line">    │   ├── man1</div><div class="line">    │   │   └── genhash.1</div><div class="line">    │   ├── man5</div><div class="line">    │   │   └── keepalived.conf.5</div><div class="line">    │   └── man8</div><div class="line">    │       └── keepalived.8</div><div class="line">    └── snmp</div><div class="line">        └── mibs</div><div class="line"></div><div class="line">14 directories, 34 files</div></pre></td></tr></table></figure>
<h2 id="keepalived-配置与管理"><a href="#keepalived-配置与管理" class="headerlink" title="keepalived 配置与管理"></a>keepalived 配置与管理</h2><p>简单的配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"># cat keepalived.conf</div><div class="line">! Configuration File for keepalived</div><div class="line"># 全局配置</div><div class="line">global_defs &#123;</div><div class="line">   #指定keepalived在发生切换时需要发送email到的对象，一行一个</div><div class="line">   notification_email &#123;</div><div class="line">     acassen@firewall.loc</div><div class="line">     failover@firewall.loc</div><div class="line">     sysadmin@firewall.loc</div><div class="line">   &#125;</div><div class="line">   notification_email_from Alexandre.Cassen@firewall.loc #指定发件人</div><div class="line">   smtp_server 192.168.200.1  #指定smtp服务器地址</div><div class="line">   smtp_connect_timeout 30  #指定smtp连接超时时间</div><div class="line">   router_id LVS_DEVEL  #运行keepalived机器的一个标识</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state MASTER  #指定那个为master，那个为backup，如果设置了nopreempt这个值不起作用，主备考priority决定</div><div class="line">    interface eth0  #设置实例绑定的网卡</div><div class="line">    virtual_router_id 51  #VPID标记</div><div class="line">    priority 100  #优先级，高优先级竞选为master</div><div class="line">    advert_int 1  #检查间隔，默认1秒</div><div class="line">    authentication &#123;  #设置认证</div><div class="line">        auth_type PASS   #认证方式</div><div class="line">        auth_pass 1111   #认证密码</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;  #设置vip</div><div class="line">        192.168.200.16</div><div class="line">        192.168.200.17</div><div class="line">        192.168.200.18</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual_server 192.168.200.100 443 &#123;</div><div class="line">    delay_loop 6   #健康检查时间间隔</div><div class="line">    lb_algo rr  #lvs调度算法rr|wrr|lc|wlc|lblc|sh|dh</div><div class="line">    lb_kind NAT  #负载均衡转发规则NAT|DR|RUN</div><div class="line">    nat_mask 255.255.255.0</div><div class="line">    persistence_timeout 50   #会话保持时间</div><div class="line">    protocol TCP  #使用的协议</div><div class="line"></div><div class="line">    real_server 192.168.201.100 443 &#123;</div><div class="line">        weight 1</div><div class="line">        SSL_GET &#123;</div><div class="line">            url &#123; #检查url，可以指定多个</div><div class="line">              path /</div><div class="line">              digest ff20ad2481f97b1754ef3e12ecd3a9cc</div><div class="line">            &#125;</div><div class="line">            url &#123;</div><div class="line">              path /mrtg/</div><div class="line">              digest 9b3a0c85a887a256d6939da88aabd8cd</div><div class="line">            &#125;</div><div class="line">            connect_timeout 3 #连接超时时间</div><div class="line">            nb_get_retry 3  #重连次数</div><div class="line">            delay_before_retry 3   #重连间隔时间</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual_server 10.10.10.2 1358 &#123;</div><div class="line">    delay_loop 6</div><div class="line">    lb_algo rr</div><div class="line">    lb_kind NAT</div><div class="line">    persistence_timeout 50</div><div class="line">    protocol TCP</div><div class="line"></div><div class="line">    sorry_server 192.168.200.200 1358</div><div class="line"></div><div class="line">    real_server 192.168.200.2 1358 &#123;</div><div class="line">        weight 1</div><div class="line">        HTTP_GET &#123;</div><div class="line">            url &#123;</div><div class="line">              path /testurl/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</div><div class="line">            &#125;</div><div class="line">            url &#123;</div><div class="line">              path /testurl2/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</div><div class="line">            &#125;</div><div class="line">            url &#123;</div><div class="line">              path /testurl3/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</div><div class="line">            &#125;</div><div class="line">            connect_timeout 3</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    real_server 192.168.200.3 1358 &#123;</div><div class="line">        weight 1</div><div class="line">        HTTP_GET &#123;</div><div class="line">            url &#123;</div><div class="line">              path /testurl/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334c</div><div class="line">            &#125;</div><div class="line">            url &#123;</div><div class="line">              path /testurl2/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334c</div><div class="line">            &#125;</div><div class="line">            connect_timeout 3</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual_server 10.10.10.3 1358 &#123;</div><div class="line">    delay_loop 3</div><div class="line">    lb_algo rr</div><div class="line">    lb_kind NAT</div><div class="line">    nat_mask 255.255.255.0</div><div class="line">    persistence_timeout 50</div><div class="line">    protocol TCP</div><div class="line"></div><div class="line">    real_server 192.168.200.4 1358 &#123;</div><div class="line">        weight 1</div><div class="line">        HTTP_GET &#123;</div><div class="line">            url &#123;</div><div class="line">              path /testurl/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</div><div class="line">            &#125;</div><div class="line">            url &#123;</div><div class="line">              path /testurl2/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</div><div class="line">            &#125;</div><div class="line">            url &#123;</div><div class="line">              path /testurl3/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</div><div class="line">            &#125;</div><div class="line">            connect_timeout 3</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    real_server 192.168.200.5 1358 &#123;</div><div class="line">        weight 1</div><div class="line">        HTTP_GET &#123;</div><div class="line">            url &#123;</div><div class="line">              path /testurl/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</div><div class="line">            &#125;</div><div class="line">            url &#123;</div><div class="line">              path /testurl2/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</div><div class="line">            &#125;</div><div class="line">            url &#123;</div><div class="line">              path /testurl3/test.jsp</div><div class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</div><div class="line">            &#125;</div><div class="line">            connect_timeout 3</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># keepalived -h</div><div class="line">Usage: keepalived [OPTION...]</div><div class="line">  -f, --use-file=FILE          使用指定的配置文件</div><div class="line">  -P, --vrrp                   只能使用VRRP子系统运行</div><div class="line">  -C, --check                  只能使用Health-checker子系统运行</div><div class="line">  -l, --log-console            将消息记录到本地控制台</div><div class="line">  -D, --log-detail             详细日志消息 /var/log/messages</div><div class="line">  -S, --log-facility=[0-7]     将syslog设置设置为LOG_LOCAL [0-7]</div><div class="line">  -V, --dont-release-vrrp      不要在守护程序停止时删除VRRP VIP和VROUTE</div><div class="line">  -I, --dont-release-ipvs      不要在守护程序停止时删除IPVS拓扑</div><div class="line">  -R, --dont-respawn           不要重新生成子进程</div><div class="line">  -n, --dont-fork              D不要fork守护进程</div><div class="line">  -d, --dump-conf              转储配置数据</div><div class="line">  -p, --pid=FILE               对父进程使用指定的pidfile</div><div class="line">  -r, --vrrp_pid=FILE          对VRRP子进程使用指定的pidfile</div><div class="line">  -c, --checkers_pid=FILE      使用指定的pidfile进行checkers子进程</div><div class="line">  -x, --snmp                   启用SNMP子系统</div><div class="line">  -v, --version                显示版本号</div><div class="line">  -h, --help                   显示此帮助消息</div></pre></td></tr></table></figure>
<p>示例，启动 keepalived<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># keepalived -D -f /xxx/keepalived.conf</div></pre></td></tr></table></figure></p>
<p>查看进程列表，keepalived 是否已经启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">]# ps aux | grep keepalived</div><div class="line">root      1371  0.0  0.1  17200  1092 ?        Ss   18:00   0:00 keepalived -D -f /etc/keepalived/keepalived.conf</div><div class="line">root      1372  0.0  0.2  17256  2632 ?        S    18:00   0:00 keepalived -D -f /etc/keepalived/keepalived.conf</div><div class="line">root      1373  0.0  0.1  17256  1840 ?        S    18:00   0:00 keepalived -D -f /etc/keepalived/keepalived.conf</div><div class="line">root      1390  0.0  0.0   6052   776 pts/0    S+   18:02   0:00 grep keepalived</div></pre></td></tr></table></figure></p>
<p>查看网络设置，虚拟IP是否已经设置</p>
<blockquote>
<p>使用 ifconfig 是看不到 虚拟IP 配置的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># ip add</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN</div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">    inet6 ::1/128 scope host</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</div><div class="line">    link/ether 08:00:27:bf:25:88 brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.1.103/24 brd 192.168.1.255 scope global eth0</div><div class="line">    inet 192.168.200.16/32 scope global eth0</div><div class="line">    inet 192.168.200.17/32 scope global eth0</div><div class="line">    inet 192.168.200.18/32 scope global eth0</div><div class="line">    inet6 fe80::a00:27ff:febf:2588/64 scope link</div><div class="line">       valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.keepalived.org/download.html&quot;&gt;keepalived 源码包下载地址:http://www.keepalived.org/download.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务器内核要求&quot;&gt;&lt;a href=&quot;#服务器内核要求&quot; class=&quot;headerlink&quot; title=&quot;服务器内核要求&quot;&gt;&lt;/a&gt;服务器内核要求&lt;/h2&gt;&lt;p&gt;需要服务器内核支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Kernel/User netlink socket&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;netlink是基于socket的通信机制，由于socket本身的双工性、突发性、不阻塞性等特点，能够很好地满足内核空间与用户空间小量数据的及时交互，因此在Linux 2.6内核开始被广泛使用，例如内核态的netfilter与用户态的iptables的数据交换就是通过netlink机制完成的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LinuxVirtualServer&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在大部分 linux 发行版中，ipvs 被默认安装。如果没有安装则需要安装。&lt;br&gt;检查当前加载的内核模块，看是否存在 ip_vs 模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[root@hd-4 ipvsadm-1.24]# lsmod|grep ip_vs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ip_vs 77569 0&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="keepalived" scheme="https://weizhimiao.github.io/tags/keepalived/"/>
    
  </entry>
  
  <entry>
    <title>Github中Webhooks的应用</title>
    <link href="https://weizhimiao.github.io/2017/02/03/Github%E4%B8%ADwebhooks%E5%BA%94%E7%94%A8/"/>
    <id>https://weizhimiao.github.io/2017/02/03/Github中webhooks应用/</id>
    <published>2017-02-03T12:30:00.000Z</published>
    <updated>2017-03-09T08:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Webhooks</code> 是 <code>Github</code> 为我们提供的一种订阅某些时间的功能。当这些事件被触发时，<code>Github</code> 会将信息以<code>POST</code>方式发送到我们指定的<code>URL</code>。通过<code>Webhooks</code> 我们可以记录更新，触发<code>CI构建</code>、更新备份镜像，甚至服务器的自动部署等等我们能够想到的各个地方。</p>
<p><code>Github</code> 上对于每个账号或者项目上的每个事件最多可以创建20个 <code>Webhooks</code> 。<br><a id="more"></a></p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>配置 <code>Webhook</code> 时，我们可以自定义具体的事件。只有定义定义的这些事件才会触发对指定的<code>URL</code>的请求。默认，<code>webhooks</code> 只订阅 <code>push</code> 事件，不过我们也可通过 <code>API</code> 或者 <code>UI</code> 来更改订阅事件的列表。</p>
<p>每个事件对应于可能发生在我们组织或 <code>Repository</code> 中的一组特定操作。 例如，如果订阅 <code>issues</code> 事件，则每次打开，关闭，标记 <code>issues</code> 时，我们都会收到详细的有效内容。</p>
<p>可用事件有：</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>任何时间触发任何事件（通配符事件）。</td>
</tr>
<tr>
<td><code>commit_comment</code></td>
<td>每次提交被注释时。</td>
</tr>
<tr>
<td><code>create</code></td>
<td>每次分支或标记被创建时。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>每次分支或标记被删除时。</td>
</tr>
<tr>
<td><code>deployment</code></td>
<td>每次 <code>Repository</code> 被部署。</td>
</tr>
<tr>
<td><code>deployment_status</code></td>
<td>任何时候，Repository的部署有来自API的状态更新时。</td>
</tr>
<tr>
<td><code>fork</code></td>
<td>每次<code>Repository</code>被<code>fork</code>时。</td>
</tr>
<tr>
<td><code>gollum</code></td>
<td>每次<code>Wiki Page</code> 被更新时。</td>
</tr>
<tr>
<td><code>issue_comment</code></td>
<td>每次 <code>Issue</code> 中的评论被添加、编辑、或删除时。</td>
</tr>
<tr>
<td><code>issues</code></td>
<td>每次 <code>issue</code> 被分配、未分配，标记，未标记，打开，编辑，重大事件，拆除，关闭或重新打开时。</td>
</tr>
<tr>
<td><code>label</code></td>
<td>每次标签被创建、编辑、或删除时。</td>
</tr>
<tr>
<td><code>member</code></td>
<td>每次添加或删除一个协作者用户，或者更改他们的权限时。</td>
</tr>
<tr>
<td><code>membership</code></td>
<td>任何时候添加或删除团队中用户。（仅组织钩子）</td>
</tr>
<tr>
<td><code>milestone</code></td>
<td>每次创建、关闭、打开、编辑或删除 <code>milestone</code> （里程碑）时。</td>
</tr>
<tr>
<td><code>organization</code></td>
<td>任何时候添加，删除或邀请用户加入组织。 仅组织钩子。</td>
</tr>
<tr>
<td><code>page_build</code></td>
<td>每次页面网站建立时。</td>
</tr>
<tr>
<td><code>project_card</code></td>
<td>项目卡片创建，更新或删除。</td>
</tr>
<tr>
<td><code>project_column</code></td>
<td>项目 <code>column</code> 创建，更新，移动或删除时。</td>
</tr>
<tr>
<td><code>project</code></td>
<td>项目创建、编辑、或删除时。</td>
</tr>
<tr>
<td><code>public</code></td>
<td><code>Repository</code> 从private更改为public时。</td>
</tr>
<tr>
<td><code>pull_request_review_comment</code></td>
<td>每次pull请求被创建，编辑或删除差异注释时。</td>
</tr>
<tr>
<td><code>pull_request_review</code></td>
<td>每次提交Pull请求审核时。</td>
</tr>
<tr>
<td><code>pull_request</code></td>
<td>每次 pull 请求被打开，关闭，重新打开，编辑，分配，未分配，请求审核，审核请求已移除，已标记，未标记或已同步时。</td>
</tr>
<tr>
<td><code>push</code></td>
<td>每次 push 时（默认事件）</td>
</tr>
</tbody>
</table>
<p><code>repository</code>|每次 <code>Repository</code> 被创建、删除、公开或 私有化时。<br><code>release</code>|每次 <code>release</code> 被发布到 <code>Repository</code> 中时<br><code>status</code> |每次从API中更新版本库状态时。<br><code>team</code>   |任何时候创建，删除，修改 <code>Repository</code> 的团队。 仅组织钩子<br><code>team_add</code>|每次添加或修改 <code>Repository</code> 中的 team 成员时。<br><code>watch</code>  |每次用户对<code>Repository</code>加星标时。</p>
<h2 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h2><p>每个事件类型具有特定的有效载荷格式以及相关的事件信息。 即，不同的事件被触发发送到我们配置的 <code>URL</code> 的 <code>POST</code> 数据格式和内容也会不同。</p>
<p>例如，一个 <code>commit_comment</code> 事件如果被触发，将会向 URL 发送类似下面的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;action&quot;: &quot;created&quot;,</div><div class="line">  &quot;comment&quot;: &#123;</div><div class="line">    &quot;url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/comments/11056394&quot;,</div><div class="line">    &quot;html_url&quot;: &quot;https://github.com/baxterthehacker/public-repo/commit/9049f1265b7d61be4a8904a9a27120d2064dab3b#commitcomment-11056394&quot;,</div><div class="line">    &quot;id&quot;: 11056394,</div><div class="line">    &quot;user&quot;: &#123;</div><div class="line">      &quot;login&quot;: &quot;baxterthehacker&quot;,</div><div class="line">      &quot;id&quot;: 6752317,</div><div class="line">      &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6752317?v=3&quot;,</div><div class="line">      &quot;gravatar_id&quot;: &quot;&quot;,</div><div class="line">      &quot;url&quot;: &quot;https://api.github.com/users/baxterthehacker&quot;,</div><div class="line">      &quot;html_url&quot;: &quot;https://github.com/baxterthehacker&quot;,</div><div class="line">      &quot;followers_url&quot;: &quot;https://api.github.com/users/baxterthehacker/followers&quot;,</div><div class="line">      &quot;following_url&quot;: &quot;https://api.github.com/users/baxterthehacker/following&#123;/other_user&#125;&quot;,</div><div class="line">      &quot;gists_url&quot;: &quot;https://api.github.com/users/baxterthehacker/gists&#123;/gist_id&#125;&quot;,</div><div class="line">      &quot;starred_url&quot;: &quot;https://api.github.com/users/baxterthehacker/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,</div><div class="line">      &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/baxterthehacker/subscriptions&quot;,</div><div class="line">      &quot;organizations_url&quot;: &quot;https://api.github.com/users/baxterthehacker/orgs&quot;,</div><div class="line">      &quot;repos_url&quot;: &quot;https://api.github.com/users/baxterthehacker/repos&quot;,</div><div class="line">      &quot;events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/events&#123;/privacy&#125;&quot;,</div><div class="line">      &quot;received_events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/received_events&quot;,</div><div class="line">      &quot;type&quot;: &quot;User&quot;,</div><div class="line">      &quot;site_admin&quot;: false</div><div class="line">    &#125;,</div><div class="line">    &quot;position&quot;: null,</div><div class="line">    &quot;line&quot;: null,</div><div class="line">    &quot;path&quot;: null,</div><div class="line">    &quot;commit_id&quot;: &quot;9049f1265b7d61be4a8904a9a27120d2064dab3b&quot;,</div><div class="line">    &quot;created_at&quot;: &quot;2015-05-05T23:40:29Z&quot;,</div><div class="line">    &quot;updated_at&quot;: &quot;2015-05-05T23:40:29Z&quot;,</div><div class="line">    &quot;body&quot;: &quot;This is a really good change! :+1:&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;repository&quot;: &#123;</div><div class="line">    &quot;id&quot;: 35129377,</div><div class="line">    &quot;name&quot;: &quot;public-repo&quot;,</div><div class="line">    &quot;full_name&quot;: &quot;baxterthehacker/public-repo&quot;,</div><div class="line">    &quot;owner&quot;: &#123;</div><div class="line">      &quot;login&quot;: &quot;baxterthehacker&quot;,</div><div class="line">      &quot;id&quot;: 6752317,</div><div class="line">      &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6752317?v=3&quot;,</div><div class="line">      &quot;gravatar_id&quot;: &quot;&quot;,</div><div class="line">      &quot;url&quot;: &quot;https://api.github.com/users/baxterthehacker&quot;,</div><div class="line">      &quot;html_url&quot;: &quot;https://github.com/baxterthehacker&quot;,</div><div class="line">      &quot;followers_url&quot;: &quot;https://api.github.com/users/baxterthehacker/followers&quot;,</div><div class="line">      &quot;following_url&quot;: &quot;https://api.github.com/users/baxterthehacker/following&#123;/other_user&#125;&quot;,</div><div class="line">      &quot;gists_url&quot;: &quot;https://api.github.com/users/baxterthehacker/gists&#123;/gist_id&#125;&quot;,</div><div class="line">      &quot;starred_url&quot;: &quot;https://api.github.com/users/baxterthehacker/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,</div><div class="line">      &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/baxterthehacker/subscriptions&quot;,</div><div class="line">      &quot;organizations_url&quot;: &quot;https://api.github.com/users/baxterthehacker/orgs&quot;,</div><div class="line">      &quot;repos_url&quot;: &quot;https://api.github.com/users/baxterthehacker/repos&quot;,</div><div class="line">      &quot;events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/events&#123;/privacy&#125;&quot;,</div><div class="line">      &quot;received_events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/received_events&quot;,</div><div class="line">      &quot;type&quot;: &quot;User&quot;,</div><div class="line">      &quot;site_admin&quot;: false</div><div class="line">    &#125;,</div><div class="line">    &quot;private&quot;: false,</div><div class="line">    &quot;html_url&quot;: &quot;https://github.com/baxterthehacker/public-repo&quot;,</div><div class="line">    &quot;description&quot;: &quot;&quot;,</div><div class="line">    &quot;fork&quot;: false,</div><div class="line">    &quot;url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo&quot;,</div><div class="line">    &quot;forks_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/forks&quot;,</div><div class="line">    &quot;keys_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/keys&#123;/key_id&#125;&quot;,</div><div class="line">    &quot;collaborators_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/collaborators&#123;/collaborator&#125;&quot;,</div><div class="line">    &quot;teams_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/teams&quot;,</div><div class="line">    &quot;hooks_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/hooks&quot;,</div><div class="line">    &quot;issue_events_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/issues/events&#123;/number&#125;&quot;,</div><div class="line">    &quot;events_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/events&quot;,</div><div class="line">    &quot;assignees_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/assignees&#123;/user&#125;&quot;,</div><div class="line">    &quot;branches_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/branches&#123;/branch&#125;&quot;,</div><div class="line">    &quot;tags_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/tags&quot;,</div><div class="line">    &quot;blobs_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/blobs&#123;/sha&#125;&quot;,</div><div class="line">    &quot;git_tags_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/tags&#123;/sha&#125;&quot;,</div><div class="line">    &quot;git_refs_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/refs&#123;/sha&#125;&quot;,</div><div class="line">    &quot;trees_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/trees&#123;/sha&#125;&quot;,</div><div class="line">    &quot;statuses_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/statuses/&#123;sha&#125;&quot;,</div><div class="line">    &quot;languages_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/languages&quot;,</div><div class="line">    &quot;stargazers_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/stargazers&quot;,</div><div class="line">    &quot;contributors_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/contributors&quot;,</div><div class="line">    &quot;subscribers_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/subscribers&quot;,</div><div class="line">    &quot;subscription_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/subscription&quot;,</div><div class="line">    &quot;commits_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/commits&#123;/sha&#125;&quot;,</div><div class="line">    &quot;git_commits_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/commits&#123;/sha&#125;&quot;,</div><div class="line">    &quot;comments_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/comments&#123;/number&#125;&quot;,</div><div class="line">    &quot;issue_comment_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/issues/comments&#123;/number&#125;&quot;,</div><div class="line">    &quot;contents_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/contents/&#123;+path&#125;&quot;,</div><div class="line">    &quot;compare_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/compare/&#123;base&#125;...&#123;head&#125;&quot;,</div><div class="line">    &quot;merges_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/merges&quot;,</div><div class="line">    &quot;archive_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/&#123;archive_format&#125;&#123;/ref&#125;&quot;,</div><div class="line">    &quot;downloads_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/downloads&quot;,</div><div class="line">    &quot;issues_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/issues&#123;/number&#125;&quot;,</div><div class="line">    &quot;pulls_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/pulls&#123;/number&#125;&quot;,</div><div class="line">    &quot;milestones_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/milestones&#123;/number&#125;&quot;,</div><div class="line">    &quot;notifications_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/notifications&#123;?since,all,participating&#125;&quot;,</div><div class="line">    &quot;labels_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/labels&#123;/name&#125;&quot;,</div><div class="line">    &quot;releases_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/releases&#123;/id&#125;&quot;,</div><div class="line">    &quot;created_at&quot;: &quot;2015-05-05T23:40:12Z&quot;,</div><div class="line">    &quot;updated_at&quot;: &quot;2015-05-05T23:40:12Z&quot;,</div><div class="line">    &quot;pushed_at&quot;: &quot;2015-05-05T23:40:27Z&quot;,</div><div class="line">    &quot;git_url&quot;: &quot;git://github.com/baxterthehacker/public-repo.git&quot;,</div><div class="line">    &quot;ssh_url&quot;: &quot;git@github.com:baxterthehacker/public-repo.git&quot;,</div><div class="line">    &quot;clone_url&quot;: &quot;https://github.com/baxterthehacker/public-repo.git&quot;,</div><div class="line">    &quot;svn_url&quot;: &quot;https://github.com/baxterthehacker/public-repo&quot;,</div><div class="line">    &quot;homepage&quot;: null,</div><div class="line">    &quot;size&quot;: 0,</div><div class="line">    &quot;stargazers_count&quot;: 0,</div><div class="line">    &quot;watchers_count&quot;: 0,</div><div class="line">    &quot;language&quot;: null,</div><div class="line">    &quot;has_issues&quot;: true,</div><div class="line">    &quot;has_downloads&quot;: true,</div><div class="line">    &quot;has_wiki&quot;: true,</div><div class="line">    &quot;has_pages&quot;: true,</div><div class="line">    &quot;forks_count&quot;: 0,</div><div class="line">    &quot;mirror_url&quot;: null,</div><div class="line">    &quot;open_issues_count&quot;: 2,</div><div class="line">    &quot;forks&quot;: 0,</div><div class="line">    &quot;open_issues&quot;: 2,</div><div class="line">    &quot;watchers&quot;: 0,</div><div class="line">    &quot;default_branch&quot;: &quot;master&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;sender&quot;: &#123;</div><div class="line">    &quot;login&quot;: &quot;baxterthehacker&quot;,</div><div class="line">    &quot;id&quot;: 6752317,</div><div class="line">    &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6752317?v=3&quot;,</div><div class="line">    &quot;gravatar_id&quot;: &quot;&quot;,</div><div class="line">    &quot;url&quot;: &quot;https://api.github.com/users/baxterthehacker&quot;,</div><div class="line">    &quot;html_url&quot;: &quot;https://github.com/baxterthehacker&quot;,</div><div class="line">    &quot;followers_url&quot;: &quot;https://api.github.com/users/baxterthehacker/followers&quot;,</div><div class="line">    &quot;following_url&quot;: &quot;https://api.github.com/users/baxterthehacker/following&#123;/other_user&#125;&quot;,</div><div class="line">    &quot;gists_url&quot;: &quot;https://api.github.com/users/baxterthehacker/gists&#123;/gist_id&#125;&quot;,</div><div class="line">    &quot;starred_url&quot;: &quot;https://api.github.com/users/baxterthehacker/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,</div><div class="line">    &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/baxterthehacker/subscriptions&quot;,</div><div class="line">    &quot;organizations_url&quot;: &quot;https://api.github.com/users/baxterthehacker/orgs&quot;,</div><div class="line">    &quot;repos_url&quot;: &quot;https://api.github.com/users/baxterthehacker/repos&quot;,</div><div class="line">    &quot;events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/events&#123;/privacy&#125;&quot;,</div><div class="line">    &quot;received_events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/received_events&quot;,</div><div class="line">    &quot;type&quot;: &quot;User&quot;,</div><div class="line">    &quot;site_admin&quot;: false</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其它事件的内容和格式，参考(<a href="https://developer.github.com/v3/activity/events/types/" target="_blank" rel="external">https://developer.github.com/v3/activity/events/types/</a>)</p>
<p><strong>注意：</strong> 有效负载上限为<code>5 MB</code>。 如果我们的事件产生一个更大的有效载荷，<code>webhook</code> 将不会被触发。 例如，如果同时推送了多个分支或标签，则可能会发生在创建事件上。 所以建议监控我们的有效负载大小以确保 <code>webhooks</code> 能够被触发。</p>
<h3 id="请求Header"><a href="#请求Header" class="headerlink" title="请求Header"></a>请求Header</h3><p>对 <code>Webhook</code> 配置的 <code>URL</code> 端点发出的 <code>HTTP</code> 请求将包含几个特殊<code>Header</code>头：</p>
<table>
<thead>
<tr>
<th><code>Header</code></th>
<th><code>Description</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X-GitHub-Event</code></td>
<td>触发本次请求的事件的名称。</td>
</tr>
<tr>
<td><code>X-Hub-Signature</code></td>
<td>HMAC对有效负载的十六进制摘要，使用钩子的密钥作为密钥（如果已配置）。</td>
</tr>
<tr>
<td><code>X-GitHub-Delivery</code></td>
<td>本次请求的唯一ID。</td>
</tr>
</tbody>
</table>
<p>此外，请求的<code>User-Agent</code>将具有前缀<code>GitHub-Hookshot/</code>。</p>
<p>请求示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">POST /payload HTTP/1.1</div><div class="line"></div><div class="line">Host: localhost:4567</div><div class="line">X-Github-Delivery: 72d3162e-cc78-11e3-81ab-4c9367dc0958</div><div class="line">User-Agent: GitHub-Hookshot/044aadd</div><div class="line">Content-Type: application/json</div><div class="line">Content-Length: 6615</div><div class="line">X-GitHub-Event: issues</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;action&quot;: &quot;opened&quot;,</div><div class="line">  &quot;issue&quot;: &#123;</div><div class="line">    &quot;url&quot;: &quot;https://api.github.com/repos/octocat/Hello-World/issues/1347&quot;,</div><div class="line">    &quot;number&quot;: 1347,</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  &quot;repository&quot; : &#123;</div><div class="line">    &quot;id&quot;: 1296269,</div><div class="line">    &quot;full_name&quot;: &quot;octocat/Hello-World&quot;,</div><div class="line">    &quot;owner&quot;: &#123;</div><div class="line">      &quot;login&quot;: &quot;octocat&quot;,</div><div class="line">      &quot;id&quot;: 1,</div><div class="line">      ...</div><div class="line">    &#125;,</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  &quot;sender&quot;: &#123;</div><div class="line">    &quot;login&quot;: &quot;octocat&quot;,</div><div class="line">    &quot;id&quot;: 1,</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Ping事件"><a href="#Ping事件" class="headerlink" title="Ping事件"></a><code>Ping</code>事件</h2><p>当我们创建新的 <code>webhooks</code> 时，<code>Github</code> 会向我们配置的 <code>URL</code> 发送一个简单的 <code>ping</code> 事件，以检测我们配置的 <code>URL</code> 是否正确可用。 该事件未存储，因此无法通过<code>Events API</code>检索。 可以通过调用<code>ping</code>端点再次触发<code>ping</code>。</p>
<p><code>Ping</code>事件有效负载</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>zen</code></td>
<td><code>GitHub</code>产生的随机字符串</td>
</tr>
<tr>
<td><code>hook_id</code></td>
<td>触发<code>ping</code>的<code>webhook</code>的<code>ID</code></td>
</tr>
<tr>
<td><code>hook</code></td>
<td><code>webhook</code>配置</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Webhooks&lt;/code&gt; 是 &lt;code&gt;Github&lt;/code&gt; 为我们提供的一种订阅某些时间的功能。当这些事件被触发时，&lt;code&gt;Github&lt;/code&gt; 会将信息以&lt;code&gt;POST&lt;/code&gt;方式发送到我们指定的&lt;code&gt;URL&lt;/code&gt;。通过&lt;code&gt;Webhooks&lt;/code&gt; 我们可以记录更新，触发&lt;code&gt;CI构建&lt;/code&gt;、更新备份镜像，甚至服务器的自动部署等等我们能够想到的各个地方。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github&lt;/code&gt; 上对于每个账号或者项目上的每个事件最多可以创建20个 &lt;code&gt;Webhooks&lt;/code&gt; 。&lt;br&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://weizhimiao.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="git" scheme="https://weizhimiao.github.io/tags/git/"/>
    
      <category term="版本控制" scheme="https://weizhimiao.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之客户端C-服务器S设计与实现</title>
    <link href="https://weizhimiao.github.io/2017/01/22/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AFC-%E6%9C%8D%E5%8A%A1%E5%99%A8S%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2017/01/22/深入了解Redis之客户端C-服务器S设计与实现/</id>
    <published>2017-01-22T12:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道<code>Redis</code>是一个典型的<code>C/S</code>设计程序，一个服务器可以与多个客户端建立连接。通过<code>I/O</code>多路复用技术实现的文件事件处理器，<code>Redis</code>服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p>
<p>所以，对于<code>Redis</code>我们分为这两部分来了解，</p>
<ul>
<li><code>Redis</code>服务器维护和管理客户端状态的方法</li>
<li><code>Redis</code>服务器的运行机制</li>
</ul>
<a id="more"></a>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的 <code>redisClient</code> 结构（客户端状态），这个结构保存了客户端当前的状态信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">typedef struct redisClent&#123;</div><div class="line"></div><div class="line">  // ...</div><div class="line">  // 客户端的套接字描述符</div><div class="line">  int fd;</div><div class="line">  // 客户端的名字</div><div class="line">  robj *name;</div><div class="line">  // 客户端的标识值（flag）</div><div class="line">  int flags;</div><div class="line">  // 输入缓冲区</div><div class="line">  sqs querybuf;</div><div class="line">  // 命令与命令参数</div><div class="line">  robj **argv;</div><div class="line">  // 命令参数个数</div><div class="line">  int argc;</div><div class="line">  //命令的实现函数</div><div class="line">  struct redisCommand *cmd;</div><div class="line">  //输出缓冲区</div><div class="line">  char buf[REDIS_REPLY_CHUNK_BYTES];</div><div class="line">  //</div><div class="line">  int bufpos;</div><div class="line">  // 身份认证相关属性</div><div class="line">  int authenticated;</div><div class="line">  //</div><div class="line">  time_t ctime;</div><div class="line">  time_t lastinteraction;</div><div class="line">  time_t obuf_soft_limit_reached_time;</div><div class="line"></div><div class="line">  // ...</div><div class="line"></div><div class="line">&#125; redisClient</div></pre></td></tr></table></figure></p>
<p><code>Redis</code>服务器状态结构的<code>clients</code>属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构(<code>redisClient</code>)，对客户端执行批量操作或者查找某个指定的客户端，都可以通过遍历 <code>clients</code> 链表来完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct redisServer &#123;</div><div class="line">  //...</div><div class="line"></div><div class="line">  // 一个链表，保存了所有客户端状态</div><div class="line">  list *clients;</div><div class="line"></div><div class="line">  //...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如图，是一个与三个客户端进行连接的服务器。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170116/clientsLianBiao.png" alt="clients 链表"></p>
<h3 id="客户端类型"><a href="#客户端类型" class="headerlink" title="客户端类型"></a>客户端类型</h3><p>按照处理的命令请求的来源，客户端可以分为以下两种：</p>
<ul>
<li><p>伪客户端</p>
<blockquote>
<p>处理来自<code>AOF</code>文件或者Lua脚本的命令请求。目前<code>Redis</code>会在两个地方用到伪客户端，</p>
<ul>
<li>用于载入 <code>AOF</code> 文件并还原数据库状态</li>
<li>用于执行<code>Lua</code>脚本中包含的<code>Redis</code>命令</li>
</ul>
</blockquote>
</li>
<li><p>普通客户端</p>
<blockquote>
<p>处理来自网络的普通命令请求。</p>
</blockquote>
</li>
</ul>
<p>两者的主要区别是，在客户端状态结构（<code>redisClient</code>）中的 <code>fd</code> 属性，伪客户端的该属性值为<code>-1</code>，普通客户端的该属性的值是普通客户端的套接字的描述符。</p>
<h3 id="客户端状态属性"><a href="#客户端状态属性" class="headerlink" title="客户端状态属性"></a>客户端状态属性</h3><p>客户端状态属性主要可以分为两类：</p>
<ul>
<li><p>比较通用的属性</p>
<ul>
<li>套接字描述，根据客户端端类型的不同，该属性的值可以是<code>-1</code> 或者是大于<code>-1</code> 的整数。</li>
<li>名字，默认情况下，一个连接到服务器的客户端是没有名字的，使用 <code>CLIENT setname</code> 可以为客户端设置一个名字。</li>
<li>标识，记录了客户端的角色（<code>role</code>）如，主服务器，从服务器，低版本的从服务器，专门处理<code>Lua</code>脚本的伪客户端；以及客户端目前所处的状态，如客户端正在执行<code>MONITOR</code>命令，客户端正在被<code>BRPOP</code>、<code>BLPOP</code>等命令阻塞，客户端正在执行事务等等。</li>
<li>输入缓冲区，用于保存客户端发送的命令请求。</li>
<li>命令与命令参数，保存命令参数以及命令参数个数。</li>
<li>命令的实现函数，保存命令的实现函数。</li>
<li>输出缓冲区，保存执行命令所得的命令回复内容。</li>
<li>身份验证，用于记录客户端是否通过了身份验证。</li>
<li>时间，记录创建客户端的时间、客户端与服务器最后一次交互的时间、输出缓冲区第一次到达软性限制的时间等等。</li>
</ul>
</li>
<li><p>和特定功能相关的属性</p>
<ul>
<li><code>db</code>属性（数据库操作时需要）</li>
<li><code>dictid</code>属性（数据库操作时需要）</li>
<li><code>mstate</code>属性（执行事务时需要）</li>
<li><code>watched_keys</code>属性（执行<code>WATCH</code>命令时需要）</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 clients 链表的末尾。</p>
<p>对于Lua脚本的伪客户端，服务器会在初始化时，创建负责执行Lua脚本中包含的<code>Redis</code>命令的伪客户端，并将这个伪客户端关联在服务器状态结构的 <code>lua_client</code> 属性中。且 <code>lua_client</code> 伪客户端会在服务器运行的整个生命周期中会一直存在，只有在服务器关闭时，这个伪客户端才会关闭。</p>
<p>对于用户载入 <code>AOF</code> 文件还原数据库的伪客户端，会在服务器载入<code>AOF</code>文件时创建，用于执行<code>AOF</code>文件包含的<code>Redis</code>命令，在完成载入操作之后，这个伪客户端就会关闭。</p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>对于一个普通客户端可以有多种原因而被关闭，</p>
<ul>
<li>客户端进程推出或者被杀死</li>
<li>客户单向服务器端发送了不符合协议格式的命令请求</li>
<li>客户端成为了 <code>CLIENT KILL</code> 命令的目标</li>
<li>客户端空转时间 大于了 <code>timeout</code> 的设置</li>
<li>客户端发送的命令请求的大小超过了输入缓冲区的大小限制（默认 <code>1GB</code>）</li>
<li>发送给客户端的命令回复的大小超过了输出缓冲区的限制大小</li>
</ul>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p><code>Redis</code> 服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p>
<h3 id="一条请求命令的执行过程"><a href="#一条请求命令的执行过程" class="headerlink" title="一条请求命令的执行过程"></a>一条请求命令的执行过程</h3><p>一条命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。，例如，执行 <code>redis&gt; SET KEY VALUE</code>这条命令的执行过程如下：</p>
<ul>
<li>1）客户端向服务器发送命令请求 <code>SET KEY VALUE</code></li>
<li>2）服务器接收并处理客户端发送过来的命令请求 <code>SET KEY VALUE</code>，在数据库中进行设置操作，并返回命令回复 <code>OK</code></li>
<li>3）服务器将命令回复<code>OK</code>发送给客户端</li>
<li>4）客户端接收服务器返回的命令回复<code>OK</code>，并将这个回复打印给用户</li>
</ul>
<h4 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h4><p><img src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanJieShouBingFaSongMingLingQingQiuDeGuoCheng.png" alt="客户端接收并发送命令请求的过程"><br>如图所示，用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令发送服务器。</p>
<p>示例，假设用户在客户端键入了命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SET KEY VALUE</div></pre></td></tr></table></figure></p>
<p>那么客户端会将这个命令转换成协议格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n</div></pre></td></tr></table></figure></p>
<p>然后将这段协议内容发送给服务器。</p>
<h4 id="服务器读取命令请求"><a href="#服务器读取命令请求" class="headerlink" title="服务器读取命令请求"></a>服务器读取命令请求</h4><p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求出来器来执行一下操作。</p>
<ul>
<li>1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里。</li>
<li>2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及参数的个数，然后分别保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性中。</li>
<li>3）调用命令执行器，执行客户端指定的命令。</li>
</ul>
<p>示例，</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanZhuangTaiZhongDeMingLingQingQiu.png" alt="客户端状态中的命令请求"></p>
<p>服务器将命令请求保存到客户端状态的输入缓冲区。之后，分析程序将对输入缓冲区的协议进行分析，并将分析结果保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性里。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanZhuangTaiDeargvShuXingHeargcShuXing.png" alt="客户端状态的argv属性和argc属性"></p>
<h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>分析程序将分析结果保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性里之后，服务器将通过调用命令执行器来完成执行命令所需的余下步骤。</p>
<ul>
<li><p>命令执行器：查找命令实现</p>
<blockquote>
<p>根据客户端状态的 <code>argv[0]</code> 参数，在命令表（<code>command table</code>） 中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性中。</p>
</blockquote>
</li>
<li><p>命令执行器：执行预备操作</p>
<blockquote>
<p>到目前为止，服务器已经将执行命令所需的命令实现函数（<code>cmd</code>属性）、参数（<code>argv</code>属性）、参数个数（<code>argc</code>属性）都收集齐了。但在真正执行命令前，还需要进行一些预备操作，从而确保命令能够正确的、顺序被执行。这些操作有，</p>
<ul>
<li>检查实现函数是否为空</li>
<li>检查参数个数满足当前实现函数的要求</li>
<li>检查客户端是否已经通过了身份验证</li>
<li>如果服务器打开了 <code>maxmemory</code> 功能，那么检查服务器的内从占用情况，并在有需要的情况下回收内存</li>
<li>如果服务器上一次执行 <code>BGSAVE</code> 命令出错，且打开了 <code>stop-writes-on-bgsave-error</code> 功能，且服务器当前要执行的是一个写命令，则拒绝执行这个命令，并返回错误。</li>
<li>检查服务器是否正处于某种状态（正在用<code>subscribe</code>命令订阅频道、正在用<code>psubscribe</code>命令订阅模式、正在进行数据载入、正在阻塞、正在执行事务），如果处于某种状态之下，则需要分别当前命令是否可以在该状态下被执行。</li>
<li>如果服务器打开了监视功能，那么服务器会将要执行的命令和参数等信息，发送给监视器。</li>
</ul>
<p>当完成以上操作之后，服务器就可以开始真正执行命令了。</p>
</blockquote>
</li>
<li><p>命令执行器：调用命令的实现函数</p>
<blockquote>
<p>因为之前服务器已经将要执行的命令的实现保存到了客户端状态的cmd属性、参数和个数分别保存到了<code>argv</code>属性和<code>argc</code>属性，所以当服务器决定要执行命令时，是需要执行就可以了。<code>client-&gt;cmd-&gt;proc(client);</code>实现函数执行完操作之后，会产生相应的命令回复，这些回复会保存在客户端状态的输出缓冲区里，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。</p>
</blockquote>
</li>
<li><p>命令执行器：执行后续操作</p>
<blockquote>
<p>在执行完函数之后，服务器还需要执行一些后续工作，</p>
<ul>
<li>如果服务器开启了慢日志功能，那么检查刚执行的命令是否符合条件</li>
<li>更新命令的<code>redisCommand</code>结构中<code>milliseconds</code>属性（执行命令耗费时长），和<code>calls</code>属性（被调用次数）</li>
<li>如果服务器开启<code>AOF</code>持久化功能，将刚执行的命令传播给所有从服务器</li>
</ul>
<p>到此，服务器对于当前命令的执行就告一段落了。</p>
</blockquote>
</li>
</ul>
<h4 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h4><p>前面的命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变成可写状态时，服务器就会执行命令回复处理器，将保存在输出缓冲区中的命令回复发送给客户端。</p>
<p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。</p>
<h4 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h4><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanJieShouBingDaYinMingLingHuiFuDeGuoCheng.png" alt="客户端接收并打印显示命令回复的过程"></p>
<h3 id="serverCron-函数"><a href="#serverCron-函数" class="headerlink" title="serverCron 函数"></a>serverCron 函数</h3><p><code>redis</code>服务器中的<code>serverCron</code>函数负责管理服务器的资源，并保持服务器自身的良好运转，其默认每隔 <code>100 ms</code> 执行一次。</p>
<p><code>serverCron</code>函数需要做的事情，</p>
<ul>
<li>更新服务器的时间缓存（用于获得当前时间时）</li>
<li>更新<code>LRU</code>时钟（用于计算键的空转事件）</li>
<li>更新服务器每秒执行命令次数</li>
<li>更新服务器内存峰值记录</li>
<li>处理<code>SIGTERM</code>信号</li>
<li>管理客户端资源</li>
<li>管理数据库资源</li>
<li>执行被延迟的<code>BGREWRITEAOF</code></li>
<li>检查持久化操作的运行状态</li>
<li>将<code>AOF</code>缓冲区中的内容写入<code>AOF</code>文件</li>
<li>关闭异步客户端</li>
<li>增加<code>cronloops</code>计数器值</li>
</ul>
<h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个<code>redis</code>服务器从启动到能够接受客户端的命令请求，需要经过一些列的初始化和设置过程，如</p>
<ul>
<li>初始化服务器状态结构</li>
<li>载入配置选项</li>
<li>初始化服务器数据结构</li>
<li>还原数据库状态</li>
<li>执行事件循环</li>
</ul>
<h4 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h4><p>服务器状态结构指的就是 <code>redisServer</code> 结构，初始化服务器的第一步就是创建一个 <code>struct redisServer</code>类型的实例变量 <code>server</code> 作为服务器的状态，并为结构中的各个属性设置默认值。</p>
<p>具体初始化工作由 <code>redis.c/initServerConfig</code> 函数完成，<code>initServerConfig</code> 函数完成的主要工作是，</p>
<ul>
<li>设置服务器的运行ID</li>
<li>设置服务器的默认运行频率</li>
<li>设置服务器的默认配置文件路径</li>
<li>设置服务器的运行架构</li>
<li>设置服务器的默认端口号</li>
<li>设置服务器的默认<code>RDB</code>持久化条件和<code>AOF</code>持久化条件</li>
<li>创建命令表</li>
</ul>
<p>当<code>initServerConfig</code> 函数执行完毕之后，服务器就可以进入初始化的第二阶段–载入配置选项</p>
<h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>服务器在用 <code>initServerConfig</code> 函数初始化完 <code>server</code> 变量之后，就会载入用户给指定的配置参数和配置文件，并根据用户设定的配置，对 <code>server</code> 变量相关属性进行修改：</p>
<p>例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-server --port 10086</div></pre></td></tr></table></figure></p>
<p>那么我们就会修改了服务器默认的运行端口号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-server redis.conf</div></pre></td></tr></table></figure>
<p>按照配置文件中的配置，修改 <code>server</code> 变量属性。</p>
<p>服务器在载入用户指定的配置选项，并对<code>server</code>状态进行更新之后，服务器就可以进入初始化的第三个阶段–初始化服务器数据结构。</p>
<h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>在之前执行 <code>initServerConfig</code> 函数初始化 <code>server</code> 状态，程序只创建了命令表的一个数据结构，不过了命令表之外，服务器状态还包含其他数据结构。</p>
<ul>
<li><code>server.client</code> 链表，记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个<code>redisClient</code>结构实例。</li>
<li><code>server.db</code> 数组，包含了服务器的所有数据库。</li>
<li><code>server.pubsub_channels</code> 字典，保存频道订阅信息。</li>
<li><code>server.pubsub_patterns</code> 链表，保存模式订阅信息。</li>
<li><code>server.lua</code>，保存执行<code>lua</code>脚本的<code>Lua</code>环境。</li>
<li><code>server.slowlog</code> ，保存慢查询日志。</li>
</ul>
<p>这些数据结构是通过 <code>iniServer</code> 函数来实现，为这些数据结构分配内存，并设置或关联初始化值。</p>
<p><code>iniServer</code> 函数除了初始化这些数据结构之外，还会进行一些其他非常重要的设置操作，包括:</p>
<ul>
<li>为服务器是指进程信号处理器</li>
<li>创建共享对象：这些对象包括<code>redis</code>服务器经常用到的一些值（如，包含“OK”回复的字符串对象，包含“ERR”回复的字符串对象，等等），服务器通过重用这些对象来避免反复重复的创建相同的对象。</li>
<li>打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接收客户端连接。</li>
<li>为 <code>serverCron</code> 函数创建时间事件，等待服务器正式运行时实行 <code>serverCron</code> 函数。</li>
<li>如果<code>AOF</code>持久化功能已经打开，那么打开现有的<code>AOF</code>文件，如果<code>AOF</code>文件不存在，那么创建并打开一个新的<code>AOF</code>文件，为<code>AOF</code>文件写入做好准备。</li>
<li>初始化后台<code>I/O</code>模块（<code>bio</code>），为将来的<code>I/O</code>操作做好准备。</li>
</ul>
<p>当<code>iniServer</code>函数执行完毕之后，服务器会用 <code>ASCII</code>字符在日志中打印出<code>Redis</code>的图标，以及Redis的版本信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">root@5254004e45d0:/srv/rorapps/redis/redis-2.8.15# src/redis-server</div><div class="line">[16445] 16 Sep 09:54:32.684 # Warning: no config file specified, using the default config. In order to specify a config file use src/redis-server /path/to/redis.conf</div><div class="line">[16445] 16 Sep 09:54:32.686 * Increased maximum number of open files to 10032 (it was originally set to 1024).</div><div class="line">				_._												  </div><div class="line">		   _.-``__ &apos;&apos;-._											 </div><div class="line">	  _.-``	`.  `_.  &apos;&apos;-._		   Redis 2.8.15 (00000000/0) 64 bit</div><div class="line">  .-`` .-```.  ```\/	_.,_ &apos;&apos;-._								   </div><div class="line"> (	&apos;	  ,	   .-`  | `,	)	 Running in stand alone mode</div><div class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|	 Port: 6379</div><div class="line"> |	`-._   `._	/	 _.-&apos;	|	 PID: 16445</div><div class="line">  `-._	`-._  `-./  _.-&apos;	_.-&apos;								   </div><div class="line"> |`-._`-._	`-.__.-&apos;	_.-&apos;_.-&apos;|								  </div><div class="line"> |	`-._`-._		_.-&apos;_.-&apos;	|		   http://redis.io		</div><div class="line">  `-._	`-._`-.__.-&apos;_.-&apos;	_.-&apos;								   </div><div class="line"> |`-._`-._	`-.__.-&apos;	_.-&apos;_.-&apos;|								  </div><div class="line"> |	`-._`-._		_.-&apos;_.-&apos;	|								  </div><div class="line">  `-._	`-._`-.__.-&apos;_.-&apos;	_.-&apos;								   </div><div class="line">	  `-._	`-.__.-&apos;	_.-&apos;									   </div><div class="line">		  `-._		_.-&apos;										   </div><div class="line">			  `-.__.-&apos;											   </div><div class="line"></div><div class="line">[16445] 16 Sep 09:54:32.688 # Server started, Redis version 2.8.15</div><div class="line">[16445] 16 Sep 09:54:32.688 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &apos;vm.overcommit_memory = 1&apos; to /etc/sysctl.conf and then reboot or run the command &apos;sysctl vm.overcommit_memory=1&apos; for this to take effect.</div><div class="line">[16445] 16 Sep 09:54:32.688 * The server is now ready to accept connections on port 6379</div></pre></td></tr></table></figure>
<h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><p>在完成对 <code>server</code> 变量的初始化之后，服务器需要载入 <code>RDB</code> 文件或者 <code>AOF</code> 文件，并根据文件记录的内容来还原服务器的数据库状态。</p>
<ul>
<li>如果服务器采用的是 <code>AOF</code>方式的持久化方式，那么服务器将使用<code>AOF</code>文件来还原数据库状态。</li>
<li>相反的如果服务器没有采用<code>AOF</code>方式的持久化方式，那么服务器使用<code>RDB</code>文件来还原服务器数据库状态。</li>
</ul>
<p>当服务器完成数据库的还原操作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费的时长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[5244] 21 Nov 22:43:49.084 * DB loaded from disk: 0.067 seconds</div></pre></td></tr></table></figure></p>
<h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>初始化的最后一步，服务器将打印以下日志，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[5244] 21 Nov 22:43:49.084 * The server is now ready to accept connections on port  6379</div></pre></td></tr></table></figure></p>
<p>并开始执行服务器的时间循环（<code>loop</code>）<br>。</p>
<p>至此，服务器的初始化操作就圆满完成。服务器从现在开始就可以接受客户端的连接请求，并处理客户端发来的命令请求了。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道&lt;code&gt;Redis&lt;/code&gt;是一个典型的&lt;code&gt;C/S&lt;/code&gt;设计程序，一个服务器可以与多个客户端建立连接。通过&lt;code&gt;I/O&lt;/code&gt;多路复用技术实现的文件事件处理器，&lt;code&gt;Redis&lt;/code&gt;服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。&lt;/p&gt;
&lt;p&gt;所以，对于&lt;code&gt;Redis&lt;/code&gt;我们分为这两部分来了解，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;服务器维护和管理客户端状态的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;服务器的运行机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之事件原理和实现</title>
    <link href="https://weizhimiao.github.io/2017/01/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2017/01/13/深入了解Redis之事件原理和实现/</id>
    <published>2017-01-13T12:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis服务器是一个事件驱动程序，其主要处理的事件主要可分为以下两类：</p>
<ul>
<li><p>文件事件(file event)</p>
<blockquote>
<p>Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信。</p>
</blockquote>
</li>
<li><p>时间事件(time event)</p>
<blockquote>
<p>Redis服务器中的一些操作（如，serverCron函数）需要在指定的时间点执行，而时间事件就是对这类定时操作的抽象。</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。</p>
<p>Redis基于Reactor模式开发了自己的文件事件（网络事件）处理器（file event handler）。其构成可分为四个部分，套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/WenJianShiJianChuLiQiDeSiGeZuChengBuFen.png" alt="事件处理器的四个组成部分"></p>
<ul>
<li>因为一个服务器通常会连接多个套接字，所以多个文件事件可能会并发的出现</li>
<li>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。（尽管会有多个文件事件同时出现，但是I/O多路复用程序会将之转化成一个有序的队列，依次将其传送给文件事件分派器。并且等上一个套接字处理完毕之后，I/O多路复用程序才会继续向文件事件分派器传送下一个套接字）</li>
<li>文件事件分派器接受I/O多路复用程序传送过来的套接字，并根据套接字产生的事件类型，调用相应的事件处理器。<blockquote>
<p>服务器会为执行不同任务的套接字关联不同的事件处理器，如有应答处理器、命令请求处理器、命令回复处理器。</p>
<h3 id="I-O多路复用程序的实现方式"><a href="#I-O多路复用程序的实现方式" class="headerlink" title="I/O多路复用程序的实现方式"></a>I/O多路复用程序的实现方式</h3></blockquote>
</li>
</ul>
<p>Redis的I/O复用程序的功能都是通过包装了常见的I/O多路复用函数库来实现的</p>
<ul>
<li>select</li>
<li>epoll</li>
<li>evport</li>
<li>kqueue</li>
</ul>
<p>I/O多路复用函数库的选择</p>
<blockquote>
<p>Redis用每个函数库都实现了相同的API，程序会在编译时自动判断当前系统下哪种多路复用函数库性能最高，而选择其作为Redis的I/O多路复用程序的底层实现。</p>
</blockquote>
<h3 id="文件事件的类型"><a href="#文件事件的类型" class="headerlink" title="文件事件的类型"></a>文件事件的类型</h3><ul>
<li><p>AE_READABLE 事件</p>
<blockquote>
<p>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作）</p>
</blockquote>
</li>
<li><p>AE_WRITABLE 事件</p>
<blockquote>
<p>当套接字变得可写时（客户端对套接字执行read操作）</p>
</blockquote>
</li>
</ul>
<p>I/O多路复用程序允许服务器同时监听套接字的 AE_READABLE 和 AE_WRITABLE 事件，并且如果一个套接字同时出现这两种事件，那么文件分派器会优先处理 AE_READABLE 事件，然后才会处理 AE_WRITABLE 事件。</p>
<h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><ul>
<li>连接应答处理器</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiDuiKeHuDuanDeLianJieQingQiuJinXingYingDa.png" alt="服务器对客户端的连接请求进行应答"></p>
<p>当Redis服务器进行初始化的时候，会将连接应答处理器和服务器监听套接字的 AE_READABLE 事件关联起来，当有客户端与服务器监听的套接字进行连接时，套接字就会产生 AE_READABLE 事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p>
<ul>
<li>命令请求处理器</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiJieShouKeHuDuanFaLaiDeMingLingQingQiu.png" alt="服务器接收客户端发来的命令请求"><br>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的 AE_READABLE 事件和命令请求处理器关联起来，当客户端向服务器端发送请求命令的时候，套接字就会产生 AE_READABLE 事件，引发命令请求处理器执行，并执行相应的套接字读入操作。</p>
<p>在客户端与服务器连接的整个过程中，服务器都会一直为客户端套接字的 AE_READABLE 事件关联命令请求处理器。</p>
<ul>
<li>命令回复处理器</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiXiangKeHuDuanFaSongMingLingHuiFu.png" alt="服务器向客户端发送命令回复"></p>
<p>当客户端有命令回复需要传送给客户端的时候，服务器会将客户端套接字的 AE_WRITABLE 事件和命令回复处理器关联起来，当客户端准备好接受服务器传回的命令回复时，就会产生 AE_WRITABLE 事件，引发命令回复处理器执行，并执行相应的套接字写入操作。</p>
<h3 id="一次完整的客户端与服务器连接事件的示例"><a href="#一次完整的客户端与服务器连接事件的示例" class="headerlink" title="一次完整的客户端与服务器连接事件的示例"></a>一次完整的客户端与服务器连接事件的示例</h3><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/KeHuDuanHeFuWuQiDeTongXinGuoCheng.png" alt="客户端和服务器的通信过程"></p>
<p>假设一个Redis服务器正在运行，那么这个服务器的监听套接字的 AE_READABLE 事件应该正在处于监听状态下，而该事件所对应的处理器为连接应答处理器。</p>
<p>这是如果有一个Redis客户端向服务器发起连接，那么监听套接字将会产生 AE_READABLE 事件，I/O多路复用程序将会将这个 AE_READABLE 事件传送给文件事件分派器，文件分派器将其分给连接应答处理器触发其执行。</p>
<p>应答处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端的套接字的 AE_READABLE 事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p>
<p>之后，假设客户端向主服务器发送命令请求，那么客户端套接字将产生 AE_READABLE 事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</p>
<p>执行程序执行完毕将会有对应的回复，为了将这些命令回复传送给客户端，服务器会将客户端套接字的 AE_WRITABLE 事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将会产生 AE_WRITABLE 事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联。</p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类：</p>
<ul>
<li>定时事件</li>
<li>周期性事件</li>
</ul>
<blockquote>
<p>目前版本的Redis只使用周期性事件，而没有使用定时事件。</p>
</blockquote>
<h3 id="时间事件的组成"><a href="#时间事件的组成" class="headerlink" title="时间事件的组成"></a>时间事件的组成</h3><p>一个时间事件由以下三个属性组成，</p>
<ul>
<li><p>id，服务器为时间事件生成的全局唯一的ID（标志号）。该ID是自增的，即新的事件ID总是比旧事件ID要大。</p>
</li>
<li><p>when，毫秒精度的时间戳，记录了事件的到达（arrive）时间</p>
</li>
<li><p>timeProc，时间事件处理器，一个函数</p>
</li>
</ul>
<p>不管是定期时间事件和还是周期性时间事件，其组成都是由这三个属性构成。其不同取决于时间事件处理器的返回值</p>
<ul>
<li>如果事件处理器返回 AE_NOMARE ,那么这个事件就是定时事件。该事件在第一次之后就会被删除，之后不在到达。</li>
<li>如果事件处理器返回 非AE_NOMARE 的整数值，那么这个事件就是周期性事件，该事件在到达之后，服务器会根据这个返回的值，对时间事件的 when 属性进行更新，让这个事件在一段时间之后可以再次到达。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Redis 服务器将所有的时间事件都放在了一个无序列表中，每当时间事件执行器运行时，它就会遍历成哥链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/YongLianBiaoLianJieQiLaiDeSanGeShiJianShiJian.png" alt="时间事件实现"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>持续运行的Redis服务器需要定期的对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行，这些定期操作是由 serverCron 函数负责执行。它的主要工作有，</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等</li>
<li>清理数据库中过期的键</li>
<li>关闭和清理连接失效的客户端</li>
<li>尝试进行AOF或RDB持久化操作</li>
<li>如果服务器是主服务器，那么对从服务器进行定期数据同步</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试</li>
</ul>
<p>Redis以周期性时间事件方式来运行 serverCron 函数，直至服务器关闭为止。</p>
<h2 id="文件事件和时间事件的关系"><a href="#文件事件和时间事件的关系" class="headerlink" title="文件事件和时间事件的关系"></a>文件事件和时间事件的关系</h2><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/ShiJianChuLiJiaoDuXiaDeFuWuQiYunXingLiuCheng.png" alt="事件角度下的服务器运行流程"></p>
<p>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件。并且由于文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器也不会终端正在执行的事件处理，也不会对事件进行抢占。</p>
<h3 id="Redis事件调度和执行的几条规则"><a href="#Redis事件调度和执行的几条规则" class="headerlink" title="Redis事件调度和执行的几条规则"></a>Redis事件调度和执行的几条规则</h3><ul>
<li><p>由于文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍然未有任何事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时，服务器就可以开始处理到达的时间事件了。</p>
</li>
<li><p>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间一般会比设定的时间稍晚一些。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis服务器是一个事件驱动程序，其主要处理的事件主要可分为以下两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件事件(file event)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时间事件(time event)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis服务器中的一些操作（如，serverCron函数）需要在指定的时间点执行，而时间事件就是对这类定时操作的抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之Redis的持久化方式</title>
    <link href="https://weizhimiao.github.io/2017/01/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8BRedis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>https://weizhimiao.github.io/2017/01/12/深入了解Redis之Redis的持久化方式/</id>
    <published>2017-01-12T13:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Redis是一个内存数据库，它所有的数据库状态都存储在内存中，所以如果想要在服务器故障、重启之后数据还在，就需要一个将这些数据持久化的一个功能。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/redisChiJiuHuaYuanLi.png" alt="redis持久化原理"></p>
<p>Redis提供了两种持久化的方式，</p>
<ul>
<li><p>RDB 持久化方式</p>
<blockquote>
<p>将数据库中的键值对及状态保存在持久化文件中</p>
</blockquote>
</li>
<li><p>AOF 持久化方式</p>
<blockquote>
<p>而AOF保存的是服务器所执行过的所有写命令</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiZaiRuWenJianShiDePanDuanLiuCheng.png" alt="服务器载入文件时的判断流程"></p>
<p>值得提一下的是，因为AOF文件的更新频率通常比RDB文件的更新频率更高，所以如果服务器有开启AOF持久化功能时，服务器就会优先使用AOF文件来还原数据库，其次才是RDB文件。</p>
<h2 id="RDB-持久化方式"><a href="#RDB-持久化方式" class="headerlink" title="RDB 持久化方式"></a>RDB 持久化方式</h2><h3 id="RDB文件结构简析"><a href="#RDB文件结构简析" class="headerlink" title="RDB文件结构简析"></a>RDB文件结构简析</h3><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/RDBWenJianJieGou.png" alt="RDB文件结构"></p>
<h3 id="redis服务器保存和载入RDB文件的方法"><a href="#redis服务器保存和载入RDB文件的方法" class="headerlink" title="redis服务器保存和载入RDB文件的方法"></a>redis服务器保存和载入RDB文件的方法</h3><p>redis中创建RDB文件的两个命令</p>
<ul>
<li><p>SAVE<br>SAVE命令会由Redis服务器主进程来执行RDB文件的创建，所以在执行SAVE时，Redis服务器会有阻塞，知道RDB文件创建完毕为止，且在阻塞期间服务器不能处理任何命令请求。</p>
</li>
<li><p>BGSAVE<br>BGSAVE命令则会派生出一个子进程，然后由子进程负责创建RDB文件，而Redis服务器主进程（父进程）可以继续处理各种命令请求。</p>
</li>
</ul>
<p>创建RDB文件的实际工作由rdb.c/rdbSave函数来完成，SAVE和BGSAVE命令都会以不同的形式调用这个函数。</p>
<p>RDB文件载入时的服务器状态</p>
<blockquote>
<p>RDB文件的载入只有在服务器启动时才会被执行，所以Redis中没有专门载入RDB文件的命令，只要Redis启动时没有开启AOF功能，且检测到RDB文件的存在，就会自动载入RDB文件。且服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成。</p>
</blockquote>
<h3 id="redis服务器自动保存功能的实现原理"><a href="#redis服务器自动保存功能的实现原理" class="headerlink" title="redis服务器自动保存功能的实现原理"></a>redis服务器自动保存功能的实现原理</h3><p>通过上面我们知道，Redis服务器有两个命令，SAVE和BGSAVE，来执行保存数据库状态的操作。<br>SAVE是阻塞的，BGSAVE是非阻塞的。Redis中借助BGSAVE命令，每隔一段时间自动执行一次BGSAVE命令来实现数据库状态的自动保存功能。</p>
<p>具体实现是通过设置服务器配置的save选项，按照一定的周期去执行BGSAVE命令。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div></pre></td></tr></table></figure></p>
<p>那么只要满足上面这三个条件的任何一条，BGSAVE就会被执行。</p>
<ul>
<li>服务器在900s之内，对数据库进行了至少1次修改</li>
<li>服务器在300s之内，对数据库进行了至少10次修改</li>
<li>数据库在60s之内，对数据库进行了10000次修改</li>
</ul>
<h2 id="AOF-持久化方式"><a href="#AOF-持久化方式" class="headerlink" title="AOF 持久化方式"></a>AOF 持久化方式</h2><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/AOFChiJiuHua.png" alt="AOF持久化方式"></p>
<h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>当AOF持久化功能处于打开的状态时，服务器在执行完一个写命令，先将被执行的写命令追加到服务器状态的 aof_buf 的缓冲区。Redis服务器会在每次事件循环结束之前，都会调用“flushAppendOnlyFile”函数来判断是否需要将 aof_buf 缓冲区中内容保存到AOF文件里面。</p>
<p>flushAppendOnlyFile 函数判断是否保存的依据和配置（appendfsync）</p>
<ul>
<li>always,将aof_buf 将缓冲区中所有内容写入并同步到AOF文件</li>
<li>everysec,将缓冲区中所有内容写入AOF文件，但至少间隔一秒同步一次(默认值)</li>
<li>no,将缓冲区中所有内容写入AOF文件，但不对AOF文件进行同步，何时同步则由系统决定</li>
</ul>
<h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p><img src="http://n.sinaimg.cn/games/3ece443e/20170112/AOFWenJianZaiRuGuoCheng.png" alt="AOF文件载入过程"></p>
<h3 id="AOF重写的原理和实现"><a href="#AOF重写的原理和实现" class="headerlink" title="AOF重写的原理和实现"></a>AOF重写的原理和实现</h3><p>随着服务器运行时间的增加，AOF文件中的内容会越来越多，相应的文件体积就会越来越大，但其实文件中很大一部分信息是冗余信息。</p>
<p>例如，我们对一个键进行了n次的写操作，AOF文件中相对应就会产生n次的写操作命令。但其实AOF文件中的对于该键的前n-1次的写操作命令都可认为是冗余操作命令，只需保留最后一条的写操作命令即可。</p>
<p>所以，Redis提供了AOF文件重写（rewrite）功能，来清除这些冗余命令，以控制AOF文件的大小。具体实现思路为，Redis服务器先创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态是相同的，但新的AOF文件不会包含任何浪费空间的冗余命令。</p>
<h4 id="Redis服务器AOF重写的实现"><a href="#Redis服务器AOF重写的实现" class="headerlink" title="Redis服务器AOF重写的实现"></a>Redis服务器AOF重写的实现</h4><ul>
<li><p>虽然该功能名称叫 AOF文件重写 ，但是具体的实现却并没有对现有AOF文件进行任何读取、分析、或者写入操作，而是通过读取当前服务器的数据库状态来实现的。</p>
</li>
<li><p>通过读取当前数据库中键值的状态，尽量生成最少的能与之对应redis命令，然后将该redis命令写入新的AOF文件中，直至将当前数据库状态全部生成完毕。</p>
</li>
<li><p>另外，在执行AOF重写的期间，Redis会维护一个AOF重写缓冲区，该缓冲区会在子进程创建AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态完全一致。</p>
</li>
<li><p>最后，服务器用新的AOF替换旧的AOF文件，以此来完成AOF文件的重写操作。</p>
</li>
</ul>
<h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>由于生成新的AOF文件时会进行大量的写入操作，所以在进行AOF重写的时候，会造成长时间的阻塞，所以redis将AOF重写程序放在子进程里执行，这样就可避免主进程长时间的阻塞。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道Redis是一个内存数据库，它所有的数据库状态都存储在内存中，所以如果想要在服务器故障、重启之后数据还在，就需要一个将这些数据持久化的一个功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20170112/redisChiJiuHuaYuanLi.png&quot; alt=&quot;redis持久化原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;Redis提供了两种持久化的方式，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RDB 持久化方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将数据库中的键值对及状态保存在持久化文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AOF 持久化方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;而AOF保存的是服务器所执行过的所有写命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之Redis数据库的实现</title>
    <link href="https://weizhimiao.github.io/2017/01/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8BRedis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2017/01/12/深入了解Redis之Redis数据库的实现/</id>
    <published>2017-01-12T12:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis这个<code>key-value</code>的存储系统，由于其高性能，支持主从复制和丰富的数据结构等特性，目前已经广泛应用于我们的各个场景之中。所以了解整理其相关的一些内容，用以加深我们对其的了解，方便之后更好的使用它实现我们的各种功能。</p>
<a id="more"></a>
<h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><p>Redis底层的实现，主要用到的数据结构有简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等。但REdis没有直接用这些数据结构来实现数据库的设计。而是基于这些数据结构创建了一个对象系统。</p>
<p>使用这种对象系统的好处</p>
<ul>
<li>对不同的使用场景，可以为对象设置多种不同的数据结构实现，从而可以优化对象在不同场景下的使用效率</li>
<li>基于对象方便实现基于引用计数技术的内存回收机制</li>
</ul>
<p>键值对的具体组成：</p>
<ul>
<li>键 =&gt; 自字符串对象</li>
<li>值<ul>
<li>字符串对象</li>
<li>列表对象</li>
<li>哈希对象</li>
<li>集合对象</li>
<li>有序集合对象</li>
</ul>
</li>
</ul>
<h2 id="数据库的实现"><a href="#数据库的实现" class="headerlink" title="数据库的实现"></a>数据库的实现</h2><p>Redis服务器的所有数据库都保存在”redisSeriver”结构中的“db” 的数组中。而db的结构则主要由“dict”和“expires”另个字典构成，dict字典负责保存键值对，而expires字典负责保存键的过期时间。</p>
<p>redisSeriver结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct redisSeriver&#123;</div><div class="line">  //...</div><div class="line"></div><div class="line">  redisDb *db;</div><div class="line"></div><div class="line">  //...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>redisDb结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typeed struct redisDb&#123;</div><div class="line">  //...</div><div class="line"></div><div class="line">  //数据库键值字典，保存数据库中所有键值对（又称之为，键空间）</div><div class="line">  dict *dict;</div><div class="line"></div><div class="line">  //过期字典，保存键的过期时间</div><div class="line">  dict *expires;</div><div class="line"></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure></p>
<h3 id="服务器保存键值对的方法"><a href="#服务器保存键值对的方法" class="headerlink" title="服务器保存键值对的方法"></a>服务器保存键值对的方法</h3><p>键值字典和用户所见的数据库是直接对应的</p>
<ul>
<li>该字典里的键就是我们数据库的键（每个键都是一个字符串对象）</li>
<li>字典的值就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任一种对象。</li>
</ul>
<p>相应的操作</p>
<ul>
<li><p>当添加新键值对时</p>
<blockquote>
<p>实际就是将一个新键值对添加到该“dict”键值字典中，其键为字符串对象，值为任意的一个Redis对象</p>
</blockquote>
</li>
<li><p>删除键</p>
<blockquote>
<p>实际上就是在该“dict”键值字典中删除键对应的键值对对象</p>
</blockquote>
</li>
<li><p>更新键</p>
</li>
<li>对该键取值</li>
</ul>
<p>当我们对这些键值进行这些读写操作的时候，redis还会执行一些额外的（维护）操作。这些操作有</p>
<ul>
<li>当读取一个键后，会更新服务器键空间命中次数（hit）或不命中次数（miss）</li>
<li>读取一个键后，还会更新该键的LRU（最后一次使用时间）</li>
<li>当读取一个键时，发现该键已经过期，那么出返回结果还需要删除这个键</li>
<li>如果有客户端watch这个键，那么操作过这个键之后还需要将这个键标记为“dirty”，让watch这个键的客户端知道该键已经被修改过</li>
<li>当每次修改过一个键之后，都会对“dirty”计数器的值增1，以便触发服务器的持久化以及复制操作。</li>
<li>如果服务器开启了数据库通知的功能，那么修改了键之后，还需要按配置发送相应的通知。</li>
</ul>
<h3 id="服务器保存键值对过期时间的方法"><a href="#服务器保存键值对过期时间的方法" class="headerlink" title="服务器保存键值对过期时间的方法"></a>服务器保存键值对过期时间的方法</h3><p>过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p>
<p>redis有四个不同的命令来设置键的过期时间</p>
<ul>
<li>EXPIRE <key> <ttl> (秒级)</ttl></key></li>
<li>PEXPIRE <key> <ttl> (毫秒级)</ttl></key></li>
<li>EXPIREAT <key> <timestamp> (秒级)</timestamp></key></li>
<li>PEXPIREAT <key> <timestamp> (毫秒级)</timestamp></key></li>
</ul>
<p>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令最终都是使用PEXPIREAT命令来实现的。</p>
<p>redisDb结构中，expires字典保存了数据库中所有键的过期时间。</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象</li>
<li>过期字典的值是一个long类型的整数，这个整数保存着过期时间（一个毫秒精度的UNIX时间戳）</li>
</ul>
<h3 id="服务器删除过期键值对的方法"><a href="#服务器删除过期键值对的方法" class="headerlink" title="服务器删除过期键值对的方法"></a>服务器删除过期键值对的方法</h3><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><ul>
<li>1、检查给定的键是否存在于过期字典，如果存在，那么取得键的过期时间</li>
<li>2、检查当前UNIX时间戳是否大于取得的键的过期时间，如果大于的，那么该键已过期；否则该键未过期。</li>
</ul>
<h4 id="一般的常见的过期键删除机制"><a href="#一般的常见的过期键删除机制" class="headerlink" title="一般的常见的过期键删除机制"></a>一般的常见的过期键删除机制</h4><ul>
<li>定时删除，在设置键的时候设定一个定时器，让其在定时器结束时执行对键的删除操作</li>
<li>惰性删除，设置后不管，当需要再次获取该键时，先检查该键是否已经过期，如果过期的话，执行删除操作，没有过期的话，返回键值</li>
<li>定期删除，每隔一段时间，对所有键检查一次，有过期的则主动删除</li>
</ul>
<h4 id="Redis采用的过期键删除机制（惰性-定期）"><a href="#Redis采用的过期键删除机制（惰性-定期）" class="headerlink" title="Redis采用的过期键删除机制（惰性+定期）"></a>Redis采用的过期键删除机制（惰性+定期）</h4><ul>
<li><p>惰性删除策略的实现</p>
<blockquote>
<p>redis在所有读写数据库的Redis命令之前都会执行一个叫”expireIfNeeded”的函数对要操作的键进行检查</p>
</blockquote>
<ul>
<li>如果要操作的键已经过期，那么”expireIfNeeded”函数将该键从数据库中删除</li>
<li>如果未过期，那么”expireIfNeeded”函数不做操作</li>
</ul>
</li>
</ul>
<p>注：对所操作键存在与否的判断先与是否过期的判断</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20170111/redisGuoQiJianShanChuLiuCheng.png" alt="img"></p>
<ul>
<li>定期删除策略的实现<blockquote>
<p>redis中会有一个周期性运行的操作函数“serverCron”。过期键的定期删除是由一个叫“activeExpireCycle”的函数实现。当serverCron函数运行时，activeExpireCycle 函数就会被调用。它会在规定的时间内分多次遍历服务器中各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
</blockquote>
</li>
</ul>
<h4 id="redis集群中过期键的删除"><a href="#redis集群中过期键的删除" class="headerlink" title="redis集群中过期键的删除"></a>redis集群中过期键的删除</h4><p>在Redis集群中 当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，而从服务器即使发现过期键也不会自作主张的将其删除，而是等待主节点发来DEL命令，显式的进行删除。这种统一的、中心化的过期键策略可以保证主从服务器数据一致。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis这个&lt;code&gt;key-value&lt;/code&gt;的存储系统，由于其高性能，支持主从复制和丰富的数据结构等特性，目前已经广泛应用于我们的各个场景之中。所以了解整理其相关的一些内容，用以加深我们对其的了解，方便之后更好的使用它实现我们的各种功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构下使用Nginx变量对应用程序进行性能追踪[转]</title>
    <link href="https://weizhimiao.github.io/2016/12/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E4%BD%BF%E7%94%A8Nginx%E5%8F%98%E9%87%8F%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E8%BF%BD%E8%B8%AA%5B%E8%BD%AC%5D/"/>
    <id>https://weizhimiao.github.io/2016/12/29/微服务架构下使用Nginx变量对应用程序进行性能追踪[转]/</id>
    <published>2016-12-29T13:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>使用变量来对应用程序性能进行管理</em></strong></p>
<p>变量是NGINX配置的一个重要且有时被忽视的方面。 Nginx 有大约<a href="http://nginx.org/en/docs/varindex.html" target="_blank" rel="external">150个变量</a>可用，Nginx 变量可用来方便每个部分的配置。 在本博客中，我们讨论如何使用NGINX变量来进行 <strong>应用程序跟踪</strong> 和 <strong>应用程序性能管理（APM）</strong> ，重点是发现应用程序中的性能瓶颈。 这篇文章适用于开源的 NGINX 软件和 NGINX Plus。 为了简洁，我们将参考NGINX Plus，除非两个产品之间有差异。</p>
<a id="more"></a>
<h2 id="应用程序交付环境"><a href="#应用程序交付环境" class="headerlink" title="应用程序交付环境"></a>应用程序交付环境</h2><p>在我们的示例应用程序交付环境中，NGINX Plus作为我们应用程序的反向代理。 应用程序本身包括一个Web前端，后面是多个微服务。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161229/nginx-proxies-app-with-frontend-and-microservices.png" alt="示例应用程序交付环境"></p>
<h2 id="跟踪端到端-End‑to‑End-请求"><a href="#跟踪端到端-End‑to‑End-请求" class="headerlink" title="跟踪端到端(End‑to‑End)请求"></a>跟踪端到端(End‑to‑End)请求</h2><p><code>NGINX Plus R10</code>（和<code>NGINX 1.11.0</code>）引入 <code>$request_id</code> 变量，它是随机生成的32个十六进制字符串，在每个HTTP请求到达时自动分配给它们（例如<code>444535f9378a3dfa1b8604bc9e05a303</code>）。 这个看似简单的机制解锁了一个强大的工具，可用于跟踪和故障排除。 通过配置<code>NGINX Plus</code>和所有后端服务传递<code>$request_id</code>值，您可以跟踪每个请求端到端。 这个示例配置是为我们的前端<code>NGINX Plus</code>服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">upstream app_server &#123;</div><div class="line">    server 10.0.0.1:80;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    add_header X-Request-ID $request_id; # Return to client</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://app_server;</div><div class="line">        proxy_set_header X-Request-ID $request_id; # Pass to app server</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要配置NGINX Plus进行请求跟踪，我们首先定义 <code>upstream</code> 块中应用程序服务器的网络位置。 为了简单起见，我们在这里只显示一个应用程序服务器，但通常使用几个应用程序服务器来实现高可用性和负载平衡。</p>
<p><code>server</code>块定义了<code>NGINX Plus</code>如何处理传入的HTTP请求。 <code>listen</code>指令告诉<code>NGINX Plus</code>侦听端口80，但生产环境配置通常使用<code>SSL/TLS</code>来保护传输中的数据。</p>
<p><code>add_header</code>指令将<code>$request_id</code>值作为响应中的自定义<code>header</code>头发送回客户端。 这对于测试以及生成自己的日志（如移动应用程序）的客户端应用程序非常有用，以便客户端可以精确匹配服务器的错误日志。</p>
<p>最后，<code>location</code> 块应用于整个应用程序空间（<code>/</code>），<code>proxy_pass</code>指令简单地代理所有请求到应用程序服务器。 <code>proxy_set_header</code>指令通过添加传递给应用程序的HTTP头来修改代理请求。 在这种情况下，我们创建一个名为<code>X-Request-ID</code>的头，并为其分配<code>$request_id</code>变量的值。 因此，我们的应用程序接收由<code>NGINX Plus</code>生成的request ID。</p>
<h2 id="记录端到端的-request-id"><a href="#记录端到端的-request-id" class="headerlink" title="记录端到端的$request_id"></a>记录端到端的<code>$request_id</code></h2><p>我们的应用程序跟踪的目标是确定请求处理生命周期中的性能瓶颈，作为应用程序性能管理的一部分。 我们可以通过在处理过程中记录重要的事件来做到这一点，方便我们以后分析它们的异常或不合理的延迟。</p>
<h3 id="配置NGINX-Plus"><a href="#配置NGINX-Plus" class="headerlink" title="配置NGINX Plus"></a>配置NGINX Plus</h3><p>我们从配置前端<code>NGINX Plus</code>服务器开始，将<code>$request_id</code>包含在用于<code>access_trace.log</code>文件的自定义日志记录格式<code>trace</code>中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">log_format trace &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                 &apos;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &apos;</div><div class="line">                 &apos;&quot;$http_x_forwarded_for&quot; $request_id&apos;;</div><div class="line"></div><div class="line">upstream app_server &#123;</div><div class="line">    server 10.0.0.1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    add_header X-Request-ID $request_id; # Return to client</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://app_server;</div><div class="line">        proxy_set_header X-Request-ID $request_id;        # Pass to app server</div><div class="line">        access_log /var/log/nginx/access_trace.log trace; # Log $request_id</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="配置后端应用程序"><a href="#配置后端应用程序" class="headerlink" title="配置后端应用程序"></a>配置后端应用程序</h3><p>将<code>Request ID</code> 传递到我们的应用程序有时也会用到。 在这个例子中，我们有一个由<code>uWSGI</code>管理的<code>Python应用程序</code>。 让我们修改应用程序入口点，以获取<code>Request ID</code>作为日志变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> uwsgi <span class="keyword">import</span> set_logvar</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    set_logvar(<span class="string">'requestid'</span>, environ[<span class="string">'X_REQUEST_ID'</span>])</div></pre></td></tr></table></figure>
<p>然后我们可以修改<code>uWSGI</code>配置，将<code>Request ID</code>包含在标准日志文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log-format = %(addr) - %(user) [%(ltime)] &quot;%(method) %(uri) %(proto)&quot; %(status)</div><div class="line">%(size) &quot;%(referer)&quot; &quot;%(uagent)&quot; %(requestid)</div></pre></td></tr></table></figure>
<p>通过这种配置，我们现在可以生成日志文件，这些文件可以跨多个系统，我们可以通过<code>requestid</code>来查看我们单次<code>request</code>的调用链。</p>
<p>来自<code>NGINX</code>的日志示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">172.17.0.1 - - [02/Aug/2016:14:26:50 +0000] &quot;GET / HTTP/1.1&quot; 200 90 &quot;-&quot; &quot;-&quot; &quot;-&quot; 5f222ae5938482c32a822dbf15e19f0f</div></pre></td></tr></table></figure></p>
<p>来自应用程序的日志示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.91.1 - - [02/Aug/2016:14:26:50 +0000] &quot;GET / HTTP/1.0&quot; 200 123 &quot;-&quot; &quot;-&quot; 5f222ae5938482c32a822dbf15e19f0f</div></pre></td></tr></table></figure></p>
<p>通过将 <code>Request ID</code> 字段与事务匹配，<code>Splunk</code> 和 <code>Kibana</code> 之类的工具允许我们识别性能瓶颈。 例如，我们可以搜索花费两秒钟以上时间完成的请求。 然而，在常规时间戳中的默认时间精度为一秒不足以用于大多数真实环境的分析。</p>
<h2 id="高精度时序"><a href="#高精度时序" class="headerlink" title="高精度时序"></a>高精度时序</h2><p>为了准确地测量端到端请求，我们需要具有毫秒级精度的时间戳。 通过在日志条目中包括<code>$msec</code>变量，我们在每个条目的时间戳上获得毫秒的精度。 向应用程序日志添加毫秒时间戳允许我们查找花费 本该不超过200毫秒完成，但却花了2秒的请求。</p>
<p>但是即使这样，我们也没有得到全部的图片，因为<code>NGINX Plus</code>只在处理每个请求结束时写入<code>$msec</code>时间戳。 幸运的是，有几个其他<code>NGINX Plus</code>定时变量，毫秒精度，让我们更深入地了解处理本身：</p>
<ul>
<li><p><code>$request_time</code> – 完全请求时间，从NGINX Plus从客户端读取第一个字节，并在NGINX Plus发送响应主体的最后一个字节时结束</p>
</li>
<li><p><code>$upstream_connect_time</code> – 花费在与<code>upstream</code>服务器建立连接的时间</p>
</li>
<li><p><code>$upstream_header_time</code> – 建立到<code>upstream</code>服务器的连接和接收响应头的第一个字节之间的时间</p>
</li>
<li><p><code>$upstream_response_time</code> – 建立到<code>upstream</code>服务器的连接和接收响应主体的最后一个字节之间的时间</p>
</li>
</ul>
<p>有关这些时序变量的详细信息，请参阅<a href="Using NGINX Logging for Application Performance Monitoring">使用NGINX日志记录应用程序性能监视</a>。</p>
<p>我们可以扩展我们的<code>log_format</code>指令，将所有这些高精度定时变量包含在我们的跟踪日志格式中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">log_format trace &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; $status &apos;</div><div class="line">                 &apos;$body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &apos;</div><div class="line">                 &apos;&quot;$http_x_forwarded_for&quot; $request_id $msec $request_time &apos;</div><div class="line">                 &apos;$upstream_connect_time $upstream_header_time $upstream_response_time&apos;;</div></pre></td></tr></table></figure></p>
<p>使用我们首选的日志分析工具，我们可以提取变量值并执行以下计算，以了解<code>NGINX Plus</code>在连接到应用程序服务器之前处理请求的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NGINX Plus processing time = $request_time - $upstream_connect_time - $upstream_response_time</div></pre></td></tr></table></figure></p>
<p>我们还可以搜索<code>$upstream_response_time</code>的最高值，查看它们是否与特定URI或上游服务器相关联。 然后可以进一步检查具有相同请求ID的应用程序日志条目。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>利用新的<code>$request_id</code>变量和一些毫秒精度的时间变量可以提供对应用程序性能瓶颈的深入了解，提高应用程序性能管理，而无需使用什么重量级代理和插件。</p>
<p><a href="https://www.nginx.com/blog/application-tracing-nginx-plus/" target="_blank" rel="external">【原文】:https://www.nginx.com/blog/application-tracing-nginx-plus/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;使用变量来对应用程序性能进行管理&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变量是NGINX配置的一个重要且有时被忽视的方面。 Nginx 有大约&lt;a href=&quot;http://nginx.org/en/docs/varindex.html&quot;&gt;150个变量&lt;/a&gt;可用，Nginx 变量可用来方便每个部分的配置。 在本博客中，我们讨论如何使用NGINX变量来进行 &lt;strong&gt;应用程序跟踪&lt;/strong&gt; 和 &lt;strong&gt;应用程序性能管理（APM）&lt;/strong&gt; ，重点是发现应用程序中的性能瓶颈。 这篇文章适用于开源的 NGINX 软件和 NGINX Plus。 为了简洁，我们将参考NGINX Plus，除非两个产品之间有差异。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="APM" scheme="https://weizhimiao.github.io/tags/APM/"/>
    
      <category term="应用性能跟踪" scheme="https://weizhimiao.github.io/tags/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>贪婪和懒惰匹配模式使用小结</title>
    <link href="https://weizhimiao.github.io/2016/11/29/%E8%B4%AA%E5%A9%AA%E5%92%8C%E6%87%92%E6%83%B0%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/11/29/贪婪和懒惰匹配模式使用小结/</id>
    <published>2016-11-29T12:30:00.000Z</published>
    <updated>2017-03-09T08:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>所谓的贪婪/懒惰匹配模式，就是指正则表达式在匹配字符串是的两种不同的匹配策略。<br>简单的说就是，贪婪匹配模式在正则匹配时会尽量匹配出尽可能多的字符；而懒惰匹配模式则相反，它会匹配尽可能少的字符。</p>
<p>举例来说，</p>
<p>我们要匹配以字符<code>a</code>开始，以<code>b</code>结束的字符串：假如我们要搜索的字符串是<code>aabab</code>，那么分别按照贪婪和懒惰两种模式来匹配，将会得到以下结果：</p>
<ul>
<li><code>aabab</code>(贪婪模式)</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-0@2x.png" alt="贪婪"></p>
<ul>
<li><code>aab</code>(懒惰模式)(为什么不是<code>ab</code>？)</li>
</ul>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-1@2x.png" alt="懒惰"></p>
<a id="more"></a>
<h2 id="正则表达式的这两种匹配模式的实现"><a href="#正则表达式的这两种匹配模式的实现" class="headerlink" title="正则表达式的这两种匹配模式的实现"></a>正则表达式的这两种匹配模式的实现</h2><ul>
<li><strong>贪婪</strong> <code>a.*b</code> 一般当一个正则表达式能够匹配出多种结果时，默认将会匹配出尽可能多的字符串。</li>
</ul>
<ul>
<li><strong>懒惰</strong> <code>a.*?b</code>只要表达式中的限定符后面加上一个问号。例如，（<code>.*?</code>）,则会匹配出符合条件的最短的字符。</li>
</ul>
<h2 id="懒惰模式的匹配原理"><a href="#懒惰模式的匹配原理" class="headerlink" title="懒惰模式的匹配原理"></a>懒惰模式的匹配原理</h2><p>简单的来说，就是在匹配喝不匹配都可以的情况下，优先不匹配，记录备选状态，并将匹配控制权交给正则表达式的下一个匹配字符。当后面的匹配失败时，回溯，进行匹配。</p>
<h2 id="常用的懒惰限定符"><a href="#常用的懒惰限定符" class="headerlink" title="常用的懒惰限定符"></a>常用的懒惰限定符</h2><table>
<thead>
<tr>
<th>懒惰限定符代码/语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*?</code></td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>重复1次或多次，但尽可能少重复</td>
</tr>
<tr>
<td><code>??</code></td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,m}?</code></td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,}?</code></td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
<h2 id="示例中，采用a-b表达式进行匹配时，匹配的结果为什么不是ab"><a href="#示例中，采用a-b表达式进行匹配时，匹配的结果为什么不是ab" class="headerlink" title="示例中，采用a.*?b表达式进行匹配时，匹配的结果为什么不是ab"></a>示例中，采用<code>a.*?b</code>表达式进行匹配时，匹配的结果为什么不是<code>ab</code></h2><p>如果我们只考虑<code>.*?</code>这个表达式，<code>aabab</code>字符串中将会匹配出两组字符，一组是<code>aab</code>(1~3字符)，另一组时<code>ab</code>（第2~3个字符）。但为什么结果是<code>aab</code>?按照懒惰模式匹配，他应该匹配出符合条件的最短的字符（最短的字符应该是<code>ab</code>）。</p>
<p>简单的说，正则表达式有一条规则，比懒惰/贪婪规则优先级更高：<strong><em>最先开始的匹配拥有最高优先权</em></strong>。</p>
<p><strong>提示：</strong></p>
<p>在实际开发中，涉及贪婪模式与懒惰模式的地方是很多的。在一定的情况下，使用懒惰模式可以减少回溯，提高效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓的贪婪/懒惰匹配模式，就是指正则表达式在匹配字符串是的两种不同的匹配策略。&lt;br&gt;简单的说就是，贪婪匹配模式在正则匹配时会尽量匹配出尽可能多的字符；而懒惰匹配模式则相反，它会匹配尽可能少的字符。&lt;/p&gt;
&lt;p&gt;举例来说，&lt;/p&gt;
&lt;p&gt;我们要匹配以字符&lt;code&gt;a&lt;/code&gt;开始，以&lt;code&gt;b&lt;/code&gt;结束的字符串：假如我们要搜索的字符串是&lt;code&gt;aabab&lt;/code&gt;，那么分别按照贪婪和懒惰两种模式来匹配，将会得到以下结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aabab&lt;/code&gt;(贪婪模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-0@2x.png&quot; alt=&quot;贪婪&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aab&lt;/code&gt;(懒惰模式)(为什么不是&lt;code&gt;ab&lt;/code&gt;？)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-1@2x.png&quot; alt=&quot;懒惰&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
      <category term="正则表达式" scheme="https://weizhimiao.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Memcached</title>
    <link href="https://weizhimiao.github.io/2016/11/27/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Memcached/"/>
    <id>https://weizhimiao.github.io/2016/11/27/深入了解Memcached/</id>
    <published>2016-11-27T14:30:00.000Z</published>
    <updated>2017-03-09T08:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://n.sinaimg.cn/games/3ece443e/20161128/memcachedDuoXianChengMoXingYuanLiTu.png" alt="Memcached多线程模型原理"></p>
<a id="more"></a>
<h3 id="Memcached的高并发支持原理"><a href="#Memcached的高并发支持原理" class="headerlink" title="Memcached的高并发支持原理"></a>Memcached的高并发支持原理</h3><ul>
<li>多路复用I/O模型</li>
<li>多线程模式</li>
</ul>
<p>Memcached 使用了多路复用I/O模型（如，epoll、select等）。</p>
<p>传统的阻塞I/O中，系统可能会因为某个用户连接还没有做好I/O准备而一直等待，知道这个连接做好I/O准备。如果在这是有其他的用户连接到服务器，很可能会因为系统阻塞而得不到响应。</p>
<p>而多路复用I/O是一种消息通知模式，用户连接做好I/O准备后，系统会通知我们这个连接可以进行I/O操作了，这样系统就不会阻塞在某个用户连接了。因此就能够支持更高的并发。</p>
<p>此外，Memcached使用了多线程模式，在开启Memcached服务器时，通过使用 <code>-t</code> 参数指定要开启的线程数。（但，并不是线程数越多越好，一般设置为CPU核数，这样效率最高。）</p>
<h3 id="Memcached内存分配算法了解"><a href="#Memcached内存分配算法了解" class="headerlink" title="Memcached内存分配算法了解"></a>Memcached内存分配算法了解</h3><p>Memcached 在存储数据时，使用的是Slab内存分配算法。这种算法可以减少生成的内存碎片，提高使用效率。但这种算法也导致Memcached只能够使用不大于1MB的内存（所以，Memcache默认只能存储不大于1MB的数据）。</p>
<h3 id="Slab分配算法原理"><a href="#Slab分配算法原理" class="headerlink" title="Slab分配算法原理"></a>Slab分配算法原理</h3><p>Slab分配算法把每1MB大小的内存块称之为一个slab页，每次向系统申请一个slab页（所以，slab是一次申请内存的最小单位），然后再通过分割算法将这个slab页分割成若干小块的chunk，然后把这些chunk分配给用户使用。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161128/slabNaCunFenPeiYuanLi.png" alt="img"></p>
<p>默认情况下，Memcached可分为40种slab页，每种slab页的chunk块大小都不相同。</p>
<p>当保存数据时Memcached向Slab层申请内存时，Slab层找到一个一个合适的slab页，然后分配其中一个空闲的chunk块给Memcached使用。</p>
<h3 id="Memcached过期数据删除机制"><a href="#Memcached过期数据删除机制" class="headerlink" title="Memcached过期数据删除机制"></a>Memcached过期数据删除机制</h3><p>Memcached 为每一个item都设置了一个过期时间，但不是到期了之后就把item从内存中删除，而是访问item时，先进行判断，如果到期有效期，才把item从内存中删掉。</p>
<h3 id="Memcached淘汰数据算法"><a href="#Memcached淘汰数据算法" class="headerlink" title="Memcached淘汰数据算法"></a>Memcached淘汰数据算法</h3><blockquote>
<p>当内存不足时，Memcached会把访问比较少的或者一段时间没有访问的item淘汰（并不是主动去遍历那些过期的item），以便腾出内存空间存放新的item。</p>
</blockquote>
<p>当Memecached使用的内存数大于设置的内存数之后，为了腾出空间来存放新的数据项，Memcached采用的是LRU算法(最近最少使用算法)来淘汰旧的数据项。</p>
<p>数据淘汰流程：</p>
<ul>
<li>1、当Memcached第一次申请内存失败时，就开始算法进行淘汰数据。</li>
<li>2、首先从数据项列表（item_list）尾部开始遍历。</li>
<li>3、在列表中查找一个引用计数器（refcount）为0的item，把此item占用的内存释放掉。</li>
<li>4、再次申请内存，如果失败的话，继续进行淘汰算法。</li>
<li>5、查找3小时没有访问过的item，并将这些item释放掉。</li>
<li>6、再次申请内存，如果还是失败的话，就返回NULL（申请内存失败）。</li>
</ul>
<p><strong>Tips：</strong></p>
<p>1、为什么从数据项列表尾部开始遍历？</p>
<p>因为，Memcached会把刚刚访问过的item放到item列表头部，所以尾部的item就是没有被访问过的（或者是很少被访问到的），这就是LRU的精髓。</p>
<h3 id="Memcached多线程模型"><a href="#Memcached多线程模型" class="headerlink" title="Memcached多线程模型"></a>Memcached多线程模型</h3><p>Memcached 是一个多线程的缓存服务器程序。在Memcached内部，线程分为：</p>
<ul>
<li>主线程（main thread）：负责接收客户端连接，并把连接分配给工作线程处理；</li>
<li>工作线程（worker thread）：处理主线程分配过来的客户端连接请求。</li>
</ul>
<p>Memcached 多线程模型原理如图所示。</p>
<p><img src="http://n.sinaimg.cn/games/3ece443e/20161128/memcachedDuoXianChengMoXingYuanLiTu.png" alt="Memcached多线程模型原理"></p>
<p>主线程主要负责侦听客户端连接，在客户端连接到Memcached时，Memcached接收到来的请求，并把连接push到工作线程的CQ队列中，并向工作线程发送一个信号，告诉工作线程有新的客户端连接需要处理。</p>
<p>当工作线程收到主线程的信号后，便会把CQ队列上的客户端连接注册到libevent进行侦听，libevent会侦听客户端连接的读写请求，病调用相关的回调函数进行处理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161128/memcachedDuoXianChengMoXingYuanLiTu.png&quot; alt=&quot;Memcached多线程模型原理&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="memcached" scheme="https://weizhimiao.github.io/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>Linux中借助lockf简单实现和应用文件锁机制</title>
    <link href="https://weizhimiao.github.io/2016/11/16/%E6%96%87%E4%BB%B6%E9%94%81%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://weizhimiao.github.io/2016/11/16/文件锁机制实现与应用/</id>
    <published>2016-11-16T13:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>文件锁机制的作用：防止多个程序同时对一个不允许同时操作的工作做操作。</p>
<a id="more"></a>
<h2 id="实现-lockf"><a href="#实现-lockf" class="headerlink" title="实现(lockf)"></a>实现(lockf)</h2><p>在Linux中我们可以借助lockf命令来实现文件锁机制</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -xzf lockf_linux.tar.gz</div><div class="line">cd lockf_linux</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lockf --help</div><div class="line">  -k 锁定文件，如果当前文件被锁，则输出 lockf:/tmp/create/lock :already locked</div><div class="line">  -s 锁定文件，不输出任何信息 silent</div><div class="line">  -t second ：超时时间，超时就退出</div></pre></td></tr></table></figure>
<h3 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lockf -s -t 0 /tmp/create.lock /usr/local/bin/php -f xxx.php</div></pre></td></tr></table></figure>
<blockquote>
<p>先判断/tmp/create.lock 文件是否被锁，被锁则立即退出，否则将会执行后面的脚本。</p>
</blockquote>
<p>第一次运行会给<code>/tmp/create.lock</code> 文件上锁，并执行后面的命令，</p>
<p>当第二次运行该命令时，<code>/tmp/create.lock</code> 文件已经被锁，命令将会直接退出，而不会去执行后面的<code>/usr/local/bin/php -f xxx.php</code> 的脚本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件锁机制的作用：防止多个程序同时对一个不允许同时操作的工作做操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="文件锁机制" scheme="https://weizhimiao.github.io/tags/%E6%96%87%E4%BB%B6%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>sudo使用场景分析[转]</title>
    <link href="https://weizhimiao.github.io/2016/11/16/sudo%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <id>https://weizhimiao.github.io/2016/11/16/sudo使用场景分析/</id>
    <published>2016-11-16T12:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下使用 sudo 命令，可以让普通用户也能执行一些或者全部的 root 命令。本文就对我们常用到 sudo 操作情景进行简单分析，通过一些例子来了解 sudo 命令相关的技巧。</p>
<ul>
<li><p>情景一：用户无权限执行 root 命令</p>
</li>
<li><p>情景二：vim 编辑后发现忘记使用 sudo</p>
</li>
<li><p>情景三：执行 root 命令忘记加 sudo</p>
</li>
<li><p>情景四：shell 内置命令如何使用 sudo</p>
</li>
<li><p>情景五：sudo 操作记录日志</p>
</li>
</ul>
<a id="more"></a>
<h2 id="情景一：用户无权限执行-root-命令"><a href="#情景一：用户无权限执行-root-命令" class="headerlink" title="情景一：用户无权限执行 root 命令"></a>情景一：用户无权限执行 root 命令</h2><p>普通用户登录 shell 之后，如果自身没有权限访问某个文件或执行某个命令时，若该用户获得root授权，那么就可以在需要执行的命令之前加上 sudo，临时切换到root用户的权限，完成相关的操作。在sudo于1980年前后被写出之前，一般用户管理系统的方式是利用su切换为超级用户。但是使用su的缺点之一在于必须要先告知超级用户的密码，而sudo使一般用户不需要知道超级用户的密码即可获得权限。</p>
<p>那么哪些用户可以临时获得 root 权限呢？这就需要在 <code>/etc/sudoers</code> 文件中进行配置：</p>
<p>授权给单个用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># User privilege specification</div><div class="line">guohl   ALL=(ALL) ALL</div></pre></td></tr></table></figure></p>
<p>上面这个例子中：</p>
<ul>
<li><p>guohl：允许使用 sudo 的用户名</p>
</li>
<li><p>ALL：允许从任何终端（任何机器）使用 sudo</p>
</li>
<li><p>(ALL)：允许以任何用户执行 sudo 命令</p>
</li>
<li><p>ALL：允许 sudo 权限执行任何命令</p>
</li>
</ul>
<p>如果我们想让用户 test 只能在本主机（主机名为guohl-pc）以 root 账户执行/bin/chown、/bin/chmod 两条命令，那么就应该这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># User privilege specification</div><div class="line">test   guohl-pc=(root) /bin/chown,/bin/chmod</div></pre></td></tr></table></figure></p>
<p>如果test 登录之后运行 sudo 命令，不满足上面三个条件命令均失败。</p>
<p>授权给用户组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Allow members of group sudo to execute any command</div><div class="line"># (Note that later entries override this, so you might need to move it further down)</div><div class="line">%sudo ALL=(ALL) ALL</div><div class="line">和授权给单个用户类似，只不过将用户名在这里换成%组名，所有在该组中的用户都按照此规则进行授权。对于该例，所有在 sudo 组内的用户都有在任何终端（第一个ALL）、以任何用户（第二个ALL）、执行任何命令（第三个ALL）的权限，查看 /etc/group 文件可以知道哪些用户属于 sudo 组。</div></pre></td></tr></table></figure></p>
<p>举例:</p>
<p>如果当前帐号在 /etc/sudoers 文件中被授予 sudo 的权限，那么你就可以将任何 root 命令作为 sudo 命令的参数，使用 root 权限来执行该命令。举例来说，挂载一个文件系统只能由 root 来执行，但是一个普通用户也可以使用 sudo 来挂载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$sudo mount /dev/sda7 /mnt</div><div class="line">[sudo] password for guohailin:</div></pre></td></tr></table></figure>
<p>首次使用会要求你输入当前用户的密码，系统确实输入正确即以 root 权限来执行 mount 命令，接下来一段时间（默认为5分钟）再次使用 sudo 命令就不需要输密码了。</p>
<h2 id="情景二：vim-编辑后发现忘记使用-sudo"><a href="#情景二：vim-编辑后发现忘记使用-sudo" class="headerlink" title="情景二：vim 编辑后发现忘记使用 sudo"></a>情景二：vim 编辑后发现忘记使用 sudo</h2><p>我们经常会遇到这样的一个囧境：使用 <code>vim</code> 对某个文件进行编辑，编辑完之后，按 ESC 之后回到普通模式，再按 <code>:wq</code> 准备保存退出时，发现没有权限对该文件进行修改，我们在使用 <code>vim</code> 命令时忘记在前面加 <code>sudo</code> 了。我就经常出现这种问题，之前的做法是只能不保存强退，再加上 <code>sudo</code> 重新编辑。</p>
<p>但是今后我们再也不需要用这么愚蠢的做法了，我们可以在 vim 的普通模式下，按 <code>:w !sudo tee %</code>，这样就可以 root 权限来保存文件了，你也无需因为自己一时忘记加个 sudo 而沮丧懊恼了！</p>
<h2 id="情景三：执行-root-命令忘记加-sudo"><a href="#情景三：执行-root-命令忘记加-sudo" class="headerlink" title="情景三：执行 root 命令忘记加 sudo"></a>情景三：执行 root 命令忘记加 sudo</h2><p>我们还会遇到这样稍微好一点的情形：输入一个长长的命令，按 Enter 之后出现无权限操作，因为我们忘记加 sudo 了。大多人的做法是按 ↑ 回到上一条命令，在该命令之前加上 sudo，再执行该命令。</p>
<p>以后，我们无需这样了，只要输入 <code>sudo !!</code> 即可，这里的 <code>!!</code> 代表上一条命令。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ head -n 4 /etc/sudoers</div><div class="line">head: cannot open `/etc/sudoers&apos; for reading: Permission denied</div><div class="line"></div><div class="line">$ sudo !!</div><div class="line">sudo head -n 4 /etc/sudoers</div><div class="line"># /etc/sudoers</div><div class="line">#</div><div class="line"># This file MUST be edited with the &apos;visudo&apos; command as root.</div><div class="line">#</div></pre></td></tr></table></figure></p>
<h2 id="情景四：shell-内置命令如何使用-sudo"><a href="#情景四：shell-内置命令如何使用-sudo" class="headerlink" title="情景四：shell 内置命令如何使用 sudo"></a>情景四：shell 内置命令如何使用 sudo</h2><p>shell 是一个交互式的应用程序，在执行外部命令时通过 fork 来创建一个子进程，再通过 exec 来加载外部命令的程序来执行，但是如果一个命令是 shell 内置命令，那么只能直接由 shell 来运行。sudo 的意思是，以别的用户（如root）的权限来 fork 一个进程，加载程序并运行，因此 sudo 后面不能跟 shell 的内置命令，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo cd /sys/kernel/debugfs</div><div class="line">sudo: cd: command not found</div></pre></td></tr></table></figure>
<p>在这种情况，我们又没有 root 账户的密码，我们怎样执行该命令呢？有种办法就是使用 sudo 获得root shell 的权限，然后在root shell 中执行该命令。进入root shell 很简单，输入sudo bash 确认本用户的密码即可，此时你会发现命令提示符显示当前是 root。一旦获得root shell，你可以执行任何命令而不需要在每条命令前输入sudo了。</p>
<p>另外，常用的shell 内置命令在<a href="http://www.thegeekstuff.com/2010/08/bash-shell-builtin-commands/" target="_blank" rel="external">这里</a> 有简单介绍，我们可以使用 type 命令来查看命令的类型，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ type ls</div><div class="line">ls is /bin/ls</div><div class="line">$ type umask</div><div class="line">umask is a shell builtin</div></pre></td></tr></table></figure>
<h2 id="情景五：sudo-操作记录日志"><a href="#情景五：sudo-操作记录日志" class="headerlink" title="情景五：sudo 操作记录日志"></a>情景五：sudo 操作记录日志</h2><p>作为一个 Linux 系统的管理员，不仅可以让指定的用户或用户组作为root用户或其它用户来运行某些命令，还能将指定的用户所输入的命令和参数作详细的记录。而sudo的日志功能就可以用户跟踪用户输入的命令，这不仅能增进系统的安全性，还能用来进行故障检修。但是要记录sudo的日志还要一些简单的配置：</p>
<p>1、创建sudo日志文件</p>
<p>我们将sudo日志文件放置在 <code>/var/log/sudo.log</code> 文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo touch /var/log/sudo.log</div></pre></td></tr></table></figure></p>
<p>2、修改 <code>/etc/rsyslog.conf</code> 配置文件</p>
<p>我使用系统为<code>Ubuntu13.04</code>为改名字，但有些系统名为<code>/etc/syslog.conf</code>，注意不同发行版之间的差别，在该文件加入下面一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">local2.debug    /var/log/sudo.log    #空白不能用空格，必须用tab</div></pre></td></tr></table></figure>
<p>3、修改 /etc/sudoers 配置文件</p>
<p>注意网上很多关于sudo日志文件配置都缺少这一步！在该文件中加入下面一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Defaults    logfile=/var/log/sudo.log</div></pre></td></tr></table></figure></p>
<p>4、重启 syslog 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service rsyslog restart</div></pre></td></tr></table></figure></p>
<p>5、查看 sudo 日志记录：</p>
<p>经过上面的配置，sudo 的所有成功和不成功的sudo</p>
<p>命令都记录到文件/var/log/sudo.log 中，例如我运行几条sudo 命令之后，查看该文件的记录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat sudo.log</div><div class="line">Sep 20 22:10:51 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;</div><div class="line">    COMMAND=/bin/cat /etc/sudoers</div><div class="line">Sep 20 22:11:36 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;</div><div class="line">    COMMAND=/usr/sbin/service rsyslog restart</div><div class="line">Sep 20 22:11:45 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;</div><div class="line">    COMMAND=/bin/ls</div><div class="line">Sep 20 22:12:08 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;</div><div class="line">    COMMAND=/bin/ls /root/</div></pre></td></tr></table></figure></p>
<p>[原文：<a href="http://www.cnblogs.com/hazir/p/sudo_command.html" target="_blank" rel="external">http://www.cnblogs.com/hazir/p/sudo_command.html</a>]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 下使用 sudo 命令，可以让普通用户也能执行一些或者全部的 root 命令。本文就对我们常用到 sudo 操作情景进行简单分析，通过一些例子来了解 sudo 命令相关的技巧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;情景一：用户无权限执行 root 命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景二：vim 编辑后发现忘记使用 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景三：执行 root 命令忘记加 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景四：shell 内置命令如何使用 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景五：sudo 操作记录日志&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="sudo" scheme="https://weizhimiao.github.io/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>Bash脚本15分钟进阶教程[转]</title>
    <link href="https://weizhimiao.github.io/2016/11/16/Bash%E8%84%9A%E6%9C%AC15%E5%88%86%E9%92%9F%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"/>
    <id>https://weizhimiao.github.io/2016/11/16/Bash脚本15分钟进阶教程/</id>
    <published>2016-11-16T12:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里的技术技巧最初是来自谷歌的“Testing on the Toilet” (TOTT)。这里是一个修订和扩增版本。</p>
<ul>
<li>脚本安全</li>
<li>脚本函数</li>
<li>变量注解</li>
<li>用$()代替反单引号(`)</li>
<li>用<code>[[]]</code>(双层中括号)替代[]</li>
<li>正则表达式/Globbing</li>
<li>字符串操作</li>
<li>避免使用临时文件</li>
<li>内置变量</li>
<li>调试</li>
<li>什么时候不应该使用bash脚本</li>
</ul>
<a id="more"></a>
<h2 id="脚本安全"><a href="#脚本安全" class="headerlink" title="脚本安全"></a>脚本安全</h2><p>我的所有bash脚本都以下面几句为开场白：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">   <span class="built_in">set</span> -o nounset</div><div class="line">   <span class="built_in">set</span> -o errexit</div></pre></td></tr></table></figure></p>
<p>这样做会避免两种常见的问题：</p>
<ul>
<li>引用未定义的变量(缺省值为“”)</li>
<li>执行失败的命令被忽略</li>
</ul>
<p>需要注意的是，有些Linux命令的某些参数可以强制忽略发生的错误，例如“mkdir -p” 和 “rm -f”。</p>
<p>还要注意的是，在“errexit”模式下，虽然能有效的捕捉错误，但并不能捕捉全部失败的命令，在某些情况下，一些失败的命令是无法检测到的。(更多细节请参考<a href="https://groups.google.com/forum/?fromgroups#!topic/gnu.bash.bug/-9ySnEo1WrQ" target="_blank" rel="external">这个帖子</a>。)</p>
<h2 id="脚本函数"><a href="#脚本函数" class="headerlink" title="脚本函数"></a>脚本函数</h2><p>在bash里你可以定义函数，它们就跟其它命令一样，可以随意的使用；它们能让你的脚本更具可读性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">ExtractBashComments</span></span>() &#123;</div><div class="line">    egrep <span class="string">"^#"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">cat myscript.sh | ExtractBashComments | wc</div><div class="line"></div><div class="line">comments=$(ExtractBashComments &lt; myscript.sh)</div></pre></td></tr></table></figure>
<p>还有一些例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">SumLines</span></span>() &#123;  <span class="comment"># iterating over stdin - similar to awk      </span></div><div class="line">    <span class="built_in">local</span> sum=0</div><div class="line">    <span class="built_in">local</span> line=””</div><div class="line">    <span class="keyword">while</span> <span class="built_in">read</span> line ; <span class="keyword">do</span></div><div class="line">        sum=$((<span class="variable">$&#123;sum&#125;</span> + <span class="variable">$&#123;line&#125;</span>))</div><div class="line">    <span class="keyword">done</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;sum&#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">SumLines &lt; data_one_number_per_line.txt</div><div class="line"></div><div class="line"><span class="function"><span class="title">log</span></span>() &#123;  <span class="comment"># classic logger</span></div><div class="line">   <span class="built_in">local</span> prefix=<span class="string">"[<span class="variable">$(date +%Y/%m/%d\ %H:%M:%S)</span>]: "</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;prefix&#125;</span> <span class="variable">$@</span>"</span> &gt;&amp;2</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">log</span> <span class="string">"INFO"</span> <span class="string">"a message"</span></div></pre></td></tr></table></figure>
<p>尽可能的把你的bash代码移入到函数里，仅把全局变量、常量和对“main”调用的语句放在最外层。</p>
<h2 id="变量注解"><a href="#变量注解" class="headerlink" title="变量注解"></a>变量注解</h2><p>Bash里可以对变量进行有限的注解。最重要的两个注解是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">local</span>(函数内部变量)</div><div class="line"><span class="built_in">readonly</span>(只读变量)</div><div class="line">    <span class="comment"># a useful idiom: DEFAULT_VAL can be overwritten</span></div><div class="line">    <span class="comment">#       with an environment variable of the same name</span></div><div class="line">    <span class="built_in">readonly</span> DEFAULT_VAL=<span class="variable">$&#123;DEFAULT_VAL:-7&#125;</span></div><div class="line"></div><div class="line">    <span class="function"><span class="title">myfunc</span></span>() &#123;</div><div class="line">       <span class="comment"># initialize a local variable with the global default</span></div><div class="line">       <span class="built_in">local</span> some_var=<span class="variable">$&#123;DEFAULT_VAL&#125;</span></div><div class="line">       ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这样，你可以将一个以前不是只读变量的变量声明成只读变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x=5</div><div class="line">x=6</div><div class="line"><span class="built_in">readonly</span> x</div><div class="line">x=7   <span class="comment"># failure</span></div></pre></td></tr></table></figure>
<p>尽量对你bash脚本里的所有变量使用local或readonly进行注解。</p>
<h2 id="用-代替反单引号"><a href="#用-代替反单引号" class="headerlink" title="用$()代替反单引号(`)"></a>用$()代替反单引号(`)</h2><p>反单引号很难看，在有些字体里跟正单引号很相似。$()能够内嵌使用，而且避免了转义符的麻烦。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># both commands below print out: A-B-C-D</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"A-`echo B-\`echo C-\\\`echo D\\\`\``"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"A-<span class="variable">$(echo B-$(echo C-$(echo D)</span>))"</span></div></pre></td></tr></table></figure></p>
<h2 id="用-双层中括号-替代"><a href="#用-双层中括号-替代" class="headerlink" title="用[[]](双层中括号)替代[]"></a>用<code>[[]]</code>(双层中括号)替代[]</h2><p>使用[[]]能避免像异常的文件扩展名之类的问题，而且能带来很多语法上的改进，而且还增加了很多新功能：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#124;&#124;</td>
<td>逻辑or(仅双中括号里使用)</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑and(仅双中括号里使用)</td>
</tr>
<tr>
<td>&lt;</td>
<td>字符串比较(双中括号里不需要转移)</td>
</tr>
<tr>
<td>-lt</td>
<td>数字比较</td>
</tr>
<tr>
<td>=</td>
<td>字符串相等</td>
</tr>
<tr>
<td>==</td>
<td>以Globbing方式进行字符串比较(仅双中括号里使用，参考下文)</td>
</tr>
<tr>
<td>=~</td>
<td>用正则表达式进行字符串比较(仅双中括号里使用，参考下文)</td>
</tr>
<tr>
<td>-n</td>
<td>非空字符串</td>
</tr>
<tr>
<td>-z</td>
<td>空字符串</td>
</tr>
<tr>
<td>-eq</td>
<td>数字相等</td>
</tr>
<tr>
<td>-ne</td>
<td>数字不等</td>
</tr>
</tbody>
</table>
<p>单中括号：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> \&gt; <span class="string">"a"</span> -o <span class="variable">$&#123;name&#125;</span> \&lt; <span class="string">"m"</span> ]</div></pre></td></tr></table></figure></p>
<p>双中括号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[ <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> &gt; <span class="string">"a"</span> &amp;&amp; <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> &lt; <span class="string">"m"</span>  ]]</div></pre></td></tr></table></figure></p>
<h2 id="正则表达式-Globbing"><a href="#正则表达式-Globbing" class="headerlink" title="正则表达式/Globbing"></a>正则表达式/Globbing</h2><p>使用双中括号带来的好处用下面几个例子最能表现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t=<span class="string">"abc123"</span></div><div class="line">[[ <span class="string">"<span class="variable">$t</span>"</span> == abc* ]]         <span class="comment"># true (globbing比较)</span></div><div class="line">[[ <span class="string">"<span class="variable">$t</span>"</span> == <span class="string">"abc*"</span> ]]       <span class="comment"># false (字面比较)</span></div><div class="line">[[ <span class="string">"<span class="variable">$t</span>"</span> =~ [abc]+[123]+ ]] <span class="comment"># true (正则表达式比较)</span></div><div class="line">[[ <span class="string">"<span class="variable">$t</span>"</span> =~ <span class="string">"abc*"</span> ]]       <span class="comment"># false (字面比较)</span></div></pre></td></tr></table></figure></p>
<p>注意，从bash 3.2版开始，正则表达式和globbing表达式都不能用引号包裹。如果你的表达式里有空格，你可以把它存储到一个变量里：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r=<span class="string">"a b+"</span></div><div class="line">[[ <span class="string">"a bbb"</span> =~ <span class="variable">$r</span> ]]        <span class="comment"># true</span></div></pre></td></tr></table></figure></p>
<p>按Globbing方式的字符串比较也可以用到case语句中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="variable">$t</span> <span class="keyword">in</span></div><div class="line">abc*)  &lt;action&gt; ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure></p>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>Bash里有各种各样操作字符串的方式，很多都是不可取的。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">f=<span class="string">"path1/path2/file.ext"</span>  </div><div class="line"></div><div class="line">len=<span class="string">"<span class="variable">$&#123;#f&#125;</span>"</span> <span class="comment"># = 20 (字符串长度)</span></div><div class="line"></div><div class="line"><span class="comment"># 切片操作: $&#123;&lt;var&gt;:&lt;start&gt;&#125; or $&#123;&lt;var&gt;:&lt;start&gt;:&lt;length&gt;&#125;</span></div><div class="line">slice1=<span class="string">"<span class="variable">$&#123;f:6&#125;</span>"</span> <span class="comment"># = "path2/file.ext"</span></div><div class="line">slice2=<span class="string">"<span class="variable">$&#123;f:6:5&#125;</span>"</span> <span class="comment"># = "path2"</span></div><div class="line">slice3=<span class="string">"<span class="variable">$&#123;f: -8&#125;</span>"</span> <span class="comment"># = "file.ext"(注意："-"前有空格)</span></div><div class="line">pos=6</div><div class="line">len=5</div><div class="line">slice4=<span class="string">"<span class="variable">$&#123;f:$&#123;pos&#125;</span>:<span class="variable">$&#123;len&#125;</span>&#125;"</span> <span class="comment"># = "path2"</span></div></pre></td></tr></table></figure>
<h3 id="替换操作-使用globbing"><a href="#替换操作-使用globbing" class="headerlink" title="替换操作(使用globbing)"></a>替换操作(使用globbing)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">f=<span class="string">"path1/path2/file.ext"</span>  </div><div class="line"></div><div class="line">single_subst=<span class="string">"<span class="variable">$&#123;f/path?/x&#125;</span>"</span>   <span class="comment"># = "x/path2/file.ext"</span></div><div class="line">global_subst=<span class="string">"<span class="variable">$&#123;f//path?/x&#125;</span>"</span>  <span class="comment"># = "x/x/file.ext"</span></div><div class="line"></div><div class="line"><span class="comment"># 字符串拆分</span></div><div class="line"><span class="built_in">readonly</span> DIR_SEP=<span class="string">"/"</span></div><div class="line">array=(<span class="variable">$&#123;f//$&#123;DIR_SEP&#125;</span>/ &#125;)</div><div class="line">second_dir=<span class="string">"<span class="variable">$&#123;arrray[1]&#125;</span>"</span>     <span class="comment"># = path2</span></div></pre></td></tr></table></figure>
<h3 id="删除头部或尾部-使用globbing"><a href="#删除头部或尾部-使用globbing" class="headerlink" title="删除头部或尾部(使用globbing)"></a>删除头部或尾部(使用globbing)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">f=<span class="string">"path1/path2/file.ext"</span></div><div class="line"></div><div class="line"><span class="comment"># 删除字符串头部</span></div><div class="line">extension=<span class="string">"<span class="variable">$&#123;f#*.&#125;</span>"</span>  <span class="comment"># = "ext"</span></div><div class="line"></div><div class="line"><span class="comment"># 以贪婪匹配方式删除字符串头部</span></div><div class="line">filename=<span class="string">"<span class="variable">$&#123;f##*/&#125;</span>"</span>  <span class="comment"># = "file.ext"</span></div><div class="line"></div><div class="line"><span class="comment"># 删除字符串尾部</span></div><div class="line">dirname=<span class="string">"<span class="variable">$&#123;f%/*&#125;</span>"</span>    <span class="comment"># = "path1/path2"</span></div><div class="line"></div><div class="line"><span class="comment"># 以贪婪匹配方式删除字符串尾部</span></div><div class="line">root=<span class="string">"<span class="variable">$&#123;f%%/*&#125;</span>"</span>      <span class="comment"># = "path1"</span></div></pre></td></tr></table></figure>
<h2 id="避免使用临时文件"><a href="#避免使用临时文件" class="headerlink" title="避免使用临时文件"></a>避免使用临时文件</h2><p>有些命令需要以文件名为参数，这样一来就不能使用管道。这个时候 &lt;() 就显出用处了，它可以接受一个命令，并把它转换成可以当成文件名之类的什么东西：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 下载并比较两个网页</span></div><div class="line">diff &lt;(wget -O - url1) &lt;(wget -O - url2)</div></pre></td></tr></table></figure></p>
<p>还有一个非常有用处的是”here documents”，它能让你在标准输入上输入多行字符串。下面的’MARKER’可以替换成任何字词。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 任何字词都可以当作分界符</span></div><div class="line"><span class="built_in">command</span>  &lt;&lt; MARKER</div><div class="line">...</div><div class="line"><span class="variable">$&#123;var&#125;</span></div><div class="line">$(cmd)</div><div class="line">...</div><div class="line">MARKER</div></pre></td></tr></table></figure></p>
<p>如果文本里没有内嵌变量替换操作，你可以把第一个MARKER用单引号包起来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">command</span> &lt;&lt; <span class="string">'MARKER'</span></div><div class="line">...</div><div class="line">no substitution is happening here.</div><div class="line">$ (dollar sign) is passed through verbatim.</div><div class="line">...</div><div class="line">MARKER</div></pre></td></tr></table></figure></p>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>脚本名称</td>
</tr>
<tr>
<td>$n</td>
<td>传给脚本/函数的第n个参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本的PID</td>
</tr>
<tr>
<td>$!</td>
<td>上一个被执行的命令的PID(后台运行的进程)</td>
</tr>
<tr>
<td>$?</td>
<td>上一个命令的退出状态(管道命令使用${PIPESTATUS})</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本/函数的参数个数</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本/函数的所有参数(识别每个参数)</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本/函数的所有参数(把所有参数当成一个字符串)</td>
</tr>
</tbody>
</table>
<p><strong>提示</strong></p>
<blockquote>
<p>使用$*很少是正确的选择。</p>
<p>$@能够处理空格参数，而且参数间的空格也能正确的处理。</p>
<p>使用$@时应该用双引号括起来，像”$@”这样。</p>
</blockquote>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>对脚本进行语法检查：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -n myscript.sh</div></pre></td></tr></table></figure></p>
<p>跟踪脚本里每个命令的执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -v myscripts.sh</div></pre></td></tr></table></figure></p>
<p>跟踪脚本里每个命令的执行并附加扩充信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -x myscript.sh</div></pre></td></tr></table></figure></p>
<p>你可以在脚本头部使用set -o verbose和set -o xtrace来永久指定-v和-o。当在远程机器上执行脚本时，这样做非常有用，用它来输出远程信息。</p>
<h2 id="什么时候不应该使用bash脚本"><a href="#什么时候不应该使用bash脚本" class="headerlink" title="什么时候不应该使用bash脚本"></a>什么时候不应该使用bash脚本</h2><ul>
<li>你的脚本太长，多达几百行</li>
<li>你需要比数组更复杂的数据结构</li>
<li>出现了复杂的转义问题</li>
<li>有太多的字符串操作</li>
<li>不太需要调用其它程序和跟其它程序管道交互</li>
<li>担心性能</li>
</ul>
<p>这个时候，你应该考虑一种脚本语言，比如Python或Ruby。</p>
<p>[转自 <a href="http://blog.sae.sina.com.cn/archives/3606" target="_blank" rel="external">http://blog.sae.sina.com.cn/archives/3606</a>]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里的技术技巧最初是来自谷歌的“Testing on the Toilet” (TOTT)。这里是一个修订和扩增版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脚本安全&lt;/li&gt;
&lt;li&gt;脚本函数&lt;/li&gt;
&lt;li&gt;变量注解&lt;/li&gt;
&lt;li&gt;用$()代替反单引号(`)&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;[[]]&lt;/code&gt;(双层中括号)替代[]&lt;/li&gt;
&lt;li&gt;正则表达式/Globbing&lt;/li&gt;
&lt;li&gt;字符串操作&lt;/li&gt;
&lt;li&gt;避免使用临时文件&lt;/li&gt;
&lt;li&gt;内置变量&lt;/li&gt;
&lt;li&gt;调试&lt;/li&gt;
&lt;li&gt;什么时候不应该使用bash脚本&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://weizhimiao.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法与实现（PHP）汇总</title>
    <link href="https://weizhimiao.github.io/2016/11/07/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88PHP%EF%BC%89%E6%B1%87%E6%80%BB/"/>
    <id>https://weizhimiao.github.io/2016/11/07/常见的排序算法与实现（PHP）汇总/</id>
    <published>2016-11-07T12:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>堆排序</li>
<li>桶排序</li>
<li>基数排序</li>
<li>希尔排序</li>
</ul>
<a id="more"></a>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>在排序的一组数中，对当前还未排好的序列，从前后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的数往上冒。</p>
<p>即，每当两个相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [bubblingSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bubblingSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    $len = count($arr);</div><div class="line"></div><div class="line">    <span class="comment">//控制需要冒泡的轮数</span></div><div class="line">    <span class="keyword">for</span>($i = <span class="number">1</span>;$i &lt; $len; $i++)&#123;</div><div class="line">      <span class="comment">//控制每层冒出一个数 需要比较的次数</span></div><div class="line">      <span class="keyword">for</span>($k = <span class="number">0</span>; $k &lt; $len-$i; $k++)&#123;</div><div class="line">        <span class="keyword">if</span>($arr[$k] &gt; $arr[$k+<span class="number">1</span>])&#123;</div><div class="line">          $temp = $arr[$k+<span class="number">1</span>];</div><div class="line">          $arr[$k+<span class="number">1</span>] = $arr[$k];</div><div class="line">          $arr[$k] = $temp;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(bubblingSort($arr));</div></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>在要排序的一组数中，选出最小的一个数与第一个位置的数交换。</p>
<p>然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [selectSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">selectSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    <span class="comment">//双重循环，外层控制循环轮数，内层控制比较次数</span></div><div class="line">    $len = count($arr);</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$len<span class="number">-1</span>;$i++)&#123;</div><div class="line">      <span class="comment">//先假设最小的值的位置</span></div><div class="line">      $p = $i;</div><div class="line"></div><div class="line">      <span class="keyword">for</span>($j=$i+<span class="number">1</span>;$j&lt;$len;$j++)&#123;</div><div class="line">        <span class="comment">//$arr[$p] 是当前已知的最小值</span></div><div class="line">        <span class="keyword">if</span>($arr[$p] &gt; $arr[$j])&#123;</div><div class="line">          <span class="comment">//比较，发现更小的，记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较</span></div><div class="line">          $p = $j;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。</span></div><div class="line">      <span class="keyword">if</span>($p != $i)&#123;</div><div class="line">        $tmp = $arr[$p];</div><div class="line">        $arr[$p] = $arr[$i];</div><div class="line">        $arr[$i] = $tmp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(selectSort($arr));</div></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插入到前面的有序数中，使得这n个数也是排好序的。如此反复循环，直到全部排好顺序。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [insertSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insertSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    $len = count($arr);</div><div class="line"></div><div class="line">    <span class="keyword">for</span>($i=<span class="number">1</span>;$i&lt;$len;$i++)&#123;</div><div class="line">      $tmp = $arr[$i];</div><div class="line">      <span class="comment">//内层循环控制，比较并插入</span></div><div class="line">      <span class="keyword">for</span>($j=$i<span class="number">-1</span>;$j&gt;=<span class="number">0</span>;$j--)&#123;</div><div class="line">        <span class="keyword">if</span>($tmp &lt; $arr[$j])&#123;</div><div class="line">          <span class="comment">//发现插入的元素要小，交换位置，将后边的元素与前面的元素互换</span></div><div class="line">          $arr[$j+<span class="number">1</span>] = $arr[$j];</div><div class="line">          $arr[$j] = $tmp;</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">          <span class="comment">//如果碰到不需要移动的元素，由于是已经排序好的数组，则前面的就不需要再次比较了</span></div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(insertSort($arr));</div></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。</p>
<p>此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [quickSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    <span class="comment">//先判断是否需要继续进行</span></div><div class="line">    $len = count($arr);</div><div class="line">    <span class="keyword">if</span>($len &lt;= <span class="number">1</span>)&#123;</div><div class="line">      <span class="keyword">return</span> $arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//选择第一个元素作为基准</span></div><div class="line">    $base_num = $arr[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">//遍历除了标尺外的所有元素，按照大小关系放入两个数组内</span></div><div class="line">    <span class="comment">//初始化两个数组</span></div><div class="line">    $left_array = <span class="keyword">array</span>();  <span class="comment">//小于基准值的数组</span></div><div class="line">    $right_array = <span class="keyword">array</span>();   <span class="comment">//大于基准的数组</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>($i=<span class="number">1</span>;$i&lt;$len;$i++)&#123;</div><div class="line">      <span class="keyword">if</span>($base_num &gt; $arr[$i])&#123;</div><div class="line">        <span class="comment">//放入左边</span></div><div class="line">        $left_array[] = $arr[$i];</div><div class="line">      &#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//放入右边</span></div><div class="line">        $right_array[] = $arr[$i];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数</span></div><div class="line">    $left_array = quickSort($left_array);</div><div class="line">    $right_array = quickSort($right_array);</div><div class="line"></div><div class="line">    <span class="comment">//合并</span></div><div class="line">    <span class="keyword">return</span> array_merge($left_array, <span class="keyword">array</span>($base_num), $right_array);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(quickSort($arr));</div></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>采用分治法，将已有序的子序列合并,从而得到完全有序的序列.</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [mergeSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    $len = count($arr);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>($len &lt; <span class="number">2</span>)&#123;</div><div class="line">      <span class="keyword">return</span> $arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获取中间参考点值</span></div><div class="line">    $middle = floor($len/<span class="number">2</span>);</div><div class="line">    <span class="comment">//取左边区间</span></div><div class="line">    $left = array_slice($arr, <span class="number">0</span>, $middle);</div><div class="line">    <span class="comment">//取右边区间</span></div><div class="line">    $right = array_slice($arr, $middle);</div><div class="line"></div><div class="line">    <span class="comment">//调用归并函数</span></div><div class="line">    <span class="keyword">return</span> merge(mergeSort($left), mergeSort($right));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 归并函数</div><div class="line">   * <span class="doctag">@param</span>  [type] $left  [description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $right [description]</div><div class="line">   * <span class="doctag">@return</span> [type]        [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">($left, $right)</span></span>&#123;</div><div class="line">    $res = <span class="keyword">array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(count($left) &gt; <span class="number">0</span> &amp;&amp; count($right) &gt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">if</span>($left[<span class="number">0</span>] &lt;= $right[<span class="number">0</span>])&#123;</div><div class="line">        array_push($res, array_shift($left));</div><div class="line">      &#125; <span class="keyword">else</span>&#123;</div><div class="line">        array_push($res, array_shift($right));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//解决$left遗留元素</span></div><div class="line">    <span class="keyword">while</span>(count($left) &gt; <span class="number">0</span>)&#123;</div><div class="line">      array_push($res, array_shift($left));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//解决$right遗留元素</span></div><div class="line">    <span class="keyword">while</span>(count($right) &gt; <span class="number">0</span>)&#123;</div><div class="line">      array_push($res, array_shift($right));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(mergeSort($arr));</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>思路分析<blockquote>
<p><strong>建堆</strong>，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。</p>
<p><strong>调整堆</strong>：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。</p>
<p><strong>堆排序</strong>：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是O(nlgn)。因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是lgn，调用了n-1次，所以堆排序的时间复杂度是O(nlgn)</p>
</blockquote>
</li>
</ul>
<ul>
<li>实现</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [heapSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">heapSort</span><span class="params">($arr)</span> </span>&#123;</div><div class="line">      <span class="comment">#初始化大顶堆</span></div><div class="line">      initHeap($arr, <span class="number">0</span>, count($arr) - <span class="number">1</span>);</div><div class="line"></div><div class="line">      <span class="comment">#开始交换首尾节点,并每次减少一个末尾节点再调整堆,直到剩下一个元素</span></div><div class="line">      <span class="keyword">for</span>($end = count($arr) - <span class="number">1</span>; $end &gt; <span class="number">0</span>; $end--) &#123;</div><div class="line">          $temp = $arr[<span class="number">0</span>];</div><div class="line">          $arr[<span class="number">0</span>] = $arr[$end];</div><div class="line">          $arr[$end] = $temp;</div><div class="line">          ajustNodes($arr, <span class="number">0</span>, $end - <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 初始化大顶堆</div><div class="line">   * 初始化最大堆,从最后一个非叶子节点开始,最后一个非叶子节点编号为 数组长度/2 向下取整</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initHeap</span><span class="params">(&amp;$arr)</span> </span>&#123;</div><div class="line">      $len = count($arr);</div><div class="line">      <span class="keyword">for</span>($start = floor($len / <span class="number">2</span>) - <span class="number">1</span>; $start &gt;= <span class="number">0</span>; $start--) &#123;</div><div class="line">          ajustNodes($arr, $start, $len - <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 调整节点</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr   待调整数组</div><div class="line">   * <span class="doctag">@param</span>  [type] $start 调整的父节点坐标</div><div class="line">   * <span class="doctag">@param</span>  [type] $end   待调整数组结束节点坐标</div><div class="line">   * <span class="doctag">@return</span> [type]        [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ajustNodes</span><span class="params">(&amp;$arr, $start, $end)</span> </span>&#123;</div><div class="line">      $maxInx = $start;</div><div class="line">      $len = $end + <span class="number">1</span>;    <span class="comment">#待调整部分长度</span></div><div class="line">      $leftChildInx = ($start + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;    <span class="comment">#左孩子坐标</span></div><div class="line">      $rightChildInx = ($start + <span class="number">1</span>) * <span class="number">2</span>;    <span class="comment">#右孩子坐标</span></div><div class="line"></div><div class="line">      <span class="comment">#如果待调整部分有左孩子</span></div><div class="line">      <span class="keyword">if</span>($leftChildInx + <span class="number">1</span> &lt;= $len) &#123;</div><div class="line">          <span class="comment">#获取最小节点坐标</span></div><div class="line">          <span class="keyword">if</span>($arr[$maxInx] &lt; $arr[$leftChildInx]) &#123;</div><div class="line">              $maxInx = $leftChildInx;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">#如果待调整部分有右子节点</span></div><div class="line">          <span class="keyword">if</span>($rightChildInx + <span class="number">1</span> &lt;= $len) &#123;</div><div class="line">              <span class="keyword">if</span>($arr[$maxInx] &lt; $arr[$rightChildInx]) &#123;</div><div class="line">                  $maxInx = $rightChildInx;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">#交换父节点和最大节点</span></div><div class="line">      <span class="keyword">if</span>($start != $maxInx) &#123;</div><div class="line">          $temp = $arr[$start];</div><div class="line">          $arr[$start] = $arr[$maxInx];</div><div class="line">          $arr[$maxInx] = $temp;</div><div class="line"></div><div class="line">          <span class="comment">#如果交换后的子节点还有子节点,继续调整</span></div><div class="line">          <span class="keyword">if</span>(($maxInx + <span class="number">1</span>) * <span class="number">2</span> &lt;= $len) &#123;</div><div class="line">              ajustNodes($arr, $maxInx, $end);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var_dump(heapSort($arr));</div></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>先将数组根据其值的大小放入到桶的相应位置，然后在按照顺序将元素从桶中取出。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [tongSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $max [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tongSort</span><span class="params">($arr, $max)</span></span>&#123;</div><div class="line">    $len = count($arr);</div><div class="line"></div><div class="line">    <span class="comment">//填充木桶</span></div><div class="line">		$tong = <span class="keyword">array</span>();</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$max;$i++)&#123;</div><div class="line">      $tong[$i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">		<span class="comment">//开始标示木桶</span></div><div class="line">		<span class="keyword">for</span>($i = <span class="number">0</span>; $i&lt;$len; $i++)&#123;</div><div class="line">			$tong[$arr[$i]]++;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		$res = <span class="keyword">array</span>();</div><div class="line">		<span class="comment">//开始从木桶中拿出数据</span></div><div class="line">		<span class="keyword">for</span>($i = <span class="number">0</span>; $i&lt; $max ; $i++)&#123;</div><div class="line">        <span class="keyword">if</span>($tong[$i] &gt; <span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">for</span>($j = <span class="number">1</span>; $j &lt;= $tong[$i]; $j++)&#123; <span class="comment">//这一行主要用来控制输出多个数</span></div><div class="line">            $res[] = $i;</div><div class="line">    			&#125;</div><div class="line">        &#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> $res;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">  var_dump(tongSort($arr, <span class="number">1000</span>));</div></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul>
<li><p>思路分析</p>
<blockquote>
<p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</p>
<p>然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [countingSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type]  $arr       [description]</div><div class="line">   * <span class="doctag">@param</span>  boolean $digit_num [description]</div><div class="line">   * <span class="doctag">@return</span> [type]             [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countingSort</span><span class="params">($arr, $digit_num = false)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> ($digit_num !== <span class="keyword">false</span>) &#123; <span class="comment">#如果参数$digit_num不为空，则根据元素的第$digit_num位数进行排序</span></div><div class="line">       <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($arr); $i++) &#123;</div><div class="line">         $arr_temp[$i] = get_specific_digit($arr[$i], $digit_num);</div><div class="line">       &#125;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       $arr_temp = $arr;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     $max = max($arr);</div><div class="line">     $time_arr = <span class="keyword">array</span>(); <span class="comment">#储存元素出现次数的数组</span></div><div class="line"></div><div class="line">     <span class="comment">#初始化出现次数数组</span></div><div class="line">     <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt;= $max; $i++) &#123;</div><div class="line">       $time_arr[$i] = <span class="number">0</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">#统计每个元素出现次数</span></div><div class="line">     <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($arr_temp); $i++) &#123;</div><div class="line">       $time_arr[$arr_temp[$i]]++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">#统计每个元素比其小或相等的元素出现次数</span></div><div class="line">     <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($time_arr) - <span class="number">1</span>; $i++) &#123;</div><div class="line">       $time_arr[$i + <span class="number">1</span>] += $time_arr[$i];</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">#利用出现次数对数组进行排序</span></div><div class="line">     <span class="keyword">for</span>($i = count($arr) - <span class="number">1</span>; $i &gt;= <span class="number">0</span>; $i--) &#123;</div><div class="line">       $sorted_arr[$time_arr[$arr_temp[$i]] - <span class="number">1</span>] = $arr[$i];</div><div class="line">       $time_arr[$arr_temp[$i]]--;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     $arr = $sorted_arr;</div><div class="line">     ksort($arr);  <span class="comment">#忽略这次对key排序的效率损耗</span></div><div class="line">     <span class="keyword">return</span> $arr;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 计算某个数的位数</div><div class="line">    * <span class="doctag">@param</span>  [type] $number [description]</div><div class="line">    * <span class="doctag">@return</span> [type]         [description]</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">get_digit</span><span class="params">($number)</span> </span>&#123;</div><div class="line">     $i = <span class="number">1</span>;</div><div class="line">     <span class="keyword">while</span> ($number &gt;= pow(<span class="number">10</span>, $i)) &#123;</div><div class="line">      $i++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> $i;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 获取某个数字的从个位算起的第i位数</div><div class="line">    * <span class="doctag">@param</span>  [type] $num [description]</div><div class="line">    * <span class="doctag">@param</span>  [type] $i   [description]</div><div class="line">    * <span class="doctag">@return</span> [type]      [description]</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">get_specific_digit</span><span class="params">($num, $i)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> ($num &lt; pow(<span class="number">10</span>, $i - <span class="number">1</span>)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> floor($num % pow(<span class="number">10</span>, $i) / pow(<span class="number">10</span>, $i - <span class="number">1</span>));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 基数排序,以计数排序作为子排序过程</div><div class="line">    * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">    * <span class="doctag">@return</span> [type]      [description]</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">radix_sort</span><span class="params">(&amp;$arr)</span> </span>&#123;</div><div class="line">     <span class="comment">#先求出数组中最大的位数</span></div><div class="line">     $max = max($arr);</div><div class="line">     $max_digit = get_digit($max);</div><div class="line"></div><div class="line">     <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max_digit; $i++) &#123;</div><div class="line">       counting_sort($arr, $i);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   var_dump(countingSort($arr));</div></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul>
<li><p>思路分析：</p>
<blockquote>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
</blockquote>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">223</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">54</span>,<span class="number">455</span>,<span class="number">26</span>,<span class="number">823</span>,<span class="number">45</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">65</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [shellSort description]</div><div class="line">   * <span class="doctag">@param</span>  [type] $arr [description]</div><div class="line">   * <span class="doctag">@return</span> [type]      [description]</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">shellSort</span><span class="params">($arr)</span></span>&#123;</div><div class="line">    $length=count($arr);</div><div class="line">    $h=<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>($h&lt;$length/<span class="number">3</span>)</div><div class="line">    &#123;</div><div class="line">      $h=<span class="number">3</span>*$h+<span class="number">1</span>;<span class="comment">//设置间隔</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>($h&gt;=<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>($i=$h; $i&lt;$length; $i++)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">for</span>($j=$i; $j&gt;=$h &amp;&amp; $arr[$j]&lt;$arr[$j-$h]; $j-=$h)</div><div class="line">        &#123;</div><div class="line">           $temp =$arr[$j-$h];</div><div class="line">           $arr[$j-$h]=$arr[$j];</div><div class="line">           $arr[$j]=$temp;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      $h=($h<span class="number">-1</span>)/<span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $arr;</div><div class="line">  &#125;</div><div class="line">  var_dump(shellSort($arr));</div></pre></td></tr></table></figure>
<h2 id="简单比较"><a href="#简单比较" class="headerlink" title="简单比较"></a>简单比较</h2><p><img src="http://n.sinaimg.cn/games/3ece443e/20161107/sort_img.png" alt="sort"></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;桶排序&lt;/li&gt;
&lt;li&gt;基数排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
      <category term="算法" scheme="https://weizhimiao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux中常用的shell脚本（二）</title>
    <link href="https://weizhimiao.github.io/2016/11/01/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84shell%E8%84%9A%E6%9C%AC%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://weizhimiao.github.io/2016/11/01/Linux中常用的shell脚本（二）/</id>
    <published>2016-11-01T12:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://n.sinaimg.cn/games/3ece443e/20161030/bash.png" alt="Linux中常用的shell脚本"></p>
<a id="more"></a>
<p>1、进程运行前后台切换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ctrl+z		# 将进程转入后台运行</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fg				# 将进程转到前台</div></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ ping www.baidu.com</div><div class="line">PING www.a.shifen.com (119.75.217.109): 56 data bytes</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=0 ttl=57 time=6.829 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=1 ttl=57 time=32.417 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=2 ttl=57 time=5.999 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=3 ttl=57 time=21.105 ms</div><div class="line">^Z</div><div class="line">[1]  + 1879 suspended  ping www.baidu.com</div><div class="line">--------------------------------------------------------------</div><div class="line">$ fg                </div><div class="line">[1]  + 1879 continued  ping www.baidu.com</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=4 ttl=57 time=27.063 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=5 ttl=57 time=5.939 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=6 ttl=57 time=6.633 ms</div><div class="line">64 bytes from 119.75.217.109: icmp_seq=7 ttl=57 time=7.462 ms</div><div class="line">^C</div><div class="line">--- www.a.shifen.com ping statistics ---</div><div class="line">8 packets transmitted, 8 packets received, 0.0% packet loss</div><div class="line">round-trip min/avg/max/stddev = 5.939/14.181/32.417/10.232 ms</div></pre></td></tr></table></figure></p>
<p>2、截取前5个字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ var=&quot;hello world&quot;</div><div class="line">$ echo $&#123;var:0:5&#125;</div><div class="line">hello</div></pre></td></tr></table></figure></p>
<p>3、一次创建多个目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p data/&#123;test,test1,test2&#125;</div><div class="line">$ tree data</div><div class="line">data</div><div class="line">├── test</div><div class="line">├── test1</div><div class="line">└── test2</div></pre></td></tr></table></figure></p>
<p>4、获得文本的md5 hash<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo -n &quot;testText&quot; | md5sum</div></pre></td></tr></table></figure></p>
<p>5、将tar.gz提取到新目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar -zxvf package.tar.gz -C /path/to/new</div></pre></td></tr></table></figure></p>
<p>6、通过curl获取HTTP头信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ curl -I http://www.baidu.com</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: bfe/1.0.8.18</div><div class="line">Date: Tue, 01 Nov 2016 15:00:30 GMT</div><div class="line">Content-Type: text/html</div><div class="line">Content-Length: 277</div><div class="line">Last-Modified: Mon, 13 Jun 2016 02:50:08 GMT</div><div class="line">Connection: Keep-Alive</div><div class="line">ETag: &quot;575e1f60-115&quot;</div><div class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</div><div class="line">Pragma: no-cache</div><div class="line">Accept-Ranges: bytes</div></pre></td></tr></table></figure></p>
<p>7、快速备份一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ll</div><div class="line">-rw-r--r--   1 zhimiao  staff   200B  2 29  2016 test.txt</div><div class="line"></div><div class="line">$ cp test.txt&#123;,.bak&#125;</div><div class="line"></div><div class="line">$ ll</div><div class="line">-rw-r--r--   1 zhimiao  staff   200B  2 29  2016 test.txt</div><div class="line">-rw-r--r--   1 zhimiao  staff   200B 11  1 23:02 test.txt.bak</div></pre></td></tr></table></figure></p>
<p>8、利用cat快速输入多行文字（Ctrl+d 退出）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ cat &gt; test2.txt</div><div class="line">weizhadf</div><div class="line">asdfads</div><div class="line">asdf</div><div class="line">adsf</div><div class="line">asdf</div><div class="line">adf</div><div class="line">(Ctrl+d)</div><div class="line"></div><div class="line">$ cat test2.txt</div><div class="line">weizhadf</div><div class="line">asdfads</div><div class="line">asdf</div><div class="line">adsf</div><div class="line">asdf</div><div class="line">adf</div></pre></td></tr></table></figure></p>
<p>9、重复运行命令，并显示其输出（默认是2秒运行一次）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">watch ps -ef</div><div class="line">Every 2.0s: ps -ef                                                                     Tue Nov  1 23:10:06 2016</div><div class="line"></div><div class="line">  UID   PID  PPID   C STIME   TTY           TIME CMD</div><div class="line">    0     1     0   0 10:28    ??         0:05.23 /sbin/launchd</div><div class="line">    0    47     1   0 10:28    ??         0:01.21 /usr/libexec/UserEventAgent (System)</div><div class="line">    0    48     1   0 10:28    ??         0:00.42 /usr/sbin/syslogd</div><div class="line">    0    50     1   0 10:28    ??         0:00.14 /System/Library/PrivateFrameworks/Uninstall.framework/Resourc</div><div class="line">es/uninstalld</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>10、递归查找目录中文件中的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ grep -r &quot;some_text&quot; /path/</div></pre></td></tr></table></figure></p>
<p>11、将所有的文件名中含有”*.txt”的文件，移入指定目录中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find -iname &quot;*.txt*&quot; -exec mv -v &#123;&#125; /home/user \;</div></pre></td></tr></table></figure></p>
<p>12、拆分大体积tar.gz文件（拆成每个100MB），然后合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ split -b 100m /path/to/large/archive /path/to/output/files</div><div class="line">$ cat files* &gt; archive</div></pre></td></tr></table></figure></p>
<p>13、Shell(Bash)中如何判断是否存在某个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 判断foo命令是否存在</div><div class="line">$ command -v foo &gt;/dev/null 2&gt;&amp;1 || &#123; echo &gt;&amp;2 &quot;I require foo but it&apos;s not installed.  Aborting.&quot;; exit 1; &#125;</div><div class="line">$ type foo &gt;/dev/null 2&gt;&amp;1 || &#123; echo &gt;&amp;2 &quot;I require foo but it&apos;s not installed.  Aborting.&quot;; exit 1; &#125;</div><div class="line">$ hash foo 2&gt;/dev/null || &#123; echo &gt;&amp;2 &quot;I require foo but it&apos;s not installed.  Aborting.&quot;; exit 1; &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161030/bash.png&quot; alt=&quot;Linux中常用的shell脚本&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://weizhimiao.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux中常用的shell脚本</title>
    <link href="https://weizhimiao.github.io/2016/10/30/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84shell%E8%84%9A%E6%9C%AC/"/>
    <id>https://weizhimiao.github.io/2016/10/30/Linux中常用的shell脚本/</id>
    <published>2016-10-30T12:30:00.000Z</published>
    <updated>2017-03-09T08:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://n.sinaimg.cn/games/3ece443e/20161030/bash.png" alt="Linux中常用的shell脚本"></p>
<a id="more"></a>
<p>1、对于进程来说，查看其运行时的环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/$PID/environ</div></pre></td></tr></table></figure></p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#首先需要我们运行一个程序</div><div class="line"># pgrep inotifywait</div><div class="line">8977</div><div class="line"># cat /proc/8977/environ</div><div class="line">HOSTNAME=localhost.localdomainSELINUX_ROLE_REQUESTED=TERM=xterm-256colorSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=192.168.1.100 63684 22SELINUX_USE_CURRENT_RANGE=SSH_TTY=/dev/pts/0USER=rootLS_COLORS=rs=0:di=38;... %sG_BROKEN_FILENAMES=1_=/usr/local/bin/inotifywaitOLDPWD=/data</div><div class="line">#一般返回的环境变量会有很多，我们采用换行方式查看会更直观</div><div class="line"></div><div class="line"># cat /proc/8977/environ | tr &apos;\0&apos; &apos;\n&apos;</div><div class="line">HOSTNAME=localhost.localdomain</div><div class="line">SELINUX_ROLE_REQUESTED=</div><div class="line">TERM=xterm-256color</div><div class="line">SHELL=/bin/bash</div><div class="line">HISTSIZE=1000</div><div class="line">SSH_CLIENT=192.168.1.100 63684 22</div><div class="line">SELINUX_USE_CURRENT_RANGE=</div><div class="line">SSH_TTY=/dev/pts/0</div><div class="line">USER=root</div><div class="line">....</div></pre></td></tr></table></figure></p>
<p>2、获得字符串长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># var=wahaha</div><div class="line"># echo $&#123;var&#125;</div><div class="line">wahaha</div><div class="line"># echo $&#123;#var&#125;</div><div class="line">6</div></pre></td></tr></table></figure></p>
<p>3、识别当前使用的是哪种shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo $SHELL</div><div class="line">/bin/bash</div></pre></td></tr></table></figure></p>
<p>4、shell脚本检查是执行当前脚本的是否为root用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># cat check_root.sh</div><div class="line">#!/bin/bash</div><div class="line">if [ $UID -ne 0 ]; then</div><div class="line">	echo &quot;Non root user. Please run as root.&quot;</div><div class="line">else</div><div class="line">	echo Root User</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>5、修改bash提示字符串（username@hastname:~$）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#利用PS1环境变量来定制</div><div class="line"># cat ~/.bashrc | grep PS1</div><div class="line">PS1=&apos;$&#123;debian_chroot:+$($debian_chroot)&#125;\u@\h:\w\$ &apos;</div><div class="line"># \u 用户名</div><div class="line"># \h 主机名</div><div class="line"># \w 当前工作目录</div></pre></td></tr></table></figure></p>
<p>6、如何判断一个命令是否执行成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">当一个命令发生错误并退回时，他会返回一个非0的退出状态；</div><div class="line">而当命令成功完成后，它会返回数字0.</div><div class="line">退出状态可以从特殊变量 $? 中获得（在命令执行之后立刻运行 $? ,就可以打印出退出状态）</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">CMD=&quot;commod&quot;  #commod代表需要检测退出状态的命令</div><div class="line">$CMD</div><div class="line">if [ $? -eq 0 ];</div><div class="line">then</div><div class="line">  echo &quot;$CMD executed succ&quot;</div><div class="line">else</div><div class="line">  echo &quot;$CMD excuted unsucc&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>7、shell中数组的定义与操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#定义1</div><div class="line">array_var=(1 2 3 4 5)</div><div class="line">#定义2</div><div class="line">array_var[0]=&quot;test&quot;</div><div class="line">array_var[1]=&quot;test1&quot;</div><div class="line">array_var[2]=&quot;test2&quot;</div><div class="line">array_var[3]=&quot;test3&quot;</div><div class="line">#打印特定索引数组元素</div><div class="line">echo $&#123;array_var[0]&#125;</div><div class="line">#以清单形式打印出数组中的所有值</div><div class="line">echo $&#123;array_var[*]&#125;</div><div class="line">test test1 test2 test3</div><div class="line">#也可以</div><div class="line">echo $&#123;array_var[@]&#125;</div><div class="line">test test1 test2 test3</div><div class="line">#输出数组元素个数</div><div class="line">echo $&#123;#array_var[*]&#125;</div><div class="line">4</div></pre></td></tr></table></figure></p>
<p>8、按照指定格式打印系统当前时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># date &quot;+%Y%m%d&quot;</div><div class="line">20161029</div><div class="line"># %a  星期  例，Sat</div><div class="line"># %A  星期  例，Saturday</div><div class="line"># %b  月    例，Nov</div><div class="line"># %B  月    例，November</div><div class="line"># %d  日   例，31</div><div class="line"># %D  固定格式(mm/dd/yy)  例，10/18/10</div><div class="line"># %y  年   例，16</div><div class="line"># %Y  年   例，2016</div><div class="line"># %I或%H 小时  例，08</div><div class="line"># %M  分钟  例，30</div><div class="line"># %S  秒   例，10</div><div class="line"># %N  纳秒  例，694394444</div></pre></td></tr></table></figure></p>
<p>9、shell函数参数传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">func()&#123;</div><div class="line">  echo $1,$2  #访问参数1和参数2</div><div class="line">  echo &quot;$@&quot;   #以列表方式一次性打印所有参数</div><div class="line">  echo &quot;$*&quot;   #类似于$@,但是参数被作为单个实体</div><div class="line">  return 0;   #返回值</div><div class="line">&#125;</div><div class="line"></div><div class="line"># $1,  第一个参数</div><div class="line"># $2,  第二个参数</div><div class="line"># $n,  第n个参数</div><div class="line"># &quot;$@&quot;,   被扩展成&quot;$1&quot; &quot;$2&quot; &quot;$3&quot;等</div><div class="line"># &quot;$*&quot;,   被扩展成&quot;$1c$2c$3&quot; ，其中c是IFS的第一个字符</div><div class="line"># &quot;$@&quot;要比&quot;$*&quot;用的多。由于&quot;$*&quot;将所有参数当做单个字符串，因此它很少被使用</div></pre></td></tr></table></figure></p>
<p>10、利用子shell生成独立进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># cat sub_shell.sh</div><div class="line">#!/bin/bash</div><div class="line">pwd;</div><div class="line">(cd /bin; pwd);</div><div class="line">pwd;</div><div class="line"># ./sub_shell.sh</div><div class="line">/root/shell</div><div class="line">/bin</div><div class="line">/root/shell</div><div class="line"></div><div class="line"># 我们可以发现（）中的子shell对于当前shell没有影响，它所有的改变仅限于（）内部</div></pre></td></tr></table></figure></p>
<p>11、运行命令直至成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">repeat()&#123;</div><div class="line">  while true</div><div class="line">  do</div><div class="line">    $@  &amp;&amp; return</div><div class="line">  done</div><div class="line">&#125;</div><div class="line"># 原理：该函数通过$@接收传参。如果命令执行成功，则返回并退出循环，否则一直循环</div><div class="line"></div><div class="line"># Tips：将该函数加入的shell的rc文件中，方便我们使用</div><div class="line"></div><div class="line"># 示例：使用repeat（）从网上下载一个文件，直至成功</div><div class="line">repeat wget -c http://xxxx.com/example.tar.gz</div></pre></td></tr></table></figure></p>
<p>12、删除多余的空行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># cat -s file &gt;&gt; newfile</div></pre></td></tr></table></figure></p>
<p>13、文件查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># find /home -name &quot;*.txt&quot;</div><div class="line"># find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>14、排序、去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 排序  sort</div><div class="line"># 去重  uniq</div><div class="line">sort file.txt | uniq</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># cat check_sorted.sh</div><div class="line">#!/bin/bash</div><div class="line"># 功能：检查文件是否已经排序过</div><div class="line">sort -C filename;</div><div class="line">if [ $? -eq 0 ]</div><div class="line">then</div><div class="line">  echo Sorted</div><div class="line">else</div><div class="line">  echo Unsorted</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>15、交互输出自动化实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># 文件名：enter.sh</div><div class="line">read -p &quot;Enter number:&quot; no ;</div><div class="line">read -p &quot;Enter name&quot; name ;</div><div class="line">echo You have entered $no $name;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#利用echo -e来生成输入序列</div><div class="line">echo -e &quot;1\nhello\n&quot; | ./enter.sh</div></pre></td></tr></table></figure>
<p>16、利用并行进程加速命令执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">PIDARRAY=()</div><div class="line">for file in File1.ios File2.ios</div><div class="line">do</div><div class="line">  md5sum $file &amp;</div><div class="line">  PIDARRAY+=(&quot;$!&quot;)</div><div class="line">done</div><div class="line">wait $&#123;PIDARRAY[@]&#125;</div><div class="line"># 原理：利用bash的操作符&amp;，它使得shell将命令置于后台并继续执行脚本。使用 $! 来获得进程的PID（在bash中 $! 保存最近一个后台进程的PID）。将这些进程PID放入PIDARRAY数组中。使用wait命令等待这些进程执行完成。</div></pre></td></tr></table></figure></p>
<p>17、查找并删除内容重复的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#创建测试文件testfile，testfile1，testfile2，newfile ;其中testfile1和testfile2都是testfile的副本</div><div class="line"></div><div class="line"># echo &quot;hello&quot; &gt;&gt; testfile</div><div class="line"># cp testfile testfile1</div><div class="line"># cp testfile testfile2</div><div class="line"># echo hello world &gt;&gt; newfile</div><div class="line"></div><div class="line"># cat remove_duplicates.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ls -lS --time-style=long-iso | awk &apos;BEGIN &#123;</div><div class="line">	getline; getline;</div><div class="line">	name1=$8; size=$5;</div><div class="line">&#125;&#123;</div><div class="line">	name2=$8</div><div class="line">	if(size==$5)&#123;</div><div class="line">		&quot;md5sum &quot;name1 | getline; csum1=$1;</div><div class="line">		&quot;md5sum &quot;name2 | getline; csum2=$1;</div><div class="line">		if(csum1==csum2)&#123;</div><div class="line">			print name1;</div><div class="line">			print name2;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	size=$5;</div><div class="line">	name1=name2;</div><div class="line">&#125;&apos; | sort -u &gt; duplicate_files</div><div class="line"></div><div class="line">cat duplicate_files | xargs -I &#123;&#125; md5sum &#123;&#125; | sort | uniq -w 32 | awk &apos;&#123;print &quot;^&quot;$2&quot;$&quot; &#125;&apos; | sort -u &gt; duplicate_sample</div><div class="line"></div><div class="line">echo Removing...</div><div class="line">comm duplicate_files duplicate_sample -2 -3 | tee /dev/stderr | xargs rm</div><div class="line">rm -f duplicate_files duplicate_sample</div><div class="line">echo Removed duplicates files successfully</div><div class="line"></div><div class="line"># 执行脚本</div><div class="line"># ./remove_duplicates.sh</div><div class="line">Removing...</div><div class="line">testfile</div><div class="line">testfile1</div><div class="line">Removed duplicates files successfully</div><div class="line"></div><div class="line"># 如上testfile、testfile1、testfile2这三个相同内容的文件，只保留了testfile2.</div><div class="line"></div><div class="line"># 脚本原理说明：</div><div class="line"># ls -lS 将当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息</div><div class="line"># awk命令的执行步骤：awk首先会执行BEGIN&#123;&#125;语句块，处理完&#123;&#125;中所有的命令后，在执行END&#123;&#125;语句块</div><div class="line"># 在awk中，外部的命令的输出可以用这样的方式来读取，&quot;cmd&quot; | getline ，随后我们就可以用 $0 来获取命令的输出 ，在$1,$2,$3...$n 获取命令输出中的每一列</div><div class="line"># BEGIN&#123;&#125;语句块中有两个getline;是因为 ls -lS --time-style=long-iso 命令的输出的第一行是文件的数量，所以我们直接跳过，来获取下一行数据</div><div class="line"># comm 通常只接受排过序的文件。所以在之前需要使用 sort -u 进行排序</div><div class="line"># tee 命令在这有一个妙用：它将文件名在传递给rm命令的同时，也起到了print的效果。tee将来自stdin的行写入文件，同事将其发送到stdout</div></pre></td></tr></table></figure></p>
<p>18、解析文本中的电子邮件地址和URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># 正则表达式</div><div class="line">#   mail：[a-zA-Z0-9.]+@[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,4&#125;</div><div class="line">#   URL： (http|https)://[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,3&#125;</div><div class="line"></div><div class="line"># wget www.sina.com.cn/index.html</div><div class="line"></div><div class="line"># 解析index.html中的email</div><div class="line"># egrep -o &quot;[a-zA-Z0-9.]+@[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,4&#125;&quot; index.html</div><div class="line">jubao@vip.sina.com</div><div class="line">jubao@vip.sina.com</div><div class="line"></div><div class="line"># 解析index.html中的URL</div><div class="line"># egrep -o &quot;(http|https)://[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,3&#125;&quot; index.html</div><div class="line">http://www.sina.com.cn</div><div class="line">http://www.sina.com.cn</div><div class="line">http://auto.sina.com.cn</div><div class="line">http://www.sina.com.cn</div><div class="line">...</div><div class="line">http://hq.sinajs.cn</div><div class="line">http://rm.sina.com.cn</div><div class="line">http://d4.sina.com.cn</div><div class="line">http://d1.sina.com.cn</div><div class="line">http://i1.sinaimg.cn</div><div class="line">http://news.sina.com.cn</div><div class="line">http://login.sina.com.cn</div><div class="line">http://login.sina.com.cn</div></pre></td></tr></table></figure></p>
<p>19、以纯文本形式下载网页<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lynx:是一款基于命令行的web浏览器。我们可以利用它获取纯文本形式的网页</div><div class="line"></div><div class="line">命令：</div><div class="line"># lynx -dump http://www.sina.com.cn</div><div class="line">-dump 选项表示将网页内容以ASCII编码形式打印</div><div class="line"></div><div class="line">另，lynx会将页面中所有的超链接（&lt;a href=&quot;link&quot;&gt;）作为文本的页脚，单独放置在标题为 References 的文本区域。如果我们需要匹配除某个页面中所有的超链接也可以使用该方法，也省的我们用正则匹配</div></pre></td></tr></table></figure></p>
<p>20、列出网络上所有的活动主机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># cat ping.sh</div><div class="line">#!/bin/bash</div><div class="line">for ip in 192.168.1.&#123;1..255&#125;;</div><div class="line">do</div><div class="line">	ping $ip -c 2 &amp;&gt; /dev/null;</div><div class="line"></div><div class="line">	if [ $? -eq 0 ]</div><div class="line">	then</div><div class="line">		echo $ip is alive</div><div class="line">	fi</div><div class="line">done</div><div class="line"></div><div class="line"># 并行ping</div><div class="line"># cat ping_1.sh</div><div class="line">#!/bin/bash</div><div class="line">for ip in 192.168.1.&#123;1..255&#125;;</div><div class="line">do</div><div class="line">	(</div><div class="line">	ping $ip -c 2 &amp;&gt; /dev/null;</div><div class="line"></div><div class="line">	if [ $? -eq 0 ]</div><div class="line">	then</div><div class="line">		echo $ip is alive</div><div class="line">	fi</div><div class="line">	)&amp;</div><div class="line">done</div><div class="line">wait</div><div class="line"></div><div class="line"># 将wait放在脚本最后，它就会一直等到所有的子脚本进程全部结束</div></pre></td></tr></table></figure></p>
<p>21、网络上利用套接字进行快速文件复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 设置侦听套接字</div><div class="line">nc -l 1234</div><div class="line"></div><div class="line"># 在另一终端或主机中连接到该套接字</div><div class="line">nc 127.0.0.1 1234</div><div class="line">message_test</div><div class="line"></div><div class="line"># 连接到套接字后就可以在终端中输入信息回车就会发送</div><div class="line"></div><div class="line"># 文件复制</div><div class="line">在接收端执行以下命令：</div><div class="line">nc -l 1234 &gt; destination_filename</div><div class="line">在发送端执行下列命令：</div><div class="line">nc 127.0.0.1 1234 &lt; source_filename</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161030/bash.png&quot; alt=&quot;Linux中常用的shell脚本&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://weizhimiao.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux中通过inotify-tools实现监控文件变化</title>
    <link href="https://weizhimiao.github.io/2016/10/29/Linux%E4%B8%AD%E9%80%9A%E8%BF%87inotify-tools%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96/"/>
    <id>https://weizhimiao.github.io/2016/10/29/Linux中通过inotify-tools实现监控文件变化/</id>
    <published>2016-10-29T12:30:00.000Z</published>
    <updated>2017-02-27T03:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>inotify-tools 是一个用C语言库，一个为Linux提供简单inotify接口的命令行程序。这些程序可以用于监视文件系统事件并执行相应操作。这些程序是用C语言来写的，除了需要Linux内核的inotify支持外，没有其他的依赖。inotify-tools 3.14是目前最新版本，其于2010年3月7日发布。</p>
<p>那么什么inotify又是什么？</p>
<p>inotify，它是Linux在内核 2.6.13 (June 18, 2005)版本中引入的一个新功能，它为用户态监视文件系统的变化提供了强大的支持，允许监控程序打开一个独立文件描述符，并针对事件集监控一个或者多个文件，例如打开、关闭、移动/重命名、删除、创建或者改变属性。</p>
<p>官方站点地址：<a href="http://inotify-tools.sourceforge.net/" target="_blank" rel="external">http://inotify-tools.sourceforge.net/</a><br>Github地址：<a href="https://github.com/rvoicilas/inotify-tools" target="_blank" rel="external">https://github.com/rvoicilas/inotify-tools</a></p>
<a id="more"></a>
<h2 id="inotify安装"><a href="#inotify安装" class="headerlink" title="inotify安装"></a>inotify安装</h2><h3 id="inotify支持检测"><a href="#inotify支持检测" class="headerlink" title="inotify支持检测"></a>inotify支持检测</h3><p>只有在内核 2.6.13 (June 18, 2005)以上的Linux版本中才支持inotify-tools。</p>
<p>查看当前系统是否支持inotify， 可用通过 uname -a 查看你的内核版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">uname -a</div><div class="line">Linux localhost.localdomain 2.6.32-279.el6.i686 #1 SMP Fri Jun 22 10:59:55 UTC 2012 i686 i686 i386 GNU/Linux</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /proc/version</div><div class="line">Linux version 2.6.32-279.el6.i686 (mockbuild@c6b9.bsys.dev.centos.org) (gcc version 4.4.6 20120305 (Red Hat 4.4.6-4) (GCC) ) #1 SMP Fri Jun 22 10:59:55 UTC 2012</div></pre></td></tr></table></figure></p>
<p>或者查看<code>/proc/sys/fs/inotify/</code>，如果看到显示 max_queued_events max_user_instances max_user_watches 则说明支持inotify<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls /proc/sys/fs/inotify/</div><div class="line">max_queued_events  max_user_instances  max_user_watches</div></pre></td></tr></table></figure></p>
<h3 id="inotify-tools安装"><a href="#inotify-tools安装" class="headerlink" title="inotify-tools安装"></a>inotify-tools安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#wget --no-check-certificate https://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz</div><div class="line">#tar zxvf inotify-tools-3.14.tar.gz</div><div class="line">#cd inotify-tools-3.14</div><div class="line">#./configure</div><div class="line">#make</div><div class="line">#make install</div></pre></td></tr></table></figure>
<p>注：源码包安装需要编译，需要系统已经安装过C编译器</p>
<p>在系统下执行man inotify 、 man inotifywait、man inotifywatch即可得到相应的帮助信息，如果看到信息 则表示安装完成.</p>
<h2 id="inotify-tools使用"><a href="#inotify-tools使用" class="headerlink" title="inotify-tools使用"></a>inotify-tools使用</h2><h3 id="inotify-的默认内核参数详解"><a href="#inotify-的默认内核参数详解" class="headerlink" title="inotify 的默认内核参数详解"></a>inotify 的默认内核参数详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/proc/sys/fs/inotify/max_queued_events</div><div class="line">    默认值: 16384</div><div class="line">    该文件中的值为调用inotify_init时分配给inotify instance中可排队的event的数目的最大值，超出这个值得事件被丢弃，但会触发IN_Q_OVERFLOW事件</div><div class="line">/proc/sys/fs/inotify/max_user_instances</div><div class="line">    默认值: 128</div><div class="line">    指定了每一个real user ID可创建的inotify instatnces的数量上限</div><div class="line">/proc/sys/fs/inotify/max_user_watches</div><div class="line">    默认值: 8192</div><div class="line">    指定了每个inotify instance相关联的watches的上限，也就是每一个inotify实例可监控的最大目录数。如果监控的文件数目巨大，需要根据实际情况适当增加此值得大小。</div><div class="line"></div><div class="line">注意:</div><div class="line">    max_queued_events 是 Inotify 管理的队列的最大长度，文件系统变化越频繁，这个值就应该越大！如果你在日志中看到Event Queue Overflow，说明max_queued_events太小需要调整参数后再次使用</div></pre></td></tr></table></figure>
<p>优化参数配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo 104857600 &gt; /proc/sys/fs/inotify/max_user_watches</div></pre></td></tr></table></figure></p>
<p>inotify-tools 工具包中包含了两个命令</p>
<ul>
<li>inotifywait</li>
<li>inotifywatch</li>
</ul>
<h3 id="inotifywait"><a href="#inotifywait" class="headerlink" title="inotifywait"></a>inotifywait</h3><blockquote>
<p>inotifywait 仅执行阻塞，等待 inotify 事件，你可以使用它来监控任何一组文件和目录，或监控整个目录树（目录、子目录、子目录的子目录等等），并且可以结合 shell 脚本，更好的使用 inotifywait。</p>
</blockquote>
<p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inotifywait [-hcmrq] [-e &lt;event&gt; ] [-t &lt;seconds&gt; ] [--format &lt;fmt&gt; ] [--timefmt &lt;fmt&gt; ] &lt;file&gt; [ ... ]</div></pre></td></tr></table></figure></p>
<p>选项参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">-h|--help     	显示帮助信息</div><div class="line">@&lt;file&gt;       	排除不需要监视的文件，可以是相对路径，也可以是绝对路径</div><div class="line">--exclude &lt;pattern&gt;</div><div class="line">                正则匹配需要排除的文件，大小写敏感</div><div class="line">--excludei &lt;pattern&gt;</div><div class="line">                正则匹配需要排除的文件，忽略大小写。</div><div class="line">-m|--monitor  	接收到一个事情而不退出，无限期地执行。默认行为是接收到一个事情后立即退出</div><div class="line">-d|--daemon   	跟--monitor一样，除了是在后台运行，需要指定--outfile把事情输出到一个文件。也意味着使用了--syslog</div><div class="line">-r|--recursive	监视一个目录下的所有子目录</div><div class="line">--fromfile &lt;file&gt;</div><div class="line">                从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头</div><div class="line">-o|--outfile &lt;file&gt;</div><div class="line">                输出事件到文件.</div><div class="line">-s|--syslog   	输出错误信息到系统日志</div><div class="line">-q|--quiet    	不输出详细信息，只输出事件</div><div class="line">-qq           	除了致命错误，不会输出任何信息</div><div class="line">--timefmt &lt;fmt&gt;	指定时间格式，用于�format选项中的%T格式</div><div class="line">-c|--csv      	输出csv格式。</div><div class="line">-t|--timeout &lt;seconds&gt;</div><div class="line">                设置超时时间，如果为0，则无限期地执行下去。</div><div class="line">-e|--event &lt;event1&gt; [ -e|--event &lt;event2&gt; ... ]</div><div class="line">                指定监听的时间，如果省略，则侦听所有事件。</div><div class="line">--format &lt;fmt&gt;	指定输出格式</div><div class="line">     %w 表示发生事件的目录</div><div class="line">     %f 表示发生事件的文件</div><div class="line">     %e 表示发生的事件</div><div class="line">     %Xe 事件以“X”分隔</div><div class="line">     %T 使用由--timefmt定义的时间格式</div></pre></td></tr></table></figure></p>
<p>可监听的事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">access		    文件或者目录被读</div><div class="line">modify		    文件或目录被写入</div><div class="line">attrib		    文件或者目录属性被更改</div><div class="line">close_write	  文件或目录关闭，在写模式下打开后</div><div class="line">close_nowrite	文件或目录关闭，在只读模式打开后</div><div class="line">close		      文件或目录关闭，而不管是读/写模式</div><div class="line">open		      文件或目录被打开</div><div class="line">moved_to	    文件或者目录移动到监视目录</div><div class="line">moved_from	  文件或者目录移出监视目录</div><div class="line">move		      文件或目录移出或者移入目录</div><div class="line">create		    文件或目录被创建在监视目录</div><div class="line">delete		    文件或者目录被删除在监视目录</div><div class="line">delete_self	  文件或目录移除，之后不再监听此文件或目录</div><div class="line">unmount		    文件系统取消挂载，之后不再监听此文件系统</div></pre></td></tr></table></figure></p>
<p>示例1、监控<code>/data</code>目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inotifywait -rmq /data</div></pre></td></tr></table></figure></p>
<p>我们在另一个终端中想该目录中写入一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;test&quot; &gt;&gt; /data/newfile</div></pre></td></tr></table></figure></p>
<p>这个时候我们就会在前一个终端中看到如下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># inotifywait -rmq /data</div><div class="line">/data/ CREATE newfile</div><div class="line">/data/ OPEN newfile</div><div class="line">/data/ MODIFY newfile</div><div class="line">/data/ CLOSE_WRITE,CLOSE newfile</div></pre></td></tr></table></figure></p>
<p>如上所示，我们监控的了对于newfile文件的 CREATE、OPEN、MODIFY、CLOSE_WRITE、CLOSE等事件。</p>
<p>示例2、实时监控对<code>/etc/passwd</code> 文件的修改、删除和权限相关时间，并且按照指定格式输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># inotifywait -mrq --timefmt &apos;%d/%m/%y %H:%M&apos; --format  &apos;%T %w%f %e&apos; --event modify,delete,attrib  /etc/passwd</div></pre></td></tr></table></figure></p>
<p>这是我们在另一终端创建一个新用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># useradd testuser</div></pre></td></tr></table></figure></p>
<p>这时在前一个终端中就会监控到一个ATTRIB 事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># inotifywait -mrq --timefmt &apos;%d/%m/%y %H:%M&apos; --format  &apos;%T %w%f %e&apos; --event modify,delete,attrib  /etc/passwd</div><div class="line">29/10/16 16:59 /etc/passwd ATTRIB</div></pre></td></tr></table></figure></p>
<p>示例3、实现对 /data/web 目录进行监控，监控文件删除，修改，创建和权限相关事件，并且要求将监控信息写入/var/log/web_watch.log。要求日志条目要清晰明了，能突显文件路径、事件名和时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># cat web_watch.sh</div><div class="line">#!/bin/bash</div><div class="line">inotifywait -mrq --timefmt &apos;%y/%m/%d %H:%M&apos; --format  &apos;%T %w%f %e&apos; --event delete,modify,create,attrib  /data/web | while read  date time file event</div><div class="line">  do</div><div class="line">      case $event in</div><div class="line">          MODIFY|CREATE|MOVE|MODIFY,ISDIR|CREATE,ISDIR|MODIFY,ISDIR)</div><div class="line">                  echo $event&apos;-&apos;$file&apos;-&apos;$date&apos;-&apos;$time &gt;&gt; /var/log/web_watch.log</div><div class="line">              ;;</div><div class="line"></div><div class="line">          MOVED_FROM|MOVED_FROM,ISDIR|DELETE|DELETE,ISDIR)</div><div class="line">                  echo $event&apos;-&apos;$file&apos;-&apos;$date&apos;-&apos;$time /var/log/web_watch.log</div><div class="line">              ;;</div><div class="line">      esac</div><div class="line">  done</div></pre></td></tr></table></figure>
<p>运行脚本后，在另一个终端操作后，查看<code>/var/log/web_watch.log</code>日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cat /var/log/web_watch.log</div><div class="line">CREATE-/data/web/a-14/06/27-16:21</div><div class="line">CREATE-/data/web/aa-14/06/27-16:21</div><div class="line">CREATE-/data/web/aaaa-14/06/27-16:24</div><div class="line">CREATE-/data/web/aaaaa-14/06/27-16:24</div></pre></td></tr></table></figure></p>
<p>更多的使用方式，请查看 inotifywatch man page</p>
<h3 id="inotifywatch"><a href="#inotifywatch" class="headerlink" title="inotifywatch"></a>inotifywatch</h3><blockquote>
<p>inotifywatch 用来收集关于被监视的文件系统的统计数据，包括每个 inotify 事件发生多少次。</p>
</blockquote>
<p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inotifywatch  [-hvzrqf]  [-e  &lt;event&gt;  ] [-t &lt;seconds&gt; ] [-a &lt;event&gt; ] [-d &lt;event&gt; ] &lt;file&gt; [ ... ]</div></pre></td></tr></table></figure></p>
<p>选项参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-h|--help    	            显示帮助信息</div><div class="line">-v|--verbose 	            详细信息</div><div class="line">@&lt;file&gt;       	          排除不需要监视的文件，可以是相对路径，也可以是绝对路径</div><div class="line">--fromfile &lt;file&gt;         从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头</div><div class="line">--exclude &lt;pattern&gt;       正则匹配需要排除的文件，大小写敏感</div><div class="line">--excludei &lt;pattern&gt;      正则匹配需要排除的文件，忽略大小写。</div><div class="line">-z|--zero                 输出表格的行和列，即使元素为空</div><div class="line">-r|--recursive	          监视一个目录下的所有子目录</div><div class="line">-t|--timeout &lt;seconds&gt;</div><div class="line">                          设置超时时间，如果为0，则无限期地执行下去。</div><div class="line">-e|--event &lt;event1&gt; [ -e|--event &lt;event2&gt; ... ]</div><div class="line">                          指定监听的时间，如果省略，则侦听所有事件。</div><div class="line">-a|--ascending &lt;event&gt;    以指定事件升序排列</div><div class="line">-d|--descending &lt;event&gt;   以指定事件降序排列</div></pre></td></tr></table></figure></p>
<p>示例1、统计/data目录所在文件系统发生的事件次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inotifywatch -v -e create,modify,delete -t 30 -r /data</div></pre></td></tr></table></figure></p>
<p>然后在另一终端中进行一些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># echo &quot;test&quot; &gt;&gt; /data/newfile1</div><div class="line">...</div><div class="line"># rm /data/newfile</div><div class="line">rm：是否删除普通文件 &quot;/data/newfile&quot;？y</div><div class="line"># rm /data/newfile1</div><div class="line">rm：是否删除普通文件 &quot;/data/newfile1&quot;？y</div></pre></td></tr></table></figure></p>
<p>30秒后，前一个终端会生成如下报告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># inotifywatch -v -e create,modify,delete -t 30 -r /data</div><div class="line">Establishing watches...</div><div class="line">Setting up watch(es) on /data</div><div class="line">OK, /data is now being watched.</div><div class="line">Total of 1 watches.</div><div class="line">Finished establishing watches, now collecting statistics.</div><div class="line">Will listen for events for 30 seconds.</div><div class="line">total  modify  create  delete  filename</div><div class="line">11     8       1       2       /data/</div></pre></td></tr></table></figure></p>
<p>更多的使用方式，请查看 inotifywatch man page</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;inotify-tools 是一个用C语言库，一个为Linux提供简单inotify接口的命令行程序。这些程序可以用于监视文件系统事件并执行相应操作。这些程序是用C语言来写的，除了需要Linux内核的inotify支持外，没有其他的依赖。inotify-tools 3.14是目前最新版本，其于2010年3月7日发布。&lt;/p&gt;
&lt;p&gt;那么什么inotify又是什么？&lt;/p&gt;
&lt;p&gt;inotify，它是Linux在内核 2.6.13 (June 18, 2005)版本中引入的一个新功能，它为用户态监视文件系统的变化提供了强大的支持，允许监控程序打开一个独立文件描述符，并针对事件集监控一个或者多个文件，例如打开、关闭、移动/重命名、删除、创建或者改变属性。&lt;/p&gt;
&lt;p&gt;官方站点地址：&lt;a href=&quot;http://inotify-tools.sourceforge.net/&quot;&gt;http://inotify-tools.sourceforge.net/&lt;/a&gt;&lt;br&gt;Github地址：&lt;a href=&quot;https://github.com/rvoicilas/inotify-tools&quot;&gt;https://github.com/rvoicilas/inotify-tools&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
      <category term="inotify" scheme="https://weizhimiao.github.io/tags/inotify/"/>
    
  </entry>
  
</feed>
